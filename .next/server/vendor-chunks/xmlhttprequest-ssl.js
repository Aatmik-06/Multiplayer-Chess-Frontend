/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/xmlhttprequest-ssl";
exports.ids = ["vendor-chunks/xmlhttprequest-ssl"];
exports.modules = {

/***/ "(ssr)/./node_modules/xmlhttprequest-ssl/lib/XMLHttpRequest.js":
/*!***************************************************************!*\
  !*** ./node_modules/xmlhttprequest-ssl/lib/XMLHttpRequest.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\r\n * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.\r\n *\r\n * This can be used with JS designed for browsers to improve reuse of code and\r\n * allow the use of existing libraries.\r\n *\r\n * Usage: include(\"XMLHttpRequest.js\") and use XMLHttpRequest per W3C specs.\r\n *\r\n * @author Dan DeFelippi <dan@driverdan.com>\r\n * @contributor David Ellis <d.f.ellis@ieee.org>\r\n * @license MIT\r\n */\r\n\r\nvar fs = __webpack_require__(/*! fs */ \"fs\");\r\nvar Url = __webpack_require__(/*! url */ \"url\");\r\nvar spawn = (__webpack_require__(/*! child_process */ \"child_process\").spawn);\r\n\r\n/**\r\n * Module exports.\r\n */\r\n\r\nmodule.exports = XMLHttpRequest;\r\n\r\n// backwards-compat\r\nXMLHttpRequest.XMLHttpRequest = XMLHttpRequest;\r\n\r\n/**\r\n * `XMLHttpRequest` constructor.\r\n *\r\n * Supported options for the `opts` object are:\r\n *\r\n *  - `agent`: An http.Agent instance; http.globalAgent may be used; if 'undefined', agent usage is disabled\r\n *\r\n * @param {Object} opts optional \"options\" object\r\n */\r\n\r\nfunction XMLHttpRequest(opts) {\r\n  \"use strict\";\r\n\r\n  opts = opts || {};\r\n\r\n  /**\r\n   * Private variables\r\n   */\r\n  var self = this;\r\n  var http = __webpack_require__(/*! http */ \"http\");\r\n  var https = __webpack_require__(/*! https */ \"https\");\r\n\r\n  // Holds http.js objects\r\n  var request;\r\n  var response;\r\n\r\n  // Request settings\r\n  var settings = {};\r\n\r\n  // Disable header blacklist.\r\n  // Not part of XHR specs.\r\n  var disableHeaderCheck = false;\r\n\r\n  // Set some default headers\r\n  var defaultHeaders = {\r\n    \"User-Agent\": \"node-XMLHttpRequest\",\r\n    \"Accept\": \"*/*\"\r\n  };\r\n\r\n  var headers = Object.assign({}, defaultHeaders);\r\n\r\n  // These headers are not user setable.\r\n  // The following are allowed but banned in the spec:\r\n  // * user-agent\r\n  var forbiddenRequestHeaders = [\r\n    \"accept-charset\",\r\n    \"accept-encoding\",\r\n    \"access-control-request-headers\",\r\n    \"access-control-request-method\",\r\n    \"connection\",\r\n    \"content-length\",\r\n    \"content-transfer-encoding\",\r\n    \"cookie\",\r\n    \"cookie2\",\r\n    \"date\",\r\n    \"expect\",\r\n    \"host\",\r\n    \"keep-alive\",\r\n    \"origin\",\r\n    \"referer\",\r\n    \"te\",\r\n    \"trailer\",\r\n    \"transfer-encoding\",\r\n    \"upgrade\",\r\n    \"via\"\r\n  ];\r\n\r\n  // These request methods are not allowed\r\n  var forbiddenRequestMethods = [\r\n    \"TRACE\",\r\n    \"TRACK\",\r\n    \"CONNECT\"\r\n  ];\r\n\r\n  // Send flag\r\n  var sendFlag = false;\r\n  // Error flag, used when errors occur or abort is called\r\n  var errorFlag = false;\r\n  var abortedFlag = false;\r\n\r\n  // Event listeners\r\n  var listeners = {};\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  this.UNSENT = 0;\r\n  this.OPENED = 1;\r\n  this.HEADERS_RECEIVED = 2;\r\n  this.LOADING = 3;\r\n  this.DONE = 4;\r\n\r\n  /**\r\n   * Public vars\r\n   */\r\n\r\n  // Current state\r\n  this.readyState = this.UNSENT;\r\n\r\n  // default ready state change handler in case one is not set or is set late\r\n  this.onreadystatechange = null;\r\n\r\n  // Result & response\r\n  this.responseText = \"\";\r\n  this.responseXML = \"\";\r\n  this.response = Buffer.alloc(0);\r\n  this.status = null;\r\n  this.statusText = null;\r\n\r\n  /**\r\n   * Private methods\r\n   */\r\n\r\n  /**\r\n   * Check if the specified header is allowed.\r\n   *\r\n   * @param string header Header to validate\r\n   * @return boolean False if not allowed, otherwise true\r\n   */\r\n  var isAllowedHttpHeader = function(header) {\r\n    return disableHeaderCheck || (header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1);\r\n  };\r\n\r\n  /**\r\n   * Check if the specified method is allowed.\r\n   *\r\n   * @param string method Request method to validate\r\n   * @return boolean False if not allowed, otherwise true\r\n   */\r\n  var isAllowedHttpMethod = function(method) {\r\n    return (method && forbiddenRequestMethods.indexOf(method) === -1);\r\n  };\r\n\r\n  /**\r\n   * Public methods\r\n   */\r\n\r\n  /**\r\n   * Open the connection. Currently supports local server requests.\r\n   *\r\n   * @param string method Connection method (eg GET, POST)\r\n   * @param string url URL for the connection.\r\n   * @param boolean async Asynchronous connection. Default is true.\r\n   * @param string user Username for basic authentication (optional)\r\n   * @param string password Password for basic authentication (optional)\r\n   */\r\n  this.open = function(method, url, async, user, password) {\r\n    this.abort();\r\n    errorFlag = false;\r\n    abortedFlag = false;\r\n\r\n    // Check for valid request method\r\n    if (!isAllowedHttpMethod(method)) {\r\n      throw new Error(\"SecurityError: Request method not allowed\");\r\n    }\r\n\r\n    settings = {\r\n      \"method\": method,\r\n      \"url\": url.toString(),\r\n      \"async\": (typeof async !== \"boolean\" ? true : async),\r\n      \"user\": user || null,\r\n      \"password\": password || null\r\n    };\r\n\r\n    setState(this.OPENED);\r\n  };\r\n\r\n  /**\r\n   * Disables or enables isAllowedHttpHeader() check the request. Enabled by default.\r\n   * This does not conform to the W3C spec.\r\n   *\r\n   * @param boolean state Enable or disable header checking.\r\n   */\r\n  this.setDisableHeaderCheck = function(state) {\r\n    disableHeaderCheck = state;\r\n  };\r\n\r\n  /**\r\n   * Sets a header for the request.\r\n   *\r\n   * @param string header Header name\r\n   * @param string value Header value\r\n   * @return boolean Header added\r\n   */\r\n  this.setRequestHeader = function(header, value) {\r\n    if (this.readyState != this.OPENED) {\r\n      throw new Error(\"INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN\");\r\n    }\r\n    if (!isAllowedHttpHeader(header)) {\r\n      console.warn('Refused to set unsafe header \"' + header + '\"');\r\n      return false;\r\n    }\r\n    if (sendFlag) {\r\n      throw new Error(\"INVALID_STATE_ERR: send flag is true\");\r\n    }\r\n    headers[header] = value;\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Gets a header from the server response.\r\n   *\r\n   * @param string header Name of header to get.\r\n   * @return string Text of the header or null if it doesn't exist.\r\n   */\r\n  this.getResponseHeader = function(header) {\r\n    if (typeof header === \"string\"\r\n      && this.readyState > this.OPENED\r\n      && response.headers[header.toLowerCase()]\r\n      && !errorFlag\r\n    ) {\r\n      return response.headers[header.toLowerCase()];\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  /**\r\n   * Gets all the response headers.\r\n   *\r\n   * @return string A string with all response headers separated by CR+LF\r\n   */\r\n  this.getAllResponseHeaders = function() {\r\n    if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {\r\n      return \"\";\r\n    }\r\n    var result = \"\";\r\n\r\n    for (var i in response.headers) {\r\n      // Cookie headers are excluded\r\n      if (i !== \"set-cookie\" && i !== \"set-cookie2\") {\r\n        result += i + \": \" + response.headers[i] + \"\\r\\n\";\r\n      }\r\n    }\r\n    return result.substr(0, result.length - 2);\r\n  };\r\n\r\n  /**\r\n   * Gets a request header\r\n   *\r\n   * @param string name Name of header to get\r\n   * @return string Returns the request header or empty string if not set\r\n   */\r\n  this.getRequestHeader = function(name) {\r\n    // @TODO Make this case insensitive\r\n    if (typeof name === \"string\" && headers[name]) {\r\n      return headers[name];\r\n    }\r\n\r\n    return \"\";\r\n  };\r\n\r\n  /**\r\n   * Sends the request to the server.\r\n   *\r\n   * @param string data Optional data to send as request body.\r\n   */\r\n  this.send = function(data) {\r\n    if (this.readyState != this.OPENED) {\r\n      throw new Error(\"INVALID_STATE_ERR: connection must be opened before send() is called\");\r\n    }\r\n\r\n    if (sendFlag) {\r\n      throw new Error(\"INVALID_STATE_ERR: send has already been called\");\r\n    }\r\n\r\n    var ssl = false, local = false;\r\n    var url = Url.parse(settings.url);\r\n    var host;\r\n    // Determine the server\r\n    switch (url.protocol) {\r\n      case 'https:':\r\n        ssl = true;\r\n        // SSL & non-SSL both need host, no break here.\r\n      case 'http:':\r\n        host = url.hostname;\r\n        break;\r\n\r\n      case 'file:':\r\n        local = true;\r\n        break;\r\n\r\n      case undefined:\r\n      case '':\r\n        host = \"localhost\";\r\n        break;\r\n\r\n      default:\r\n        throw new Error(\"Protocol not supported.\");\r\n    }\r\n\r\n    // Load files off the local filesystem (file://)\r\n    if (local) {\r\n      if (settings.method !== \"GET\") {\r\n        throw new Error(\"XMLHttpRequest: Only GET method is supported\");\r\n      }\r\n\r\n      if (settings.async) {\r\n        fs.readFile(unescape(url.pathname), function(error, data) {\r\n          if (error) {\r\n            self.handleError(error, error.errno || -1);\r\n          } else {\r\n            self.status = 200;\r\n            self.responseText = data.toString('utf8');\r\n            self.response = data;\r\n            setState(self.DONE);\r\n          }\r\n        });\r\n      } else {\r\n        try {\r\n          this.response = fs.readFileSync(unescape(url.pathname));\r\n          this.responseText = this.response.toString('utf8');\r\n          this.status = 200;\r\n          setState(self.DONE);\r\n        } catch(e) {\r\n          this.handleError(e, e.errno || -1);\r\n        }\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    // Default to port 80. If accessing localhost on another port be sure\r\n    // to use http://localhost:port/path\r\n    var port = url.port || (ssl ? 443 : 80);\r\n    // Add query string if one is used\r\n    var uri = url.pathname + (url.search ? url.search : '');\r\n\r\n    // Set the Host header or the server may reject the request\r\n    headers[\"Host\"] = host;\r\n    if (!((ssl && port === 443) || port === 80)) {\r\n      headers[\"Host\"] += ':' + url.port;\r\n    }\r\n\r\n    // Set Basic Auth if necessary\r\n    if (settings.user) {\r\n      if (typeof settings.password == \"undefined\") {\r\n        settings.password = \"\";\r\n      }\r\n      var authBuf = new Buffer(settings.user + \":\" + settings.password);\r\n      headers[\"Authorization\"] = \"Basic \" + authBuf.toString(\"base64\");\r\n    }\r\n\r\n    // Set content length header\r\n    if (settings.method === \"GET\" || settings.method === \"HEAD\") {\r\n      data = null;\r\n    } else if (data) {\r\n      headers[\"Content-Length\"] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);\r\n\r\n      var headersKeys = Object.keys(headers);\r\n      if (!headersKeys.some(function (h) { return h.toLowerCase() === 'content-type' })) {\r\n        headers[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\r\n      }\r\n    } else if (settings.method === \"POST\") {\r\n      // For a post with no data set Content-Length: 0.\r\n      // This is required by buggy servers that don't meet the specs.\r\n      headers[\"Content-Length\"] = 0;\r\n    }\r\n\r\n    var agent = opts.agent || false;\r\n    var options = {\r\n      host: host,\r\n      port: port,\r\n      path: uri,\r\n      method: settings.method,\r\n      headers: headers,\r\n      agent: agent\r\n    };\r\n\r\n    if (ssl) {\r\n      options.pfx = opts.pfx;\r\n      options.key = opts.key;\r\n      options.passphrase = opts.passphrase;\r\n      options.cert = opts.cert;\r\n      options.ca = opts.ca;\r\n      options.ciphers = opts.ciphers;\r\n      options.rejectUnauthorized = opts.rejectUnauthorized === false ? false : true;\r\n    }\r\n\r\n    // Reset error flag\r\n    errorFlag = false;\r\n    // Handle async requests\r\n    if (settings.async) {\r\n      // Use the proper protocol\r\n      var doRequest = ssl ? https.request : http.request;\r\n\r\n      // Request is being sent, set send flag\r\n      sendFlag = true;\r\n\r\n      // As per spec, this is called here for historical reasons.\r\n      self.dispatchEvent(\"readystatechange\");\r\n\r\n      // Handler for the response\r\n      var responseHandler = function(resp) {\r\n        // Set response var to the response we got back\r\n        // This is so it remains accessable outside this scope\r\n        response = resp;\r\n        // Check for redirect\r\n        // @TODO Prevent looped redirects\r\n        if (response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {\r\n          // Change URL to the redirect location\r\n          settings.url = response.headers.location;\r\n          var url = Url.parse(settings.url);\r\n          // Set host var in case it's used later\r\n          host = url.hostname;\r\n          // Options for the new request\r\n          var newOptions = {\r\n            hostname: url.hostname,\r\n            port: url.port,\r\n            path: url.path,\r\n            method: response.statusCode === 303 ? 'GET' : settings.method,\r\n            headers: headers\r\n          };\r\n\r\n          if (ssl) {\r\n            newOptions.pfx = opts.pfx;\r\n            newOptions.key = opts.key;\r\n            newOptions.passphrase = opts.passphrase;\r\n            newOptions.cert = opts.cert;\r\n            newOptions.ca = opts.ca;\r\n            newOptions.ciphers = opts.ciphers;\r\n            newOptions.rejectUnauthorized = opts.rejectUnauthorized === false ? false : true;\r\n          }\r\n\r\n          // Issue the new request\r\n          request = doRequest(newOptions, responseHandler).on('error', errorHandler);\r\n          request.end();\r\n          // @TODO Check if an XHR event needs to be fired here\r\n          return;\r\n        }\r\n\r\n        setState(self.HEADERS_RECEIVED);\r\n        self.status = response.statusCode;\r\n\r\n        response.on('data', function(chunk) {\r\n          // Make sure there's some data\r\n          if (chunk) {\r\n            var data = Buffer.from(chunk);\r\n            self.response = Buffer.concat([self.response, data]);\r\n          }\r\n          // Don't emit state changes if the connection has been aborted.\r\n          if (sendFlag) {\r\n            setState(self.LOADING);\r\n          }\r\n        });\r\n\r\n        response.on('end', function() {\r\n          if (sendFlag) {\r\n            // The sendFlag needs to be set before setState is called.  Otherwise if we are chaining callbacks\r\n            // there can be a timing issue (the callback is called and a new call is made before the flag is reset).\r\n            sendFlag = false;\r\n            // Discard the 'end' event if the connection has been aborted\r\n            setState(self.DONE);\r\n            // Construct responseText from response\r\n            self.responseText = self.response.toString('utf8');\r\n          }\r\n        });\r\n\r\n        response.on('error', function(error) {\r\n          self.handleError(error);\r\n        });\r\n      }\r\n\r\n      // Error handler for the request\r\n      var errorHandler = function(error) {\r\n        // In the case of https://nodejs.org/api/http.html#requestreusedsocket triggering an ECONNRESET,\r\n        // don't fail the xhr request, attempt again.\r\n        if (request.reusedSocket && error.code === 'ECONNRESET')\r\n          return doRequest(options, responseHandler).on('error', errorHandler);\r\n        self.handleError(error);\r\n      }\r\n\r\n      // Create the request\r\n      request = doRequest(options, responseHandler).on('error', errorHandler);\r\n\r\n      if (opts.autoUnref) {\r\n        request.on('socket', (socket) => {\r\n          socket.unref();\r\n        });\r\n      }\r\n\r\n      // Node 0.4 and later won't accept empty data. Make sure it's needed.\r\n      if (data) {\r\n        request.write(data);\r\n      }\r\n\r\n      request.end();\r\n\r\n      self.dispatchEvent(\"loadstart\");\r\n    } else { // Synchronous\r\n      // Create a temporary file for communication with the other Node process\r\n      var contentFile = \".node-xmlhttprequest-content-\" + process.pid;\r\n      var syncFile = \".node-xmlhttprequest-sync-\" + process.pid;\r\n      fs.writeFileSync(syncFile, \"\", \"utf8\");\r\n      // The async request the other Node process executes\r\n      var execString = \"var http = require('http'), https = require('https'), fs = require('fs');\"\r\n        + \"var doRequest = http\" + (ssl ? \"s\" : \"\") + \".request;\"\r\n        + \"var options = \" + JSON.stringify(options) + \";\"\r\n        + \"var responseText = '';\"\r\n        + \"var responseData = Buffer.alloc(0);\"\r\n        + \"var req = doRequest(options, function(response) {\"\r\n        + \"response.on('data', function(chunk) {\"\r\n        + \"  var data = Buffer.from(chunk);\"\r\n        + \"  responseText += data.toString('utf8');\"\r\n        + \"  responseData = Buffer.concat([responseData, data]);\"\r\n        + \"});\"\r\n        + \"response.on('end', function() {\"\r\n        + \"fs.writeFileSync('\" + contentFile + \"', JSON.stringify({err: null, data: {statusCode: response.statusCode, headers: response.headers, text: responseText, data: responseData.toString('base64')}}), 'utf8');\"\r\n        + \"fs.unlinkSync('\" + syncFile + \"');\"\r\n        + \"});\"\r\n        + \"response.on('error', function(error) {\"\r\n        + \"fs.writeFileSync('\" + contentFile + \"', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');\"\r\n        + \"fs.unlinkSync('\" + syncFile + \"');\"\r\n        + \"});\"\r\n        + \"}).on('error', function(error) {\"\r\n        + \"fs.writeFileSync('\" + contentFile + \"', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');\"\r\n        + \"fs.unlinkSync('\" + syncFile + \"');\"\r\n        + \"});\"\r\n        + (data ? \"req.write('\" + JSON.stringify(data).slice(1,-1).replace(/'/g, \"\\\\'\") + \"');\":\"\")\r\n        + \"req.end();\";\r\n      // Start the other Node Process, executing this string\r\n      var syncProc = spawn(process.argv[0], [\"-e\", execString]);\r\n      var statusText;\r\n      while(fs.existsSync(syncFile)) {\r\n        // Wait while the sync file is empty\r\n      }\r\n      self.responseText = fs.readFileSync(contentFile, 'utf8');\r\n      // Kill the child process once the file has data\r\n      syncProc.stdin.end();\r\n      // Remove the temporary file\r\n      fs.unlinkSync(contentFile);\r\n      if (self.responseText.match(/^NODE-XMLHTTPREQUEST-ERROR:/)) {\r\n        // If the file returned an error, handle it\r\n        var errorObj = JSON.parse(self.responseText.replace(/^NODE-XMLHTTPREQUEST-ERROR:/, \"\"));\r\n        self.handleError(errorObj, 503);\r\n      } else {\r\n        // If the file returned okay, parse its data and move to the DONE state\r\n        self.status = self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:([0-9]*),.*/, \"$1\");\r\n        var resp = JSON.parse(self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:[0-9]*,(.*)/, \"$1\"));\r\n        response = {\r\n          statusCode: self.status,\r\n          headers: resp.data.headers\r\n        };\r\n        self.responseText = resp.data.text;\r\n        self.response = Buffer.from(resp.data.data, 'base64');\r\n        setState(self.DONE, true);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Called when an error is encountered to deal with it.\r\n   * @param  status  {number}    HTTP status code to use rather than the default (0) for XHR errors.\r\n   */\r\n  this.handleError = function(error, status) {\r\n    this.status = status || 0;\r\n    this.statusText = error;\r\n    this.responseText = error.stack;\r\n    errorFlag = true;\r\n    setState(this.DONE);\r\n  };\r\n\r\n  /**\r\n   * Aborts a request.\r\n   */\r\n  this.abort = function() {\r\n    if (request) {\r\n      request.abort();\r\n      request = null;\r\n    }\r\n\r\n    headers = Object.assign({}, defaultHeaders);\r\n    this.responseText = \"\";\r\n    this.responseXML = \"\";\r\n    this.response = Buffer.alloc(0);\r\n\r\n    errorFlag = abortedFlag = true\r\n    if (this.readyState !== this.UNSENT\r\n        && (this.readyState !== this.OPENED || sendFlag)\r\n        && this.readyState !== this.DONE) {\r\n      sendFlag = false;\r\n      setState(this.DONE);\r\n    }\r\n    this.readyState = this.UNSENT;\r\n  };\r\n\r\n  /**\r\n   * Adds an event listener. Preferred method of binding to events.\r\n   */\r\n  this.addEventListener = function(event, callback) {\r\n    if (!(event in listeners)) {\r\n      listeners[event] = [];\r\n    }\r\n    // Currently allows duplicate callbacks. Should it?\r\n    listeners[event].push(callback);\r\n  };\r\n\r\n  /**\r\n   * Remove an event callback that has already been bound.\r\n   * Only works on the matching funciton, cannot be a copy.\r\n   */\r\n  this.removeEventListener = function(event, callback) {\r\n    if (event in listeners) {\r\n      // Filter will return a new array with the callback removed\r\n      listeners[event] = listeners[event].filter(function(ev) {\r\n        return ev !== callback;\r\n      });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Dispatch any events, including both \"on\" methods and events attached using addEventListener.\r\n   */\r\n  this.dispatchEvent = function (event) {\r\n    if (typeof self[\"on\" + event] === \"function\") {\r\n      if (this.readyState === this.DONE && settings.async)\r\n        setTimeout(function() { self[\"on\" + event]() }, 0)\r\n      else\r\n        self[\"on\" + event]()\r\n    }\r\n    if (event in listeners) {\r\n      for (let i = 0, len = listeners[event].length; i < len; i++) {\r\n        if (this.readyState === this.DONE)\r\n          setTimeout(function() { listeners[event][i].call(self) }, 0)\r\n        else\r\n          listeners[event][i].call(self)\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Changes readyState and calls onreadystatechange.\r\n   *\r\n   * @param int state New state\r\n   */\r\n  var setState = function(state) {\r\n    if ((self.readyState === state) || (self.readyState === self.UNSENT && abortedFlag))\r\n      return\r\n\r\n    self.readyState = state;\r\n\r\n    if (settings.async || self.readyState < self.OPENED || self.readyState === self.DONE) {\r\n      self.dispatchEvent(\"readystatechange\");\r\n    }\r\n\r\n    if (self.readyState === self.DONE) {\r\n      let fire\r\n\r\n      if (abortedFlag)\r\n        fire = \"abort\"\r\n      else if (errorFlag)\r\n        fire = \"error\"\r\n      else\r\n        fire = \"load\"\r\n\r\n      self.dispatchEvent(fire)\r\n\r\n      // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)\r\n      self.dispatchEvent(\"loadend\");\r\n    }\r\n  };\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveG1saHR0cHJlcXVlc3Qtc3NsL2xpYi9YTUxIdHRwUmVxdWVzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsbUJBQU8sQ0FBQyxjQUFJO0FBQ3JCLFVBQVUsbUJBQU8sQ0FBQyxnQkFBSztBQUN2QixZQUFZLGlFQUE4QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsOEJBQThCO0FBQ3JFO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsY0FBYyxtQkFBTyxDQUFDLG9CQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywyQ0FBMkM7QUFDdEYsOENBQThDO0FBQzlDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxPQUFPO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRztBQUNqRyxnRUFBZ0U7QUFDaEUseURBQXlEO0FBQ3pELGlDQUFpQztBQUNqQyw4Q0FBOEM7QUFDOUMsNERBQTREO0FBQzVELGdEQUFnRDtBQUNoRCwyQ0FBMkM7QUFDM0MsbURBQW1EO0FBQ25ELGdFQUFnRTtBQUNoRSxZQUFZLEVBQUU7QUFDZCwwQ0FBMEM7QUFDMUMsbUVBQW1FLGtCQUFrQix1SEFBdUgsV0FBVztBQUN2Tiw2Q0FBNkM7QUFDN0MsWUFBWSxFQUFFO0FBQ2QsaURBQWlEO0FBQ2pELGlIQUFpSDtBQUNqSCw2Q0FBNkM7QUFDN0MsWUFBWSxFQUFFO0FBQ2QsWUFBWSwrQkFBK0I7QUFDM0MsaUhBQWlIO0FBQ2pILDZDQUE2QztBQUM3QyxZQUFZLEVBQUU7QUFDZCw4RkFBOEY7QUFDOUYscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msc0JBQXNCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFNBQVM7QUFDOUQ7QUFDQSxrQ0FBa0MsZ0NBQWdDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMveG1saHR0cHJlcXVlc3Qtc3NsL2xpYi9YTUxIdHRwUmVxdWVzdC5qcz9lYTM2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBXcmFwcGVyIGZvciBidWlsdC1pbiBodHRwLmpzIHRvIGVtdWxhdGUgdGhlIGJyb3dzZXIgWE1MSHR0cFJlcXVlc3Qgb2JqZWN0LlxyXG4gKlxyXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHdpdGggSlMgZGVzaWduZWQgZm9yIGJyb3dzZXJzIHRvIGltcHJvdmUgcmV1c2Ugb2YgY29kZSBhbmRcclxuICogYWxsb3cgdGhlIHVzZSBvZiBleGlzdGluZyBsaWJyYXJpZXMuXHJcbiAqXHJcbiAqIFVzYWdlOiBpbmNsdWRlKFwiWE1MSHR0cFJlcXVlc3QuanNcIikgYW5kIHVzZSBYTUxIdHRwUmVxdWVzdCBwZXIgVzNDIHNwZWNzLlxyXG4gKlxyXG4gKiBAYXV0aG9yIERhbiBEZUZlbGlwcGkgPGRhbkBkcml2ZXJkYW4uY29tPlxyXG4gKiBAY29udHJpYnV0b3IgRGF2aWQgRWxsaXMgPGQuZi5lbGxpc0BpZWVlLm9yZz5cclxuICogQGxpY2Vuc2UgTUlUXHJcbiAqL1xyXG5cclxudmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcclxudmFyIFVybCA9IHJlcXVpcmUoJ3VybCcpO1xyXG52YXIgc3Bhd24gPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuc3Bhd247XHJcblxyXG4vKipcclxuICogTW9kdWxlIGV4cG9ydHMuXHJcbiAqL1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBYTUxIdHRwUmVxdWVzdDtcclxuXHJcbi8vIGJhY2t3YXJkcy1jb21wYXRcclxuWE1MSHR0cFJlcXVlc3QuWE1MSHR0cFJlcXVlc3QgPSBYTUxIdHRwUmVxdWVzdDtcclxuXHJcbi8qKlxyXG4gKiBgWE1MSHR0cFJlcXVlc3RgIGNvbnN0cnVjdG9yLlxyXG4gKlxyXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBmb3IgdGhlIGBvcHRzYCBvYmplY3QgYXJlOlxyXG4gKlxyXG4gKiAgLSBgYWdlbnRgOiBBbiBodHRwLkFnZW50IGluc3RhbmNlOyBodHRwLmdsb2JhbEFnZW50IG1heSBiZSB1c2VkOyBpZiAndW5kZWZpbmVkJywgYWdlbnQgdXNhZ2UgaXMgZGlzYWJsZWRcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgb3B0aW9uYWwgXCJvcHRpb25zXCIgb2JqZWN0XHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gWE1MSHR0cFJlcXVlc3Qob3B0cykge1xyXG4gIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICBvcHRzID0gb3B0cyB8fCB7fTtcclxuXHJcbiAgLyoqXHJcbiAgICogUHJpdmF0ZSB2YXJpYWJsZXNcclxuICAgKi9cclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgdmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XHJcbiAgdmFyIGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcclxuXHJcbiAgLy8gSG9sZHMgaHR0cC5qcyBvYmplY3RzXHJcbiAgdmFyIHJlcXVlc3Q7XHJcbiAgdmFyIHJlc3BvbnNlO1xyXG5cclxuICAvLyBSZXF1ZXN0IHNldHRpbmdzXHJcbiAgdmFyIHNldHRpbmdzID0ge307XHJcblxyXG4gIC8vIERpc2FibGUgaGVhZGVyIGJsYWNrbGlzdC5cclxuICAvLyBOb3QgcGFydCBvZiBYSFIgc3BlY3MuXHJcbiAgdmFyIGRpc2FibGVIZWFkZXJDaGVjayA9IGZhbHNlO1xyXG5cclxuICAvLyBTZXQgc29tZSBkZWZhdWx0IGhlYWRlcnNcclxuICB2YXIgZGVmYXVsdEhlYWRlcnMgPSB7XHJcbiAgICBcIlVzZXItQWdlbnRcIjogXCJub2RlLVhNTEh0dHBSZXF1ZXN0XCIsXHJcbiAgICBcIkFjY2VwdFwiOiBcIiovKlwiXHJcbiAgfTtcclxuXHJcbiAgdmFyIGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0SGVhZGVycyk7XHJcblxyXG4gIC8vIFRoZXNlIGhlYWRlcnMgYXJlIG5vdCB1c2VyIHNldGFibGUuXHJcbiAgLy8gVGhlIGZvbGxvd2luZyBhcmUgYWxsb3dlZCBidXQgYmFubmVkIGluIHRoZSBzcGVjOlxyXG4gIC8vICogdXNlci1hZ2VudFxyXG4gIHZhciBmb3JiaWRkZW5SZXF1ZXN0SGVhZGVycyA9IFtcclxuICAgIFwiYWNjZXB0LWNoYXJzZXRcIixcclxuICAgIFwiYWNjZXB0LWVuY29kaW5nXCIsXHJcbiAgICBcImFjY2Vzcy1jb250cm9sLXJlcXVlc3QtaGVhZGVyc1wiLFxyXG4gICAgXCJhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LW1ldGhvZFwiLFxyXG4gICAgXCJjb25uZWN0aW9uXCIsXHJcbiAgICBcImNvbnRlbnQtbGVuZ3RoXCIsXHJcbiAgICBcImNvbnRlbnQtdHJhbnNmZXItZW5jb2RpbmdcIixcclxuICAgIFwiY29va2llXCIsXHJcbiAgICBcImNvb2tpZTJcIixcclxuICAgIFwiZGF0ZVwiLFxyXG4gICAgXCJleHBlY3RcIixcclxuICAgIFwiaG9zdFwiLFxyXG4gICAgXCJrZWVwLWFsaXZlXCIsXHJcbiAgICBcIm9yaWdpblwiLFxyXG4gICAgXCJyZWZlcmVyXCIsXHJcbiAgICBcInRlXCIsXHJcbiAgICBcInRyYWlsZXJcIixcclxuICAgIFwidHJhbnNmZXItZW5jb2RpbmdcIixcclxuICAgIFwidXBncmFkZVwiLFxyXG4gICAgXCJ2aWFcIlxyXG4gIF07XHJcblxyXG4gIC8vIFRoZXNlIHJlcXVlc3QgbWV0aG9kcyBhcmUgbm90IGFsbG93ZWRcclxuICB2YXIgZm9yYmlkZGVuUmVxdWVzdE1ldGhvZHMgPSBbXHJcbiAgICBcIlRSQUNFXCIsXHJcbiAgICBcIlRSQUNLXCIsXHJcbiAgICBcIkNPTk5FQ1RcIlxyXG4gIF07XHJcblxyXG4gIC8vIFNlbmQgZmxhZ1xyXG4gIHZhciBzZW5kRmxhZyA9IGZhbHNlO1xyXG4gIC8vIEVycm9yIGZsYWcsIHVzZWQgd2hlbiBlcnJvcnMgb2NjdXIgb3IgYWJvcnQgaXMgY2FsbGVkXHJcbiAgdmFyIGVycm9yRmxhZyA9IGZhbHNlO1xyXG4gIHZhciBhYm9ydGVkRmxhZyA9IGZhbHNlO1xyXG5cclxuICAvLyBFdmVudCBsaXN0ZW5lcnNcclxuICB2YXIgbGlzdGVuZXJzID0ge307XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0YW50c1xyXG4gICAqL1xyXG5cclxuICB0aGlzLlVOU0VOVCA9IDA7XHJcbiAgdGhpcy5PUEVORUQgPSAxO1xyXG4gIHRoaXMuSEVBREVSU19SRUNFSVZFRCA9IDI7XHJcbiAgdGhpcy5MT0FESU5HID0gMztcclxuICB0aGlzLkRPTkUgPSA0O1xyXG5cclxuICAvKipcclxuICAgKiBQdWJsaWMgdmFyc1xyXG4gICAqL1xyXG5cclxuICAvLyBDdXJyZW50IHN0YXRlXHJcbiAgdGhpcy5yZWFkeVN0YXRlID0gdGhpcy5VTlNFTlQ7XHJcblxyXG4gIC8vIGRlZmF1bHQgcmVhZHkgc3RhdGUgY2hhbmdlIGhhbmRsZXIgaW4gY2FzZSBvbmUgaXMgbm90IHNldCBvciBpcyBzZXQgbGF0ZVxyXG4gIHRoaXMub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcclxuXHJcbiAgLy8gUmVzdWx0ICYgcmVzcG9uc2VcclxuICB0aGlzLnJlc3BvbnNlVGV4dCA9IFwiXCI7XHJcbiAgdGhpcy5yZXNwb25zZVhNTCA9IFwiXCI7XHJcbiAgdGhpcy5yZXNwb25zZSA9IEJ1ZmZlci5hbGxvYygwKTtcclxuICB0aGlzLnN0YXR1cyA9IG51bGw7XHJcbiAgdGhpcy5zdGF0dXNUZXh0ID0gbnVsbDtcclxuXHJcbiAgLyoqXHJcbiAgICogUHJpdmF0ZSBtZXRob2RzXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHRoZSBzcGVjaWZpZWQgaGVhZGVyIGlzIGFsbG93ZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gc3RyaW5nIGhlYWRlciBIZWFkZXIgdG8gdmFsaWRhdGVcclxuICAgKiBAcmV0dXJuIGJvb2xlYW4gRmFsc2UgaWYgbm90IGFsbG93ZWQsIG90aGVyd2lzZSB0cnVlXHJcbiAgICovXHJcbiAgdmFyIGlzQWxsb3dlZEh0dHBIZWFkZXIgPSBmdW5jdGlvbihoZWFkZXIpIHtcclxuICAgIHJldHVybiBkaXNhYmxlSGVhZGVyQ2hlY2sgfHwgKGhlYWRlciAmJiBmb3JiaWRkZW5SZXF1ZXN0SGVhZGVycy5pbmRleE9mKGhlYWRlci50b0xvd2VyQ2FzZSgpKSA9PT0gLTEpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHRoZSBzcGVjaWZpZWQgbWV0aG9kIGlzIGFsbG93ZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gc3RyaW5nIG1ldGhvZCBSZXF1ZXN0IG1ldGhvZCB0byB2YWxpZGF0ZVxyXG4gICAqIEByZXR1cm4gYm9vbGVhbiBGYWxzZSBpZiBub3QgYWxsb3dlZCwgb3RoZXJ3aXNlIHRydWVcclxuICAgKi9cclxuICB2YXIgaXNBbGxvd2VkSHR0cE1ldGhvZCA9IGZ1bmN0aW9uKG1ldGhvZCkge1xyXG4gICAgcmV0dXJuIChtZXRob2QgJiYgZm9yYmlkZGVuUmVxdWVzdE1ldGhvZHMuaW5kZXhPZihtZXRob2QpID09PSAtMSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUHVibGljIG1ldGhvZHNcclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogT3BlbiB0aGUgY29ubmVjdGlvbi4gQ3VycmVudGx5IHN1cHBvcnRzIGxvY2FsIHNlcnZlciByZXF1ZXN0cy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBzdHJpbmcgbWV0aG9kIENvbm5lY3Rpb24gbWV0aG9kIChlZyBHRVQsIFBPU1QpXHJcbiAgICogQHBhcmFtIHN0cmluZyB1cmwgVVJMIGZvciB0aGUgY29ubmVjdGlvbi5cclxuICAgKiBAcGFyYW0gYm9vbGVhbiBhc3luYyBBc3luY2hyb25vdXMgY29ubmVjdGlvbi4gRGVmYXVsdCBpcyB0cnVlLlxyXG4gICAqIEBwYXJhbSBzdHJpbmcgdXNlciBVc2VybmFtZSBmb3IgYmFzaWMgYXV0aGVudGljYXRpb24gKG9wdGlvbmFsKVxyXG4gICAqIEBwYXJhbSBzdHJpbmcgcGFzc3dvcmQgUGFzc3dvcmQgZm9yIGJhc2ljIGF1dGhlbnRpY2F0aW9uIChvcHRpb25hbClcclxuICAgKi9cclxuICB0aGlzLm9wZW4gPSBmdW5jdGlvbihtZXRob2QsIHVybCwgYXN5bmMsIHVzZXIsIHBhc3N3b3JkKSB7XHJcbiAgICB0aGlzLmFib3J0KCk7XHJcbiAgICBlcnJvckZsYWcgPSBmYWxzZTtcclxuICAgIGFib3J0ZWRGbGFnID0gZmFsc2U7XHJcblxyXG4gICAgLy8gQ2hlY2sgZm9yIHZhbGlkIHJlcXVlc3QgbWV0aG9kXHJcbiAgICBpZiAoIWlzQWxsb3dlZEh0dHBNZXRob2QobWV0aG9kKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWN1cml0eUVycm9yOiBSZXF1ZXN0IG1ldGhvZCBub3QgYWxsb3dlZFwiKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXR0aW5ncyA9IHtcclxuICAgICAgXCJtZXRob2RcIjogbWV0aG9kLFxyXG4gICAgICBcInVybFwiOiB1cmwudG9TdHJpbmcoKSxcclxuICAgICAgXCJhc3luY1wiOiAodHlwZW9mIGFzeW5jICE9PSBcImJvb2xlYW5cIiA/IHRydWUgOiBhc3luYyksXHJcbiAgICAgIFwidXNlclwiOiB1c2VyIHx8IG51bGwsXHJcbiAgICAgIFwicGFzc3dvcmRcIjogcGFzc3dvcmQgfHwgbnVsbFxyXG4gICAgfTtcclxuXHJcbiAgICBzZXRTdGF0ZSh0aGlzLk9QRU5FRCk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogRGlzYWJsZXMgb3IgZW5hYmxlcyBpc0FsbG93ZWRIdHRwSGVhZGVyKCkgY2hlY2sgdGhlIHJlcXVlc3QuIEVuYWJsZWQgYnkgZGVmYXVsdC5cclxuICAgKiBUaGlzIGRvZXMgbm90IGNvbmZvcm0gdG8gdGhlIFczQyBzcGVjLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGJvb2xlYW4gc3RhdGUgRW5hYmxlIG9yIGRpc2FibGUgaGVhZGVyIGNoZWNraW5nLlxyXG4gICAqL1xyXG4gIHRoaXMuc2V0RGlzYWJsZUhlYWRlckNoZWNrID0gZnVuY3Rpb24oc3RhdGUpIHtcclxuICAgIGRpc2FibGVIZWFkZXJDaGVjayA9IHN0YXRlO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgYSBoZWFkZXIgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHN0cmluZyBoZWFkZXIgSGVhZGVyIG5hbWVcclxuICAgKiBAcGFyYW0gc3RyaW5nIHZhbHVlIEhlYWRlciB2YWx1ZVxyXG4gICAqIEByZXR1cm4gYm9vbGVhbiBIZWFkZXIgYWRkZWRcclxuICAgKi9cclxuICB0aGlzLnNldFJlcXVlc3RIZWFkZXIgPSBmdW5jdGlvbihoZWFkZXIsIHZhbHVlKSB7XHJcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9IHRoaXMuT1BFTkVEKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIklOVkFMSURfU1RBVEVfRVJSOiBzZXRSZXF1ZXN0SGVhZGVyIGNhbiBvbmx5IGJlIGNhbGxlZCB3aGVuIHN0YXRlIGlzIE9QRU5cIik7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzQWxsb3dlZEh0dHBIZWFkZXIoaGVhZGVyKSkge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ1JlZnVzZWQgdG8gc2V0IHVuc2FmZSBoZWFkZXIgXCInICsgaGVhZGVyICsgJ1wiJyk7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChzZW5kRmxhZykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJTlZBTElEX1NUQVRFX0VSUjogc2VuZCBmbGFnIGlzIHRydWVcIik7XHJcbiAgICB9XHJcbiAgICBoZWFkZXJzW2hlYWRlcl0gPSB2YWx1ZTtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgYSBoZWFkZXIgZnJvbSB0aGUgc2VydmVyIHJlc3BvbnNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHN0cmluZyBoZWFkZXIgTmFtZSBvZiBoZWFkZXIgdG8gZ2V0LlxyXG4gICAqIEByZXR1cm4gc3RyaW5nIFRleHQgb2YgdGhlIGhlYWRlciBvciBudWxsIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXHJcbiAgICovXHJcbiAgdGhpcy5nZXRSZXNwb25zZUhlYWRlciA9IGZ1bmN0aW9uKGhlYWRlcikge1xyXG4gICAgaWYgKHR5cGVvZiBoZWFkZXIgPT09IFwic3RyaW5nXCJcclxuICAgICAgJiYgdGhpcy5yZWFkeVN0YXRlID4gdGhpcy5PUEVORURcclxuICAgICAgJiYgcmVzcG9uc2UuaGVhZGVyc1toZWFkZXIudG9Mb3dlckNhc2UoKV1cclxuICAgICAgJiYgIWVycm9yRmxhZ1xyXG4gICAgKSB7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5oZWFkZXJzW2hlYWRlci50b0xvd2VyQ2FzZSgpXTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBHZXRzIGFsbCB0aGUgcmVzcG9uc2UgaGVhZGVycy5cclxuICAgKlxyXG4gICAqIEByZXR1cm4gc3RyaW5nIEEgc3RyaW5nIHdpdGggYWxsIHJlc3BvbnNlIGhlYWRlcnMgc2VwYXJhdGVkIGJ5IENSK0xGXHJcbiAgICovXHJcbiAgdGhpcy5nZXRBbGxSZXNwb25zZUhlYWRlcnMgPSBmdW5jdGlvbigpIHtcclxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPCB0aGlzLkhFQURFUlNfUkVDRUlWRUQgfHwgZXJyb3JGbGFnKSB7XHJcbiAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgfVxyXG4gICAgdmFyIHJlc3VsdCA9IFwiXCI7XHJcblxyXG4gICAgZm9yICh2YXIgaSBpbiByZXNwb25zZS5oZWFkZXJzKSB7XHJcbiAgICAgIC8vIENvb2tpZSBoZWFkZXJzIGFyZSBleGNsdWRlZFxyXG4gICAgICBpZiAoaSAhPT0gXCJzZXQtY29va2llXCIgJiYgaSAhPT0gXCJzZXQtY29va2llMlwiKSB7XHJcbiAgICAgICAgcmVzdWx0ICs9IGkgKyBcIjogXCIgKyByZXNwb25zZS5oZWFkZXJzW2ldICsgXCJcXHJcXG5cIjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdC5zdWJzdHIoMCwgcmVzdWx0Lmxlbmd0aCAtIDIpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgYSByZXF1ZXN0IGhlYWRlclxyXG4gICAqXHJcbiAgICogQHBhcmFtIHN0cmluZyBuYW1lIE5hbWUgb2YgaGVhZGVyIHRvIGdldFxyXG4gICAqIEByZXR1cm4gc3RyaW5nIFJldHVybnMgdGhlIHJlcXVlc3QgaGVhZGVyIG9yIGVtcHR5IHN0cmluZyBpZiBub3Qgc2V0XHJcbiAgICovXHJcbiAgdGhpcy5nZXRSZXF1ZXN0SGVhZGVyID0gZnVuY3Rpb24obmFtZSkge1xyXG4gICAgLy8gQFRPRE8gTWFrZSB0aGlzIGNhc2UgaW5zZW5zaXRpdmVcclxuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBoZWFkZXJzW25hbWVdKSB7XHJcbiAgICAgIHJldHVybiBoZWFkZXJzW25hbWVdO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBcIlwiO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbmRzIHRoZSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gc3RyaW5nIGRhdGEgT3B0aW9uYWwgZGF0YSB0byBzZW5kIGFzIHJlcXVlc3QgYm9keS5cclxuICAgKi9cclxuICB0aGlzLnNlbmQgPSBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9IHRoaXMuT1BFTkVEKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIklOVkFMSURfU1RBVEVfRVJSOiBjb25uZWN0aW9uIG11c3QgYmUgb3BlbmVkIGJlZm9yZSBzZW5kKCkgaXMgY2FsbGVkXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzZW5kRmxhZykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJTlZBTElEX1NUQVRFX0VSUjogc2VuZCBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZFwiKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgc3NsID0gZmFsc2UsIGxvY2FsID0gZmFsc2U7XHJcbiAgICB2YXIgdXJsID0gVXJsLnBhcnNlKHNldHRpbmdzLnVybCk7XHJcbiAgICB2YXIgaG9zdDtcclxuICAgIC8vIERldGVybWluZSB0aGUgc2VydmVyXHJcbiAgICBzd2l0Y2ggKHVybC5wcm90b2NvbCkge1xyXG4gICAgICBjYXNlICdodHRwczonOlxyXG4gICAgICAgIHNzbCA9IHRydWU7XHJcbiAgICAgICAgLy8gU1NMICYgbm9uLVNTTCBib3RoIG5lZWQgaG9zdCwgbm8gYnJlYWsgaGVyZS5cclxuICAgICAgY2FzZSAnaHR0cDonOlxyXG4gICAgICAgIGhvc3QgPSB1cmwuaG9zdG5hbWU7XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlICdmaWxlOic6XHJcbiAgICAgICAgbG9jYWwgPSB0cnVlO1xyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSB1bmRlZmluZWQ6XHJcbiAgICAgIGNhc2UgJyc6XHJcbiAgICAgICAgaG9zdCA9IFwibG9jYWxob3N0XCI7XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3RvY29sIG5vdCBzdXBwb3J0ZWQuXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIExvYWQgZmlsZXMgb2ZmIHRoZSBsb2NhbCBmaWxlc3lzdGVtIChmaWxlOi8vKVxyXG4gICAgaWYgKGxvY2FsKSB7XHJcbiAgICAgIGlmIChzZXR0aW5ncy5tZXRob2QgIT09IFwiR0VUXCIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJYTUxIdHRwUmVxdWVzdDogT25seSBHRVQgbWV0aG9kIGlzIHN1cHBvcnRlZFwiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHNldHRpbmdzLmFzeW5jKSB7XHJcbiAgICAgICAgZnMucmVhZEZpbGUodW5lc2NhcGUodXJsLnBhdGhuYW1lKSwgZnVuY3Rpb24oZXJyb3IsIGRhdGEpIHtcclxuICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICBzZWxmLmhhbmRsZUVycm9yKGVycm9yLCBlcnJvci5lcnJubyB8fCAtMSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzZWxmLnN0YXR1cyA9IDIwMDtcclxuICAgICAgICAgICAgc2VsZi5yZXNwb25zZVRleHQgPSBkYXRhLnRvU3RyaW5nKCd1dGY4Jyk7XHJcbiAgICAgICAgICAgIHNlbGYucmVzcG9uc2UgPSBkYXRhO1xyXG4gICAgICAgICAgICBzZXRTdGF0ZShzZWxmLkRPTkUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICB0aGlzLnJlc3BvbnNlID0gZnMucmVhZEZpbGVTeW5jKHVuZXNjYXBlKHVybC5wYXRobmFtZSkpO1xyXG4gICAgICAgICAgdGhpcy5yZXNwb25zZVRleHQgPSB0aGlzLnJlc3BvbnNlLnRvU3RyaW5nKCd1dGY4Jyk7XHJcbiAgICAgICAgICB0aGlzLnN0YXR1cyA9IDIwMDtcclxuICAgICAgICAgIHNldFN0YXRlKHNlbGYuRE9ORSk7XHJcbiAgICAgICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKGUsIGUuZXJybm8gfHwgLTEpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERlZmF1bHQgdG8gcG9ydCA4MC4gSWYgYWNjZXNzaW5nIGxvY2FsaG9zdCBvbiBhbm90aGVyIHBvcnQgYmUgc3VyZVxyXG4gICAgLy8gdG8gdXNlIGh0dHA6Ly9sb2NhbGhvc3Q6cG9ydC9wYXRoXHJcbiAgICB2YXIgcG9ydCA9IHVybC5wb3J0IHx8IChzc2wgPyA0NDMgOiA4MCk7XHJcbiAgICAvLyBBZGQgcXVlcnkgc3RyaW5nIGlmIG9uZSBpcyB1c2VkXHJcbiAgICB2YXIgdXJpID0gdXJsLnBhdGhuYW1lICsgKHVybC5zZWFyY2ggPyB1cmwuc2VhcmNoIDogJycpO1xyXG5cclxuICAgIC8vIFNldCB0aGUgSG9zdCBoZWFkZXIgb3IgdGhlIHNlcnZlciBtYXkgcmVqZWN0IHRoZSByZXF1ZXN0XHJcbiAgICBoZWFkZXJzW1wiSG9zdFwiXSA9IGhvc3Q7XHJcbiAgICBpZiAoISgoc3NsICYmIHBvcnQgPT09IDQ0MykgfHwgcG9ydCA9PT0gODApKSB7XHJcbiAgICAgIGhlYWRlcnNbXCJIb3N0XCJdICs9ICc6JyArIHVybC5wb3J0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNldCBCYXNpYyBBdXRoIGlmIG5lY2Vzc2FyeVxyXG4gICAgaWYgKHNldHRpbmdzLnVzZXIpIHtcclxuICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5wYXNzd29yZCA9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgc2V0dGluZ3MucGFzc3dvcmQgPSBcIlwiO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBhdXRoQnVmID0gbmV3IEJ1ZmZlcihzZXR0aW5ncy51c2VyICsgXCI6XCIgKyBzZXR0aW5ncy5wYXNzd29yZCk7XHJcbiAgICAgIGhlYWRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gXCJCYXNpYyBcIiArIGF1dGhCdWYudG9TdHJpbmcoXCJiYXNlNjRcIik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2V0IGNvbnRlbnQgbGVuZ3RoIGhlYWRlclxyXG4gICAgaWYgKHNldHRpbmdzLm1ldGhvZCA9PT0gXCJHRVRcIiB8fCBzZXR0aW5ncy5tZXRob2QgPT09IFwiSEVBRFwiKSB7XHJcbiAgICAgIGRhdGEgPSBudWxsO1xyXG4gICAgfSBlbHNlIGlmIChkYXRhKSB7XHJcbiAgICAgIGhlYWRlcnNbXCJDb250ZW50LUxlbmd0aFwiXSA9IEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSA/IGRhdGEubGVuZ3RoIDogQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSk7XHJcblxyXG4gICAgICB2YXIgaGVhZGVyc0tleXMgPSBPYmplY3Qua2V5cyhoZWFkZXJzKTtcclxuICAgICAgaWYgKCFoZWFkZXJzS2V5cy5zb21lKGZ1bmN0aW9uIChoKSB7IHJldHVybiBoLnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LXR5cGUnIH0pKSB7XHJcbiAgICAgICAgaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9IFwidGV4dC9wbGFpbjtjaGFyc2V0PVVURi04XCI7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MubWV0aG9kID09PSBcIlBPU1RcIikge1xyXG4gICAgICAvLyBGb3IgYSBwb3N0IHdpdGggbm8gZGF0YSBzZXQgQ29udGVudC1MZW5ndGg6IDAuXHJcbiAgICAgIC8vIFRoaXMgaXMgcmVxdWlyZWQgYnkgYnVnZ3kgc2VydmVycyB0aGF0IGRvbid0IG1lZXQgdGhlIHNwZWNzLlxyXG4gICAgICBoZWFkZXJzW1wiQ29udGVudC1MZW5ndGhcIl0gPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBhZ2VudCA9IG9wdHMuYWdlbnQgfHwgZmFsc2U7XHJcbiAgICB2YXIgb3B0aW9ucyA9IHtcclxuICAgICAgaG9zdDogaG9zdCxcclxuICAgICAgcG9ydDogcG9ydCxcclxuICAgICAgcGF0aDogdXJpLFxyXG4gICAgICBtZXRob2Q6IHNldHRpbmdzLm1ldGhvZCxcclxuICAgICAgaGVhZGVyczogaGVhZGVycyxcclxuICAgICAgYWdlbnQ6IGFnZW50XHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChzc2wpIHtcclxuICAgICAgb3B0aW9ucy5wZnggPSBvcHRzLnBmeDtcclxuICAgICAgb3B0aW9ucy5rZXkgPSBvcHRzLmtleTtcclxuICAgICAgb3B0aW9ucy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlO1xyXG4gICAgICBvcHRpb25zLmNlcnQgPSBvcHRzLmNlcnQ7XHJcbiAgICAgIG9wdGlvbnMuY2EgPSBvcHRzLmNhO1xyXG4gICAgICBvcHRpb25zLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnM7XHJcbiAgICAgIG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlc2V0IGVycm9yIGZsYWdcclxuICAgIGVycm9yRmxhZyA9IGZhbHNlO1xyXG4gICAgLy8gSGFuZGxlIGFzeW5jIHJlcXVlc3RzXHJcbiAgICBpZiAoc2V0dGluZ3MuYXN5bmMpIHtcclxuICAgICAgLy8gVXNlIHRoZSBwcm9wZXIgcHJvdG9jb2xcclxuICAgICAgdmFyIGRvUmVxdWVzdCA9IHNzbCA/IGh0dHBzLnJlcXVlc3QgOiBodHRwLnJlcXVlc3Q7XHJcblxyXG4gICAgICAvLyBSZXF1ZXN0IGlzIGJlaW5nIHNlbnQsIHNldCBzZW5kIGZsYWdcclxuICAgICAgc2VuZEZsYWcgPSB0cnVlO1xyXG5cclxuICAgICAgLy8gQXMgcGVyIHNwZWMsIHRoaXMgaXMgY2FsbGVkIGhlcmUgZm9yIGhpc3RvcmljYWwgcmVhc29ucy5cclxuICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KFwicmVhZHlzdGF0ZWNoYW5nZVwiKTtcclxuXHJcbiAgICAgIC8vIEhhbmRsZXIgZm9yIHRoZSByZXNwb25zZVxyXG4gICAgICB2YXIgcmVzcG9uc2VIYW5kbGVyID0gZnVuY3Rpb24ocmVzcCkge1xyXG4gICAgICAgIC8vIFNldCByZXNwb25zZSB2YXIgdG8gdGhlIHJlc3BvbnNlIHdlIGdvdCBiYWNrXHJcbiAgICAgICAgLy8gVGhpcyBpcyBzbyBpdCByZW1haW5zIGFjY2Vzc2FibGUgb3V0c2lkZSB0aGlzIHNjb3BlXHJcbiAgICAgICAgcmVzcG9uc2UgPSByZXNwO1xyXG4gICAgICAgIC8vIENoZWNrIGZvciByZWRpcmVjdFxyXG4gICAgICAgIC8vIEBUT0RPIFByZXZlbnQgbG9vcGVkIHJlZGlyZWN0c1xyXG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDIgfHwgcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzAzIHx8IHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwNykge1xyXG4gICAgICAgICAgLy8gQ2hhbmdlIFVSTCB0byB0aGUgcmVkaXJlY3QgbG9jYXRpb25cclxuICAgICAgICAgIHNldHRpbmdzLnVybCA9IHJlc3BvbnNlLmhlYWRlcnMubG9jYXRpb247XHJcbiAgICAgICAgICB2YXIgdXJsID0gVXJsLnBhcnNlKHNldHRpbmdzLnVybCk7XHJcbiAgICAgICAgICAvLyBTZXQgaG9zdCB2YXIgaW4gY2FzZSBpdCdzIHVzZWQgbGF0ZXJcclxuICAgICAgICAgIGhvc3QgPSB1cmwuaG9zdG5hbWU7XHJcbiAgICAgICAgICAvLyBPcHRpb25zIGZvciB0aGUgbmV3IHJlcXVlc3RcclxuICAgICAgICAgIHZhciBuZXdPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBob3N0bmFtZTogdXJsLmhvc3RuYW1lLFxyXG4gICAgICAgICAgICBwb3J0OiB1cmwucG9ydCxcclxuICAgICAgICAgICAgcGF0aDogdXJsLnBhdGgsXHJcbiAgICAgICAgICAgIG1ldGhvZDogcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzAzID8gJ0dFVCcgOiBzZXR0aW5ncy5tZXRob2QsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnNcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgaWYgKHNzbCkge1xyXG4gICAgICAgICAgICBuZXdPcHRpb25zLnBmeCA9IG9wdHMucGZ4O1xyXG4gICAgICAgICAgICBuZXdPcHRpb25zLmtleSA9IG9wdHMua2V5O1xyXG4gICAgICAgICAgICBuZXdPcHRpb25zLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XHJcbiAgICAgICAgICAgIG5ld09wdGlvbnMuY2VydCA9IG9wdHMuY2VydDtcclxuICAgICAgICAgICAgbmV3T3B0aW9ucy5jYSA9IG9wdHMuY2E7XHJcbiAgICAgICAgICAgIG5ld09wdGlvbnMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcclxuICAgICAgICAgICAgbmV3T3B0aW9ucy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gSXNzdWUgdGhlIG5ldyByZXF1ZXN0XHJcbiAgICAgICAgICByZXF1ZXN0ID0gZG9SZXF1ZXN0KG5ld09wdGlvbnMsIHJlc3BvbnNlSGFuZGxlcikub24oJ2Vycm9yJywgZXJyb3JIYW5kbGVyKTtcclxuICAgICAgICAgIHJlcXVlc3QuZW5kKCk7XHJcbiAgICAgICAgICAvLyBAVE9ETyBDaGVjayBpZiBhbiBYSFIgZXZlbnQgbmVlZHMgdG8gYmUgZmlyZWQgaGVyZVxyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2V0U3RhdGUoc2VsZi5IRUFERVJTX1JFQ0VJVkVEKTtcclxuICAgICAgICBzZWxmLnN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1c0NvZGU7XHJcblxyXG4gICAgICAgIHJlc3BvbnNlLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHtcclxuICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGVyZSdzIHNvbWUgZGF0YVxyXG4gICAgICAgICAgaWYgKGNodW5rKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gQnVmZmVyLmZyb20oY2h1bmspO1xyXG4gICAgICAgICAgICBzZWxmLnJlc3BvbnNlID0gQnVmZmVyLmNvbmNhdChbc2VsZi5yZXNwb25zZSwgZGF0YV0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gRG9uJ3QgZW1pdCBzdGF0ZSBjaGFuZ2VzIGlmIHRoZSBjb25uZWN0aW9uIGhhcyBiZWVuIGFib3J0ZWQuXHJcbiAgICAgICAgICBpZiAoc2VuZEZsYWcpIHtcclxuICAgICAgICAgICAgc2V0U3RhdGUoc2VsZi5MT0FESU5HKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmVzcG9uc2Uub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgaWYgKHNlbmRGbGFnKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBzZW5kRmxhZyBuZWVkcyB0byBiZSBzZXQgYmVmb3JlIHNldFN0YXRlIGlzIGNhbGxlZC4gIE90aGVyd2lzZSBpZiB3ZSBhcmUgY2hhaW5pbmcgY2FsbGJhY2tzXHJcbiAgICAgICAgICAgIC8vIHRoZXJlIGNhbiBiZSBhIHRpbWluZyBpc3N1ZSAodGhlIGNhbGxiYWNrIGlzIGNhbGxlZCBhbmQgYSBuZXcgY2FsbCBpcyBtYWRlIGJlZm9yZSB0aGUgZmxhZyBpcyByZXNldCkuXHJcbiAgICAgICAgICAgIHNlbmRGbGFnID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vIERpc2NhcmQgdGhlICdlbmQnIGV2ZW50IGlmIHRoZSBjb25uZWN0aW9uIGhhcyBiZWVuIGFib3J0ZWRcclxuICAgICAgICAgICAgc2V0U3RhdGUoc2VsZi5ET05FKTtcclxuICAgICAgICAgICAgLy8gQ29uc3RydWN0IHJlc3BvbnNlVGV4dCBmcm9tIHJlc3BvbnNlXHJcbiAgICAgICAgICAgIHNlbGYucmVzcG9uc2VUZXh0ID0gc2VsZi5yZXNwb25zZS50b1N0cmluZygndXRmOCcpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXNwb25zZS5vbignZXJyb3InLCBmdW5jdGlvbihlcnJvcikge1xyXG4gICAgICAgICAgc2VsZi5oYW5kbGVFcnJvcihlcnJvcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEVycm9yIGhhbmRsZXIgZm9yIHRoZSByZXF1ZXN0XHJcbiAgICAgIHZhciBlcnJvckhhbmRsZXIgPSBmdW5jdGlvbihlcnJvcikge1xyXG4gICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI3JlcXVlc3RyZXVzZWRzb2NrZXQgdHJpZ2dlcmluZyBhbiBFQ09OTlJFU0VULFxyXG4gICAgICAgIC8vIGRvbid0IGZhaWwgdGhlIHhociByZXF1ZXN0LCBhdHRlbXB0IGFnYWluLlxyXG4gICAgICAgIGlmIChyZXF1ZXN0LnJldXNlZFNvY2tldCAmJiBlcnJvci5jb2RlID09PSAnRUNPTk5SRVNFVCcpXHJcbiAgICAgICAgICByZXR1cm4gZG9SZXF1ZXN0KG9wdGlvbnMsIHJlc3BvbnNlSGFuZGxlcikub24oJ2Vycm9yJywgZXJyb3JIYW5kbGVyKTtcclxuICAgICAgICBzZWxmLmhhbmRsZUVycm9yKGVycm9yKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ3JlYXRlIHRoZSByZXF1ZXN0XHJcbiAgICAgIHJlcXVlc3QgPSBkb1JlcXVlc3Qob3B0aW9ucywgcmVzcG9uc2VIYW5kbGVyKS5vbignZXJyb3InLCBlcnJvckhhbmRsZXIpO1xyXG5cclxuICAgICAgaWYgKG9wdHMuYXV0b1VucmVmKSB7XHJcbiAgICAgICAgcmVxdWVzdC5vbignc29ja2V0JywgKHNvY2tldCkgPT4ge1xyXG4gICAgICAgICAgc29ja2V0LnVucmVmKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE5vZGUgMC40IGFuZCBsYXRlciB3b24ndCBhY2NlcHQgZW1wdHkgZGF0YS4gTWFrZSBzdXJlIGl0J3MgbmVlZGVkLlxyXG4gICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgIHJlcXVlc3Qud3JpdGUoZGF0YSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlcXVlc3QuZW5kKCk7XHJcblxyXG4gICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoXCJsb2Fkc3RhcnRcIik7XHJcbiAgICB9IGVsc2UgeyAvLyBTeW5jaHJvbm91c1xyXG4gICAgICAvLyBDcmVhdGUgYSB0ZW1wb3JhcnkgZmlsZSBmb3IgY29tbXVuaWNhdGlvbiB3aXRoIHRoZSBvdGhlciBOb2RlIHByb2Nlc3NcclxuICAgICAgdmFyIGNvbnRlbnRGaWxlID0gXCIubm9kZS14bWxodHRwcmVxdWVzdC1jb250ZW50LVwiICsgcHJvY2Vzcy5waWQ7XHJcbiAgICAgIHZhciBzeW5jRmlsZSA9IFwiLm5vZGUteG1saHR0cHJlcXVlc3Qtc3luYy1cIiArIHByb2Nlc3MucGlkO1xyXG4gICAgICBmcy53cml0ZUZpbGVTeW5jKHN5bmNGaWxlLCBcIlwiLCBcInV0ZjhcIik7XHJcbiAgICAgIC8vIFRoZSBhc3luYyByZXF1ZXN0IHRoZSBvdGhlciBOb2RlIHByb2Nlc3MgZXhlY3V0ZXNcclxuICAgICAgdmFyIGV4ZWNTdHJpbmcgPSBcInZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpLCBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyksIGZzID0gcmVxdWlyZSgnZnMnKTtcIlxyXG4gICAgICAgICsgXCJ2YXIgZG9SZXF1ZXN0ID0gaHR0cFwiICsgKHNzbCA/IFwic1wiIDogXCJcIikgKyBcIi5yZXF1ZXN0O1wiXHJcbiAgICAgICAgKyBcInZhciBvcHRpb25zID0gXCIgKyBKU09OLnN0cmluZ2lmeShvcHRpb25zKSArIFwiO1wiXHJcbiAgICAgICAgKyBcInZhciByZXNwb25zZVRleHQgPSAnJztcIlxyXG4gICAgICAgICsgXCJ2YXIgcmVzcG9uc2VEYXRhID0gQnVmZmVyLmFsbG9jKDApO1wiXHJcbiAgICAgICAgKyBcInZhciByZXEgPSBkb1JlcXVlc3Qob3B0aW9ucywgZnVuY3Rpb24ocmVzcG9uc2UpIHtcIlxyXG4gICAgICAgICsgXCJyZXNwb25zZS5vbignZGF0YScsIGZ1bmN0aW9uKGNodW5rKSB7XCJcclxuICAgICAgICArIFwiICB2YXIgZGF0YSA9IEJ1ZmZlci5mcm9tKGNodW5rKTtcIlxyXG4gICAgICAgICsgXCIgIHJlc3BvbnNlVGV4dCArPSBkYXRhLnRvU3RyaW5nKCd1dGY4Jyk7XCJcclxuICAgICAgICArIFwiICByZXNwb25zZURhdGEgPSBCdWZmZXIuY29uY2F0KFtyZXNwb25zZURhdGEsIGRhdGFdKTtcIlxyXG4gICAgICAgICsgXCJ9KTtcIlxyXG4gICAgICAgICsgXCJyZXNwb25zZS5vbignZW5kJywgZnVuY3Rpb24oKSB7XCJcclxuICAgICAgICArIFwiZnMud3JpdGVGaWxlU3luYygnXCIgKyBjb250ZW50RmlsZSArIFwiJywgSlNPTi5zdHJpbmdpZnkoe2VycjogbnVsbCwgZGF0YToge3N0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1c0NvZGUsIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMsIHRleHQ6IHJlc3BvbnNlVGV4dCwgZGF0YTogcmVzcG9uc2VEYXRhLnRvU3RyaW5nKCdiYXNlNjQnKX19KSwgJ3V0ZjgnKTtcIlxyXG4gICAgICAgICsgXCJmcy51bmxpbmtTeW5jKCdcIiArIHN5bmNGaWxlICsgXCInKTtcIlxyXG4gICAgICAgICsgXCJ9KTtcIlxyXG4gICAgICAgICsgXCJyZXNwb25zZS5vbignZXJyb3InLCBmdW5jdGlvbihlcnJvcikge1wiXHJcbiAgICAgICAgKyBcImZzLndyaXRlRmlsZVN5bmMoJ1wiICsgY29udGVudEZpbGUgKyBcIicsICdOT0RFLVhNTEhUVFBSRVFVRVNULUVSUk9SOicgKyBKU09OLnN0cmluZ2lmeShlcnJvciksICd1dGY4Jyk7XCJcclxuICAgICAgICArIFwiZnMudW5saW5rU3luYygnXCIgKyBzeW5jRmlsZSArIFwiJyk7XCJcclxuICAgICAgICArIFwifSk7XCJcclxuICAgICAgICArIFwifSkub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcIlxyXG4gICAgICAgICsgXCJmcy53cml0ZUZpbGVTeW5jKCdcIiArIGNvbnRlbnRGaWxlICsgXCInLCAnTk9ERS1YTUxIVFRQUkVRVUVTVC1FUlJPUjonICsgSlNPTi5zdHJpbmdpZnkoZXJyb3IpLCAndXRmOCcpO1wiXHJcbiAgICAgICAgKyBcImZzLnVubGlua1N5bmMoJ1wiICsgc3luY0ZpbGUgKyBcIicpO1wiXHJcbiAgICAgICAgKyBcIn0pO1wiXHJcbiAgICAgICAgKyAoZGF0YSA/IFwicmVxLndyaXRlKCdcIiArIEpTT04uc3RyaW5naWZ5KGRhdGEpLnNsaWNlKDEsLTEpLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKSArIFwiJyk7XCI6XCJcIilcclxuICAgICAgICArIFwicmVxLmVuZCgpO1wiO1xyXG4gICAgICAvLyBTdGFydCB0aGUgb3RoZXIgTm9kZSBQcm9jZXNzLCBleGVjdXRpbmcgdGhpcyBzdHJpbmdcclxuICAgICAgdmFyIHN5bmNQcm9jID0gc3Bhd24ocHJvY2Vzcy5hcmd2WzBdLCBbXCItZVwiLCBleGVjU3RyaW5nXSk7XHJcbiAgICAgIHZhciBzdGF0dXNUZXh0O1xyXG4gICAgICB3aGlsZShmcy5leGlzdHNTeW5jKHN5bmNGaWxlKSkge1xyXG4gICAgICAgIC8vIFdhaXQgd2hpbGUgdGhlIHN5bmMgZmlsZSBpcyBlbXB0eVxyXG4gICAgICB9XHJcbiAgICAgIHNlbGYucmVzcG9uc2VUZXh0ID0gZnMucmVhZEZpbGVTeW5jKGNvbnRlbnRGaWxlLCAndXRmOCcpO1xyXG4gICAgICAvLyBLaWxsIHRoZSBjaGlsZCBwcm9jZXNzIG9uY2UgdGhlIGZpbGUgaGFzIGRhdGFcclxuICAgICAgc3luY1Byb2Muc3RkaW4uZW5kKCk7XHJcbiAgICAgIC8vIFJlbW92ZSB0aGUgdGVtcG9yYXJ5IGZpbGVcclxuICAgICAgZnMudW5saW5rU3luYyhjb250ZW50RmlsZSk7XHJcbiAgICAgIGlmIChzZWxmLnJlc3BvbnNlVGV4dC5tYXRjaCgvXk5PREUtWE1MSFRUUFJFUVVFU1QtRVJST1I6LykpIHtcclxuICAgICAgICAvLyBJZiB0aGUgZmlsZSByZXR1cm5lZCBhbiBlcnJvciwgaGFuZGxlIGl0XHJcbiAgICAgICAgdmFyIGVycm9yT2JqID0gSlNPTi5wYXJzZShzZWxmLnJlc3BvbnNlVGV4dC5yZXBsYWNlKC9eTk9ERS1YTUxIVFRQUkVRVUVTVC1FUlJPUjovLCBcIlwiKSk7XHJcbiAgICAgICAgc2VsZi5oYW5kbGVFcnJvcihlcnJvck9iaiwgNTAzKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBJZiB0aGUgZmlsZSByZXR1cm5lZCBva2F5LCBwYXJzZSBpdHMgZGF0YSBhbmQgbW92ZSB0byB0aGUgRE9ORSBzdGF0ZVxyXG4gICAgICAgIHNlbGYuc3RhdHVzID0gc2VsZi5yZXNwb25zZVRleHQucmVwbGFjZSgvXk5PREUtWE1MSFRUUFJFUVVFU1QtU1RBVFVTOihbMC05XSopLC4qLywgXCIkMVwiKTtcclxuICAgICAgICB2YXIgcmVzcCA9IEpTT04ucGFyc2Uoc2VsZi5yZXNwb25zZVRleHQucmVwbGFjZSgvXk5PREUtWE1MSFRUUFJFUVVFU1QtU1RBVFVTOlswLTldKiwoLiopLywgXCIkMVwiKSk7XHJcbiAgICAgICAgcmVzcG9uc2UgPSB7XHJcbiAgICAgICAgICBzdGF0dXNDb2RlOiBzZWxmLnN0YXR1cyxcclxuICAgICAgICAgIGhlYWRlcnM6IHJlc3AuZGF0YS5oZWFkZXJzXHJcbiAgICAgICAgfTtcclxuICAgICAgICBzZWxmLnJlc3BvbnNlVGV4dCA9IHJlc3AuZGF0YS50ZXh0O1xyXG4gICAgICAgIHNlbGYucmVzcG9uc2UgPSBCdWZmZXIuZnJvbShyZXNwLmRhdGEuZGF0YSwgJ2Jhc2U2NCcpO1xyXG4gICAgICAgIHNldFN0YXRlKHNlbGYuRE9ORSwgdHJ1ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDYWxsZWQgd2hlbiBhbiBlcnJvciBpcyBlbmNvdW50ZXJlZCB0byBkZWFsIHdpdGggaXQuXHJcbiAgICogQHBhcmFtICBzdGF0dXMgIHtudW1iZXJ9ICAgIEhUVFAgc3RhdHVzIGNvZGUgdG8gdXNlIHJhdGhlciB0aGFuIHRoZSBkZWZhdWx0ICgwKSBmb3IgWEhSIGVycm9ycy5cclxuICAgKi9cclxuICB0aGlzLmhhbmRsZUVycm9yID0gZnVuY3Rpb24oZXJyb3IsIHN0YXR1cykge1xyXG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXMgfHwgMDtcclxuICAgIHRoaXMuc3RhdHVzVGV4dCA9IGVycm9yO1xyXG4gICAgdGhpcy5yZXNwb25zZVRleHQgPSBlcnJvci5zdGFjaztcclxuICAgIGVycm9yRmxhZyA9IHRydWU7XHJcbiAgICBzZXRTdGF0ZSh0aGlzLkRPTkUpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEFib3J0cyBhIHJlcXVlc3QuXHJcbiAgICovXHJcbiAgdGhpcy5hYm9ydCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKHJlcXVlc3QpIHtcclxuICAgICAgcmVxdWVzdC5hYm9ydCgpO1xyXG4gICAgICByZXF1ZXN0ID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdEhlYWRlcnMpO1xyXG4gICAgdGhpcy5yZXNwb25zZVRleHQgPSBcIlwiO1xyXG4gICAgdGhpcy5yZXNwb25zZVhNTCA9IFwiXCI7XHJcbiAgICB0aGlzLnJlc3BvbnNlID0gQnVmZmVyLmFsbG9jKDApO1xyXG5cclxuICAgIGVycm9yRmxhZyA9IGFib3J0ZWRGbGFnID0gdHJ1ZVxyXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gdGhpcy5VTlNFTlRcclxuICAgICAgICAmJiAodGhpcy5yZWFkeVN0YXRlICE9PSB0aGlzLk9QRU5FRCB8fCBzZW5kRmxhZylcclxuICAgICAgICAmJiB0aGlzLnJlYWR5U3RhdGUgIT09IHRoaXMuRE9ORSkge1xyXG4gICAgICBzZW5kRmxhZyA9IGZhbHNlO1xyXG4gICAgICBzZXRTdGF0ZSh0aGlzLkRPTkUpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gdGhpcy5VTlNFTlQ7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lci4gUHJlZmVycmVkIG1ldGhvZCBvZiBiaW5kaW5nIHRvIGV2ZW50cy5cclxuICAgKi9cclxuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgY2FsbGJhY2spIHtcclxuICAgIGlmICghKGV2ZW50IGluIGxpc3RlbmVycykpIHtcclxuICAgICAgbGlzdGVuZXJzW2V2ZW50XSA9IFtdO1xyXG4gICAgfVxyXG4gICAgLy8gQ3VycmVudGx5IGFsbG93cyBkdXBsaWNhdGUgY2FsbGJhY2tzLiBTaG91bGQgaXQ/XHJcbiAgICBsaXN0ZW5lcnNbZXZlbnRdLnB1c2goY2FsbGJhY2spO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSBhbiBldmVudCBjYWxsYmFjayB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gYm91bmQuXHJcbiAgICogT25seSB3b3JrcyBvbiB0aGUgbWF0Y2hpbmcgZnVuY2l0b24sIGNhbm5vdCBiZSBhIGNvcHkuXHJcbiAgICovXHJcbiAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGNhbGxiYWNrKSB7XHJcbiAgICBpZiAoZXZlbnQgaW4gbGlzdGVuZXJzKSB7XHJcbiAgICAgIC8vIEZpbHRlciB3aWxsIHJldHVybiBhIG5ldyBhcnJheSB3aXRoIHRoZSBjYWxsYmFjayByZW1vdmVkXHJcbiAgICAgIGxpc3RlbmVyc1tldmVudF0gPSBsaXN0ZW5lcnNbZXZlbnRdLmZpbHRlcihmdW5jdGlvbihldikge1xyXG4gICAgICAgIHJldHVybiBldiAhPT0gY2FsbGJhY2s7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc3BhdGNoIGFueSBldmVudHMsIGluY2x1ZGluZyBib3RoIFwib25cIiBtZXRob2RzIGFuZCBldmVudHMgYXR0YWNoZWQgdXNpbmcgYWRkRXZlbnRMaXN0ZW5lci5cclxuICAgKi9cclxuICB0aGlzLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgIGlmICh0eXBlb2Ygc2VsZltcIm9uXCIgKyBldmVudF0gPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkRPTkUgJiYgc2V0dGluZ3MuYXN5bmMpXHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgc2VsZltcIm9uXCIgKyBldmVudF0oKSB9LCAwKVxyXG4gICAgICBlbHNlXHJcbiAgICAgICAgc2VsZltcIm9uXCIgKyBldmVudF0oKVxyXG4gICAgfVxyXG4gICAgaWYgKGV2ZW50IGluIGxpc3RlbmVycykge1xyXG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGlzdGVuZXJzW2V2ZW50XS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHRoaXMuRE9ORSlcclxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGxpc3RlbmVyc1tldmVudF1baV0uY2FsbChzZWxmKSB9LCAwKVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIGxpc3RlbmVyc1tldmVudF1baV0uY2FsbChzZWxmKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2hhbmdlcyByZWFkeVN0YXRlIGFuZCBjYWxscyBvbnJlYWR5c3RhdGVjaGFuZ2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gaW50IHN0YXRlIE5ldyBzdGF0ZVxyXG4gICAqL1xyXG4gIHZhciBzZXRTdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XHJcbiAgICBpZiAoKHNlbGYucmVhZHlTdGF0ZSA9PT0gc3RhdGUpIHx8IChzZWxmLnJlYWR5U3RhdGUgPT09IHNlbGYuVU5TRU5UICYmIGFib3J0ZWRGbGFnKSlcclxuICAgICAgcmV0dXJuXHJcblxyXG4gICAgc2VsZi5yZWFkeVN0YXRlID0gc3RhdGU7XHJcblxyXG4gICAgaWYgKHNldHRpbmdzLmFzeW5jIHx8IHNlbGYucmVhZHlTdGF0ZSA8IHNlbGYuT1BFTkVEIHx8IHNlbGYucmVhZHlTdGF0ZSA9PT0gc2VsZi5ET05FKSB7XHJcbiAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChcInJlYWR5c3RhdGVjaGFuZ2VcIik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNlbGYucmVhZHlTdGF0ZSA9PT0gc2VsZi5ET05FKSB7XHJcbiAgICAgIGxldCBmaXJlXHJcblxyXG4gICAgICBpZiAoYWJvcnRlZEZsYWcpXHJcbiAgICAgICAgZmlyZSA9IFwiYWJvcnRcIlxyXG4gICAgICBlbHNlIGlmIChlcnJvckZsYWcpXHJcbiAgICAgICAgZmlyZSA9IFwiZXJyb3JcIlxyXG4gICAgICBlbHNlXHJcbiAgICAgICAgZmlyZSA9IFwibG9hZFwiXHJcblxyXG4gICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoZmlyZSlcclxuXHJcbiAgICAgIC8vIEBUT0RPIGZpZ3VyZSBvdXQgSW5zcGVjdG9ySW5zdHJ1bWVudGF0aW9uOjpkaWRMb2FkWEhSKGNvb2tpZSlcclxuICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KFwibG9hZGVuZFwiKTtcclxuICAgIH1cclxuICB9O1xyXG59O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xmlhttprequest-ssl/lib/XMLHttpRequest.js\n");

/***/ })

};
;