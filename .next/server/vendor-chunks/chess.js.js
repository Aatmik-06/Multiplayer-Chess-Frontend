"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/chess.js";
exports.ids = ["vendor-chunks/chess.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/chess.js/dist/cjs/chess.js":
/*!*************************************************!*\
  !*** ./node_modules/chess.js/dist/cjs/chess.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/**\r\n * @license\r\n * Copyright (c) 2025, Jeff Hlywa (jhlywa@gmail.com)\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright notice,\r\n *    this list of conditions and the following disclaimer.\r\n * 2. Redistributions in binary form must reproduce the above copyright notice,\r\n *    this list of conditions and the following disclaimer in the documentation\r\n *    and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\r\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Chess = exports.validateFen = exports.SEVEN_TAG_ROSTER = exports.SQUARES = exports.Move = exports.DEFAULT_POSITION = exports.KING = exports.QUEEN = exports.ROOK = exports.BISHOP = exports.KNIGHT = exports.PAWN = exports.BLACK = exports.WHITE = exports.xoroshiro128 = void 0;\r\nconst pgn_1 = __webpack_require__(/*! ./pgn */ \"(ssr)/./node_modules/chess.js/dist/cjs/pgn.js\");\r\nconst MASK64 = 0xffffffffffffffffn;\r\nfunction rotl(x, k) {\r\n    return ((x << k) | (x >> (64n - k))) & 0xffffffffffffffffn;\r\n}\r\nfunction wrappingMul(x, y) {\r\n    return (x * y) & MASK64;\r\n}\r\n// xoroshiro128**\r\nfunction xoroshiro128(state) {\r\n    return function () {\r\n        let s0 = BigInt(state & MASK64);\r\n        let s1 = BigInt((state >> 64n) & MASK64);\r\n        const result = wrappingMul(rotl(wrappingMul(s0, 5n), 7n), 9n);\r\n        s1 ^= s0;\r\n        s0 = (rotl(s0, 24n) ^ s1 ^ (s1 << 16n)) & MASK64;\r\n        s1 = rotl(s1, 37n);\r\n        state = (s1 << 64n) | s0;\r\n        return result;\r\n    };\r\n}\r\nexports.xoroshiro128 = xoroshiro128;\r\nconst rand = xoroshiro128(0xa187eb39cdcaed8f31c4b365b102e01en);\r\nconst PIECE_KEYS = Array.from({ length: 2 }, () => Array.from({ length: 6 }, () => Array.from({ length: 128 }, () => rand())));\r\nconst EP_KEYS = Array.from({ length: 8 }, () => rand());\r\nconst CASTLING_KEYS = Array.from({ length: 16 }, () => rand());\r\nconst SIDE_KEY = rand();\r\nexports.WHITE = 'w';\r\nexports.BLACK = 'b';\r\nexports.PAWN = 'p';\r\nexports.KNIGHT = 'n';\r\nexports.BISHOP = 'b';\r\nexports.ROOK = 'r';\r\nexports.QUEEN = 'q';\r\nexports.KING = 'k';\r\nexports.DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\r\nclass Move {\r\n    color;\r\n    from;\r\n    to;\r\n    piece;\r\n    captured;\r\n    promotion;\r\n    /**\r\n     * @deprecated This field is deprecated and will be removed in version 2.0.0.\r\n     * Please use move descriptor functions instead: `isCapture`, `isPromotion`,\r\n     * `isEnPassant`, `isKingsideCastle`, `isQueensideCastle`, `isCastle`, and\r\n     * `isBigPawn`\r\n     */\r\n    flags;\r\n    san;\r\n    lan;\r\n    before;\r\n    after;\r\n    constructor(chess, internal) {\r\n        const { color, piece, from, to, flags, captured, promotion } = internal;\r\n        const fromAlgebraic = algebraic(from);\r\n        const toAlgebraic = algebraic(to);\r\n        this.color = color;\r\n        this.piece = piece;\r\n        this.from = fromAlgebraic;\r\n        this.to = toAlgebraic;\r\n        /*\r\n         * HACK: The chess['_method']() calls below invoke private methods in the\r\n         * Chess class to generate SAN and FEN. It's a bit of a hack, but makes the\r\n         * code cleaner elsewhere.\r\n         */\r\n        this.san = chess['_moveToSan'](internal, chess['_moves']({ legal: true }));\r\n        this.lan = fromAlgebraic + toAlgebraic;\r\n        this.before = chess.fen();\r\n        // Generate the FEN for the 'after' key\r\n        chess['_makeMove'](internal);\r\n        this.after = chess.fen();\r\n        chess['_undoMove']();\r\n        // Build the text representation of the move flags\r\n        this.flags = '';\r\n        for (const flag in BITS) {\r\n            if (BITS[flag] & flags) {\r\n                this.flags += FLAGS[flag];\r\n            }\r\n        }\r\n        if (captured) {\r\n            this.captured = captured;\r\n        }\r\n        if (promotion) {\r\n            this.promotion = promotion;\r\n            this.lan += promotion;\r\n        }\r\n    }\r\n    isCapture() {\r\n        return this.flags.indexOf(FLAGS['CAPTURE']) > -1;\r\n    }\r\n    isPromotion() {\r\n        return this.flags.indexOf(FLAGS['PROMOTION']) > -1;\r\n    }\r\n    isEnPassant() {\r\n        return this.flags.indexOf(FLAGS['EP_CAPTURE']) > -1;\r\n    }\r\n    isKingsideCastle() {\r\n        return this.flags.indexOf(FLAGS['KSIDE_CASTLE']) > -1;\r\n    }\r\n    isQueensideCastle() {\r\n        return this.flags.indexOf(FLAGS['QSIDE_CASTLE']) > -1;\r\n    }\r\n    isBigPawn() {\r\n        return this.flags.indexOf(FLAGS['BIG_PAWN']) > -1;\r\n    }\r\n}\r\nexports.Move = Move;\r\nconst EMPTY = -1;\r\nconst FLAGS = {\r\n    NORMAL: 'n',\r\n    CAPTURE: 'c',\r\n    BIG_PAWN: 'b',\r\n    EP_CAPTURE: 'e',\r\n    PROMOTION: 'p',\r\n    KSIDE_CASTLE: 'k',\r\n    QSIDE_CASTLE: 'q',\r\n};\r\n// prettier-ignore\r\nexports.SQUARES = [\r\n    'a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8',\r\n    'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7',\r\n    'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6',\r\n    'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5',\r\n    'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4',\r\n    'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3',\r\n    'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2',\r\n    'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'\r\n];\r\nconst BITS = {\r\n    NORMAL: 1,\r\n    CAPTURE: 2,\r\n    BIG_PAWN: 4,\r\n    EP_CAPTURE: 8,\r\n    PROMOTION: 16,\r\n    KSIDE_CASTLE: 32,\r\n    QSIDE_CASTLE: 64,\r\n};\r\n/* eslint-disable @typescript-eslint/naming-convention */\r\n// these are required, according to spec\r\nexports.SEVEN_TAG_ROSTER = {\r\n    Event: '?',\r\n    Site: '?',\r\n    Date: '????.??.??',\r\n    Round: '?',\r\n    White: '?',\r\n    Black: '?',\r\n    Result: '*',\r\n};\r\n/**\r\n * These nulls are placeholders to fix the order of tags (as they appear in PGN spec); null values will be\r\n * eliminated in getHeaders()\r\n */\r\nconst SUPLEMENTAL_TAGS = {\r\n    WhiteTitle: null,\r\n    BlackTitle: null,\r\n    WhiteElo: null,\r\n    BlackElo: null,\r\n    WhiteUSCF: null,\r\n    BlackUSCF: null,\r\n    WhiteNA: null,\r\n    BlackNA: null,\r\n    WhiteType: null,\r\n    BlackType: null,\r\n    EventDate: null,\r\n    EventSponsor: null,\r\n    Section: null,\r\n    Stage: null,\r\n    Board: null,\r\n    Opening: null,\r\n    Variation: null,\r\n    SubVariation: null,\r\n    ECO: null,\r\n    NIC: null,\r\n    Time: null,\r\n    UTCTime: null,\r\n    UTCDate: null,\r\n    TimeControl: null,\r\n    SetUp: null,\r\n    FEN: null,\r\n    Termination: null,\r\n    Annotator: null,\r\n    Mode: null,\r\n    PlyCount: null,\r\n};\r\nconst HEADER_TEMPLATE = {\r\n    ...exports.SEVEN_TAG_ROSTER,\r\n    ...SUPLEMENTAL_TAGS,\r\n};\r\n/* eslint-enable @typescript-eslint/naming-convention */\r\n/*\r\n * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\r\n * ----------------------------------------------------------------------------\r\n * From https://github.com/jhlywa/chess.js/issues/230\r\n *\r\n * A lot of people are confused when they first see the internal representation\r\n * of chess.js. It uses the 0x88 Move Generation Algorithm which internally\r\n * stores the board as an 8x16 array. This is purely for efficiency but has a\r\n * couple of interesting benefits:\r\n *\r\n * 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\r\n *    square with 0x88, if the result is non-zero then the square is off the\r\n *    board. For example, assuming a knight square A8 (0 in 0x88 notation),\r\n *    there are 8 possible directions in which the knight can move. These\r\n *    directions are relative to the 8x16 board and are stored in the\r\n *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\r\n *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\r\n *    (because of two-complement representation of -18). The non-zero result\r\n *    means the square is off the board and the move is illegal. Take the\r\n *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\r\n *    means the square is on the board.\r\n *\r\n * 2. The relative distance (or difference) between two squares on a 8x16 board\r\n *    is unique and can be used to inexpensively determine if a piece on a\r\n *    square can attack any other arbitrary square. For example, let's see if a\r\n *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\r\n *    -80. We add 119 to make the ATTACKS array index non-negative (because the\r\n *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\r\n *    bitmask of pieces that can attack from that distance and direction.\r\n *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\r\n *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\r\n *    example, we would check to see if 24 & 0x1 is non-zero, which it is\r\n *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\r\n *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\r\n *    there are no blocking pieces between E7 and E2. That's where the RAYS\r\n *    array comes in. It provides an offset (in this case 16) to add to E7 (20)\r\n *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\r\n */\r\n// prettier-ignore\r\n// eslint-disable-next-line\r\nconst Ox88 = {\r\n    a8: 0, b8: 1, c8: 2, d8: 3, e8: 4, f8: 5, g8: 6, h8: 7,\r\n    a7: 16, b7: 17, c7: 18, d7: 19, e7: 20, f7: 21, g7: 22, h7: 23,\r\n    a6: 32, b6: 33, c6: 34, d6: 35, e6: 36, f6: 37, g6: 38, h6: 39,\r\n    a5: 48, b5: 49, c5: 50, d5: 51, e5: 52, f5: 53, g5: 54, h5: 55,\r\n    a4: 64, b4: 65, c4: 66, d4: 67, e4: 68, f4: 69, g4: 70, h4: 71,\r\n    a3: 80, b3: 81, c3: 82, d3: 83, e3: 84, f3: 85, g3: 86, h3: 87,\r\n    a2: 96, b2: 97, c2: 98, d2: 99, e2: 100, f2: 101, g2: 102, h2: 103,\r\n    a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\r\n};\r\nconst PAWN_OFFSETS = {\r\n    b: [16, 32, 17, 15],\r\n    w: [-16, -32, -17, -15],\r\n};\r\nconst PIECE_OFFSETS = {\r\n    n: [-18, -33, -31, -14, 18, 33, 31, 14],\r\n    b: [-17, -15, 17, 15],\r\n    r: [-16, 1, 16, -1],\r\n    q: [-17, -16, -15, 1, 17, 16, 15, -1],\r\n    k: [-17, -16, -15, 1, 17, 16, 15, -1],\r\n};\r\n// prettier-ignore\r\nconst ATTACKS = [\r\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0,\r\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\r\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\r\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\r\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\r\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\r\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\r\n    24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0,\r\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\r\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\r\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\r\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\r\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\r\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\r\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20\r\n];\r\n// prettier-ignore\r\nconst RAYS = [\r\n    17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0,\r\n    0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0,\r\n    0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0,\r\n    0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0,\r\n    0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0,\r\n    0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0,\r\n    0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0,\r\n    1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0,\r\n    0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0,\r\n    0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0,\r\n    0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0,\r\n    0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0,\r\n    0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0,\r\n    0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0,\r\n    -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17\r\n];\r\nconst PIECE_MASKS = { p: 0x1, n: 0x2, b: 0x4, r: 0x8, q: 0x10, k: 0x20 };\r\nconst SYMBOLS = 'pnbrqkPNBRQK';\r\nconst PROMOTIONS = [exports.KNIGHT, exports.BISHOP, exports.ROOK, exports.QUEEN];\r\nconst RANK_1 = 7;\r\nconst RANK_2 = 6;\r\n/*\r\n * const RANK_3 = 5\r\n * const RANK_4 = 4\r\n * const RANK_5 = 3\r\n * const RANK_6 = 2\r\n */\r\nconst RANK_7 = 1;\r\nconst RANK_8 = 0;\r\nconst SIDES = {\r\n    [exports.KING]: BITS.KSIDE_CASTLE,\r\n    [exports.QUEEN]: BITS.QSIDE_CASTLE,\r\n};\r\nconst ROOKS = {\r\n    w: [\r\n        { square: Ox88.a1, flag: BITS.QSIDE_CASTLE },\r\n        { square: Ox88.h1, flag: BITS.KSIDE_CASTLE },\r\n    ],\r\n    b: [\r\n        { square: Ox88.a8, flag: BITS.QSIDE_CASTLE },\r\n        { square: Ox88.h8, flag: BITS.KSIDE_CASTLE },\r\n    ],\r\n};\r\nconst SECOND_RANK = { b: RANK_7, w: RANK_2 };\r\n// Extracts the zero-based rank of an 0x88 square.\r\nfunction rank(square) {\r\n    return square >> 4;\r\n}\r\n// Extracts the zero-based file of an 0x88 square.\r\nfunction file(square) {\r\n    return square & 0xf;\r\n}\r\nfunction isDigit(c) {\r\n    return '0123456789'.indexOf(c) !== -1;\r\n}\r\n// Converts a 0x88 square to algebraic notation.\r\nfunction algebraic(square) {\r\n    const f = file(square);\r\n    const r = rank(square);\r\n    return ('abcdefgh'.substring(f, f + 1) +\r\n        '87654321'.substring(r, r + 1));\r\n}\r\nfunction swapColor(color) {\r\n    return color === exports.WHITE ? exports.BLACK : exports.WHITE;\r\n}\r\nfunction validateFen(fen) {\r\n    // 1st criterion: 6 space-seperated fields?\r\n    const tokens = fen.split(/\\s+/);\r\n    if (tokens.length !== 6) {\r\n        return {\r\n            ok: false,\r\n            error: 'Invalid FEN: must contain six space-delimited fields',\r\n        };\r\n    }\r\n    // 2nd criterion: move number field is a integer value > 0?\r\n    const moveNumber = parseInt(tokens[5], 10);\r\n    if (isNaN(moveNumber) || moveNumber <= 0) {\r\n        return {\r\n            ok: false,\r\n            error: 'Invalid FEN: move number must be a positive integer',\r\n        };\r\n    }\r\n    // 3rd criterion: half move counter is an integer >= 0?\r\n    const halfMoves = parseInt(tokens[4], 10);\r\n    if (isNaN(halfMoves) || halfMoves < 0) {\r\n        return {\r\n            ok: false,\r\n            error: 'Invalid FEN: half move counter number must be a non-negative integer',\r\n        };\r\n    }\r\n    // 4th criterion: 4th field is a valid e.p.-string?\r\n    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\r\n        return { ok: false, error: 'Invalid FEN: en-passant square is invalid' };\r\n    }\r\n    // 5th criterion: 3th field is a valid castle-string?\r\n    if (/[^kKqQ-]/.test(tokens[2])) {\r\n        return { ok: false, error: 'Invalid FEN: castling availability is invalid' };\r\n    }\r\n    // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\r\n    if (!/^(w|b)$/.test(tokens[1])) {\r\n        return { ok: false, error: 'Invalid FEN: side-to-move is invalid' };\r\n    }\r\n    // 7th criterion: 1st field contains 8 rows?\r\n    const rows = tokens[0].split('/');\r\n    if (rows.length !== 8) {\r\n        return {\r\n            ok: false,\r\n            error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\",\r\n        };\r\n    }\r\n    // 8th criterion: every row is valid?\r\n    for (let i = 0; i < rows.length; i++) {\r\n        // check for right sum of fields AND not two numbers in succession\r\n        let sumFields = 0;\r\n        let previousWasNumber = false;\r\n        for (let k = 0; k < rows[i].length; k++) {\r\n            if (isDigit(rows[i][k])) {\r\n                if (previousWasNumber) {\r\n                    return {\r\n                        ok: false,\r\n                        error: 'Invalid FEN: piece data is invalid (consecutive number)',\r\n                    };\r\n                }\r\n                sumFields += parseInt(rows[i][k], 10);\r\n                previousWasNumber = true;\r\n            }\r\n            else {\r\n                if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\r\n                    return {\r\n                        ok: false,\r\n                        error: 'Invalid FEN: piece data is invalid (invalid piece)',\r\n                    };\r\n                }\r\n                sumFields += 1;\r\n                previousWasNumber = false;\r\n            }\r\n        }\r\n        if (sumFields !== 8) {\r\n            return {\r\n                ok: false,\r\n                error: 'Invalid FEN: piece data is invalid (too many squares in rank)',\r\n            };\r\n        }\r\n    }\r\n    // 9th criterion: is en-passant square legal?\r\n    if ((tokens[3][1] == '3' && tokens[1] == 'w') ||\r\n        (tokens[3][1] == '6' && tokens[1] == 'b')) {\r\n        return { ok: false, error: 'Invalid FEN: illegal en-passant square' };\r\n    }\r\n    // 10th criterion: does chess position contain exact two kings?\r\n    const kings = [\r\n        { color: 'white', regex: /K/g },\r\n        { color: 'black', regex: /k/g },\r\n    ];\r\n    for (const { color, regex } of kings) {\r\n        if (!regex.test(tokens[0])) {\r\n            return { ok: false, error: `Invalid FEN: missing ${color} king` };\r\n        }\r\n        if ((tokens[0].match(regex) || []).length > 1) {\r\n            return { ok: false, error: `Invalid FEN: too many ${color} kings` };\r\n        }\r\n    }\r\n    // 11th criterion: are any pawns on the first or eighth rows?\r\n    if (Array.from(rows[0] + rows[7]).some((char) => char.toUpperCase() === 'P')) {\r\n        return {\r\n            ok: false,\r\n            error: 'Invalid FEN: some pawns are on the edge rows',\r\n        };\r\n    }\r\n    return { ok: true };\r\n}\r\nexports.validateFen = validateFen;\r\n// this function is used to uniquely identify ambiguous moves\r\nfunction getDisambiguator(move, moves) {\r\n    const from = move.from;\r\n    const to = move.to;\r\n    const piece = move.piece;\r\n    let ambiguities = 0;\r\n    let sameRank = 0;\r\n    let sameFile = 0;\r\n    for (let i = 0, len = moves.length; i < len; i++) {\r\n        const ambigFrom = moves[i].from;\r\n        const ambigTo = moves[i].to;\r\n        const ambigPiece = moves[i].piece;\r\n        /*\r\n         * if a move of the same piece type ends on the same to square, we'll need\r\n         * to add a disambiguator to the algebraic notation\r\n         */\r\n        if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\r\n            ambiguities++;\r\n            if (rank(from) === rank(ambigFrom)) {\r\n                sameRank++;\r\n            }\r\n            if (file(from) === file(ambigFrom)) {\r\n                sameFile++;\r\n            }\r\n        }\r\n    }\r\n    if (ambiguities > 0) {\r\n        if (sameRank > 0 && sameFile > 0) {\r\n            /*\r\n             * if there exists a similar moving piece on the same rank and file as\r\n             * the move in question, use the square as the disambiguator\r\n             */\r\n            return algebraic(from);\r\n        }\r\n        else if (sameFile > 0) {\r\n            /*\r\n             * if the moving piece rests on the same file, use the rank symbol as the\r\n             * disambiguator\r\n             */\r\n            return algebraic(from).charAt(1);\r\n        }\r\n        else {\r\n            // else use the file symbol\r\n            return algebraic(from).charAt(0);\r\n        }\r\n    }\r\n    return '';\r\n}\r\nfunction addMove(moves, color, from, to, piece, captured = undefined, flags = BITS.NORMAL) {\r\n    const r = rank(to);\r\n    if (piece === exports.PAWN && (r === RANK_1 || r === RANK_8)) {\r\n        for (let i = 0; i < PROMOTIONS.length; i++) {\r\n            const promotion = PROMOTIONS[i];\r\n            moves.push({\r\n                color,\r\n                from,\r\n                to,\r\n                piece,\r\n                captured,\r\n                promotion,\r\n                flags: flags | BITS.PROMOTION,\r\n            });\r\n        }\r\n    }\r\n    else {\r\n        moves.push({\r\n            color,\r\n            from,\r\n            to,\r\n            piece,\r\n            captured,\r\n            flags,\r\n        });\r\n    }\r\n}\r\nfunction inferPieceType(san) {\r\n    let pieceType = san.charAt(0);\r\n    if (pieceType >= 'a' && pieceType <= 'h') {\r\n        const matches = san.match(/[a-h]\\d.*[a-h]\\d/);\r\n        if (matches) {\r\n            return undefined;\r\n        }\r\n        return exports.PAWN;\r\n    }\r\n    pieceType = pieceType.toLowerCase();\r\n    if (pieceType === 'o') {\r\n        return exports.KING;\r\n    }\r\n    return pieceType;\r\n}\r\n// parses all of the decorators out of a SAN string\r\nfunction strippedSan(move) {\r\n    return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\r\n}\r\nclass Chess {\r\n    _board = new Array(128);\r\n    _turn = exports.WHITE;\r\n    _header = {};\r\n    _kings = { w: EMPTY, b: EMPTY };\r\n    _epSquare = -1;\r\n    _halfMoves = 0;\r\n    _moveNumber = 0;\r\n    _history = [];\r\n    _comments = {};\r\n    _castling = { w: 0, b: 0 };\r\n    _hash = 0n;\r\n    // tracks number of times a position has been seen for repetition checking\r\n    _positionCount = new Map();\r\n    constructor(fen = exports.DEFAULT_POSITION, { skipValidation = false } = {}) {\r\n        this.load(fen, { skipValidation });\r\n    }\r\n    clear({ preserveHeaders = false } = {}) {\r\n        this._board = new Array(128);\r\n        this._kings = { w: EMPTY, b: EMPTY };\r\n        this._turn = exports.WHITE;\r\n        this._castling = { w: 0, b: 0 };\r\n        this._epSquare = EMPTY;\r\n        this._halfMoves = 0;\r\n        this._moveNumber = 1;\r\n        this._history = [];\r\n        this._comments = {};\r\n        this._header = preserveHeaders ? this._header : { ...HEADER_TEMPLATE };\r\n        this._hash = this._computeHash();\r\n        this._positionCount = new Map();\r\n        /*\r\n         * Delete the SetUp and FEN headers (if preserved), the board is empty and\r\n         * these headers don't make sense in this state. They'll get added later\r\n         * via .load() or .put()\r\n         */\r\n        this._header['SetUp'] = null;\r\n        this._header['FEN'] = null;\r\n    }\r\n    load(fen, { skipValidation = false, preserveHeaders = false } = {}) {\r\n        let tokens = fen.split(/\\s+/);\r\n        // append commonly omitted fen tokens\r\n        if (tokens.length >= 2 && tokens.length < 6) {\r\n            const adjustments = ['-', '-', '0', '1'];\r\n            fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(' ');\r\n        }\r\n        tokens = fen.split(/\\s+/);\r\n        if (!skipValidation) {\r\n            const { ok, error } = validateFen(fen);\r\n            if (!ok) {\r\n                throw new Error(error);\r\n            }\r\n        }\r\n        const position = tokens[0];\r\n        let square = 0;\r\n        this.clear({ preserveHeaders });\r\n        for (let i = 0; i < position.length; i++) {\r\n            const piece = position.charAt(i);\r\n            if (piece === '/') {\r\n                square += 8;\r\n            }\r\n            else if (isDigit(piece)) {\r\n                square += parseInt(piece, 10);\r\n            }\r\n            else {\r\n                const color = piece < 'a' ? exports.WHITE : exports.BLACK;\r\n                this._put({ type: piece.toLowerCase(), color }, algebraic(square));\r\n                square++;\r\n            }\r\n        }\r\n        this._turn = tokens[1];\r\n        if (tokens[2].indexOf('K') > -1) {\r\n            this._castling.w |= BITS.KSIDE_CASTLE;\r\n        }\r\n        if (tokens[2].indexOf('Q') > -1) {\r\n            this._castling.w |= BITS.QSIDE_CASTLE;\r\n        }\r\n        if (tokens[2].indexOf('k') > -1) {\r\n            this._castling.b |= BITS.KSIDE_CASTLE;\r\n        }\r\n        if (tokens[2].indexOf('q') > -1) {\r\n            this._castling.b |= BITS.QSIDE_CASTLE;\r\n        }\r\n        this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3]];\r\n        this._halfMoves = parseInt(tokens[4], 10);\r\n        this._moveNumber = parseInt(tokens[5], 10);\r\n        this._hash = this._computeHash();\r\n        this._updateSetup(fen);\r\n        this._incPositionCount();\r\n    }\r\n    fen({ forceEnpassantSquare = false, } = {}) {\r\n        let empty = 0;\r\n        let fen = '';\r\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\r\n            if (this._board[i]) {\r\n                if (empty > 0) {\r\n                    fen += empty;\r\n                    empty = 0;\r\n                }\r\n                const { color, type: piece } = this._board[i];\r\n                fen += color === exports.WHITE ? piece.toUpperCase() : piece.toLowerCase();\r\n            }\r\n            else {\r\n                empty++;\r\n            }\r\n            if ((i + 1) & 0x88) {\r\n                if (empty > 0) {\r\n                    fen += empty;\r\n                }\r\n                if (i !== Ox88.h1) {\r\n                    fen += '/';\r\n                }\r\n                empty = 0;\r\n                i += 8;\r\n            }\r\n        }\r\n        let castling = '';\r\n        if (this._castling[exports.WHITE] & BITS.KSIDE_CASTLE) {\r\n            castling += 'K';\r\n        }\r\n        if (this._castling[exports.WHITE] & BITS.QSIDE_CASTLE) {\r\n            castling += 'Q';\r\n        }\r\n        if (this._castling[exports.BLACK] & BITS.KSIDE_CASTLE) {\r\n            castling += 'k';\r\n        }\r\n        if (this._castling[exports.BLACK] & BITS.QSIDE_CASTLE) {\r\n            castling += 'q';\r\n        }\r\n        // do we have an empty castling flag?\r\n        castling = castling || '-';\r\n        let epSquare = '-';\r\n        /*\r\n         * only print the ep square if en passant is a valid move (pawn is present\r\n         * and ep capture is not pinned)\r\n         */\r\n        if (this._epSquare !== EMPTY) {\r\n            if (forceEnpassantSquare) {\r\n                epSquare = algebraic(this._epSquare);\r\n            }\r\n            else {\r\n                const bigPawnSquare = this._epSquare + (this._turn === exports.WHITE ? 16 : -16);\r\n                const squares = [bigPawnSquare + 1, bigPawnSquare - 1];\r\n                for (const square of squares) {\r\n                    // is the square off the board?\r\n                    if (square & 0x88) {\r\n                        continue;\r\n                    }\r\n                    const color = this._turn;\r\n                    // is there a pawn that can capture the epSquare?\r\n                    if (this._board[square]?.color === color &&\r\n                        this._board[square]?.type === exports.PAWN) {\r\n                        // if the pawn makes an ep capture, does it leave its king in check?\r\n                        this._makeMove({\r\n                            color,\r\n                            from: square,\r\n                            to: this._epSquare,\r\n                            piece: exports.PAWN,\r\n                            captured: exports.PAWN,\r\n                            flags: BITS.EP_CAPTURE,\r\n                        });\r\n                        const isLegal = !this._isKingAttacked(color);\r\n                        this._undoMove();\r\n                        // if ep is legal, break and set the ep square in the FEN output\r\n                        if (isLegal) {\r\n                            epSquare = algebraic(this._epSquare);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return [\r\n            fen,\r\n            this._turn,\r\n            castling,\r\n            epSquare,\r\n            this._halfMoves,\r\n            this._moveNumber,\r\n        ].join(' ');\r\n    }\r\n    _pieceKey(i) {\r\n        if (!this._board[i]) {\r\n            return 0n;\r\n        }\r\n        const { color, type } = this._board[i];\r\n        const colorIndex = {\r\n            w: 0,\r\n            b: 1,\r\n        }[color];\r\n        const typeIndex = {\r\n            p: 0,\r\n            n: 1,\r\n            b: 2,\r\n            r: 3,\r\n            q: 4,\r\n            k: 5,\r\n        }[type];\r\n        return PIECE_KEYS[colorIndex][typeIndex][i];\r\n    }\r\n    _epKey() {\r\n        return this._epSquare === EMPTY ? 0n : EP_KEYS[this._epSquare & 7];\r\n    }\r\n    _castlingKey() {\r\n        const index = (this._castling.w >> 5) | (this._castling.b >> 3);\r\n        return CASTLING_KEYS[index];\r\n    }\r\n    _computeHash() {\r\n        let hash = 0n;\r\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\r\n            // did we run off the end of the board\r\n            if (i & 0x88) {\r\n                i += 7;\r\n                continue;\r\n            }\r\n            if (this._board[i]) {\r\n                hash ^= this._pieceKey(i);\r\n            }\r\n        }\r\n        hash ^= this._epKey();\r\n        hash ^= this._castlingKey();\r\n        if (this._turn === 'b') {\r\n            hash ^= SIDE_KEY;\r\n        }\r\n        return hash;\r\n    }\r\n    /*\r\n     * Called when the initial board setup is changed with put() or remove().\r\n     * modifies the SetUp and FEN properties of the header object. If the FEN\r\n     * is equal to the default position, the SetUp and FEN are deleted the setup\r\n     * is only updated if history.length is zero, ie moves haven't been made.\r\n     */\r\n    _updateSetup(fen) {\r\n        if (this._history.length > 0)\r\n            return;\r\n        if (fen !== exports.DEFAULT_POSITION) {\r\n            this._header['SetUp'] = '1';\r\n            this._header['FEN'] = fen;\r\n        }\r\n        else {\r\n            this._header['SetUp'] = null;\r\n            this._header['FEN'] = null;\r\n        }\r\n    }\r\n    reset() {\r\n        this.load(exports.DEFAULT_POSITION);\r\n    }\r\n    get(square) {\r\n        return this._board[Ox88[square]];\r\n    }\r\n    findPiece(piece) {\r\n        const squares = [];\r\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\r\n            // did we run off the end of the board\r\n            if (i & 0x88) {\r\n                i += 7;\r\n                continue;\r\n            }\r\n            // if empty square or wrong color\r\n            if (!this._board[i] || this._board[i]?.color !== piece.color) {\r\n                continue;\r\n            }\r\n            // check if square contains the requested piece\r\n            if (this._board[i].color === piece.color &&\r\n                this._board[i].type === piece.type) {\r\n                squares.push(algebraic(i));\r\n            }\r\n        }\r\n        return squares;\r\n    }\r\n    put({ type, color }, square) {\r\n        if (this._put({ type, color }, square)) {\r\n            this._updateCastlingRights();\r\n            this._updateEnPassantSquare();\r\n            this._updateSetup(this.fen());\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    _set(sq, piece) {\r\n        this._hash ^= this._pieceKey(sq);\r\n        this._board[sq] = piece;\r\n        this._hash ^= this._pieceKey(sq);\r\n    }\r\n    _put({ type, color }, square) {\r\n        // check for piece\r\n        if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\r\n            return false;\r\n        }\r\n        // check for valid square\r\n        if (!(square in Ox88)) {\r\n            return false;\r\n        }\r\n        const sq = Ox88[square];\r\n        // don't let the user place more than one king\r\n        if (type == exports.KING &&\r\n            !(this._kings[color] == EMPTY || this._kings[color] == sq)) {\r\n            return false;\r\n        }\r\n        const currentPieceOnSquare = this._board[sq];\r\n        // if one of the kings will be replaced by the piece from args, set the `_kings` respective entry to `EMPTY`\r\n        if (currentPieceOnSquare && currentPieceOnSquare.type === exports.KING) {\r\n            this._kings[currentPieceOnSquare.color] = EMPTY;\r\n        }\r\n        this._set(sq, { type: type, color: color });\r\n        if (type === exports.KING) {\r\n            this._kings[color] = sq;\r\n        }\r\n        return true;\r\n    }\r\n    _clear(sq) {\r\n        this._hash ^= this._pieceKey(sq);\r\n        delete this._board[sq];\r\n    }\r\n    remove(square) {\r\n        const piece = this.get(square);\r\n        this._clear(Ox88[square]);\r\n        if (piece && piece.type === exports.KING) {\r\n            this._kings[piece.color] = EMPTY;\r\n        }\r\n        this._updateCastlingRights();\r\n        this._updateEnPassantSquare();\r\n        this._updateSetup(this.fen());\r\n        return piece;\r\n    }\r\n    _updateCastlingRights() {\r\n        this._hash ^= this._castlingKey();\r\n        const whiteKingInPlace = this._board[Ox88.e1]?.type === exports.KING &&\r\n            this._board[Ox88.e1]?.color === exports.WHITE;\r\n        const blackKingInPlace = this._board[Ox88.e8]?.type === exports.KING &&\r\n            this._board[Ox88.e8]?.color === exports.BLACK;\r\n        if (!whiteKingInPlace ||\r\n            this._board[Ox88.a1]?.type !== exports.ROOK ||\r\n            this._board[Ox88.a1]?.color !== exports.WHITE) {\r\n            this._castling.w &= ~BITS.QSIDE_CASTLE;\r\n        }\r\n        if (!whiteKingInPlace ||\r\n            this._board[Ox88.h1]?.type !== exports.ROOK ||\r\n            this._board[Ox88.h1]?.color !== exports.WHITE) {\r\n            this._castling.w &= ~BITS.KSIDE_CASTLE;\r\n        }\r\n        if (!blackKingInPlace ||\r\n            this._board[Ox88.a8]?.type !== exports.ROOK ||\r\n            this._board[Ox88.a8]?.color !== exports.BLACK) {\r\n            this._castling.b &= ~BITS.QSIDE_CASTLE;\r\n        }\r\n        if (!blackKingInPlace ||\r\n            this._board[Ox88.h8]?.type !== exports.ROOK ||\r\n            this._board[Ox88.h8]?.color !== exports.BLACK) {\r\n            this._castling.b &= ~BITS.KSIDE_CASTLE;\r\n        }\r\n        this._hash ^= this._castlingKey();\r\n    }\r\n    _updateEnPassantSquare() {\r\n        if (this._epSquare === EMPTY) {\r\n            return;\r\n        }\r\n        const startSquare = this._epSquare + (this._turn === exports.WHITE ? -16 : 16);\r\n        const currentSquare = this._epSquare + (this._turn === exports.WHITE ? 16 : -16);\r\n        const attackers = [currentSquare + 1, currentSquare - 1];\r\n        if (this._board[startSquare] !== null ||\r\n            this._board[this._epSquare] !== null ||\r\n            this._board[currentSquare]?.color !== swapColor(this._turn) ||\r\n            this._board[currentSquare]?.type !== exports.PAWN) {\r\n            this._hash ^= this._epKey();\r\n            this._epSquare = EMPTY;\r\n            return;\r\n        }\r\n        const canCapture = (square) => !(square & 0x88) &&\r\n            this._board[square]?.color === this._turn &&\r\n            this._board[square]?.type === exports.PAWN;\r\n        if (!attackers.some(canCapture)) {\r\n            this._hash ^= this._epKey();\r\n            this._epSquare = EMPTY;\r\n        }\r\n    }\r\n    _attacked(color, square, verbose) {\r\n        const attackers = [];\r\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\r\n            // did we run off the end of the board\r\n            if (i & 0x88) {\r\n                i += 7;\r\n                continue;\r\n            }\r\n            // if empty square or wrong color\r\n            if (this._board[i] === undefined || this._board[i].color !== color) {\r\n                continue;\r\n            }\r\n            const piece = this._board[i];\r\n            const difference = i - square;\r\n            // skip - to/from square are the same\r\n            if (difference === 0) {\r\n                continue;\r\n            }\r\n            const index = difference + 119;\r\n            if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\r\n                if (piece.type === exports.PAWN) {\r\n                    if ((difference > 0 && piece.color === exports.WHITE) ||\r\n                        (difference <= 0 && piece.color === exports.BLACK)) {\r\n                        if (!verbose) {\r\n                            return true;\r\n                        }\r\n                        else {\r\n                            attackers.push(algebraic(i));\r\n                        }\r\n                    }\r\n                    continue;\r\n                }\r\n                // if the piece is a knight or a king\r\n                if (piece.type === 'n' || piece.type === 'k') {\r\n                    if (!verbose) {\r\n                        return true;\r\n                    }\r\n                    else {\r\n                        attackers.push(algebraic(i));\r\n                        continue;\r\n                    }\r\n                }\r\n                const offset = RAYS[index];\r\n                let j = i + offset;\r\n                let blocked = false;\r\n                while (j !== square) {\r\n                    if (this._board[j] != null) {\r\n                        blocked = true;\r\n                        break;\r\n                    }\r\n                    j += offset;\r\n                }\r\n                if (!blocked) {\r\n                    if (!verbose) {\r\n                        return true;\r\n                    }\r\n                    else {\r\n                        attackers.push(algebraic(i));\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (verbose) {\r\n            return attackers;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    attackers(square, attackedBy) {\r\n        if (!attackedBy) {\r\n            return this._attacked(this._turn, Ox88[square], true);\r\n        }\r\n        else {\r\n            return this._attacked(attackedBy, Ox88[square], true);\r\n        }\r\n    }\r\n    _isKingAttacked(color) {\r\n        const square = this._kings[color];\r\n        return square === -1 ? false : this._attacked(swapColor(color), square);\r\n    }\r\n    hash() {\r\n        return this._hash.toString(16);\r\n    }\r\n    isAttacked(square, attackedBy) {\r\n        return this._attacked(attackedBy, Ox88[square]);\r\n    }\r\n    isCheck() {\r\n        return this._isKingAttacked(this._turn);\r\n    }\r\n    inCheck() {\r\n        return this.isCheck();\r\n    }\r\n    isCheckmate() {\r\n        return this.isCheck() && this._moves().length === 0;\r\n    }\r\n    isStalemate() {\r\n        return !this.isCheck() && this._moves().length === 0;\r\n    }\r\n    isInsufficientMaterial() {\r\n        /*\r\n         * k.b. vs k.b. (of opposite colors) with mate in 1:\r\n         * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\r\n         *\r\n         * k.b. vs k.n. with mate in 1:\r\n         * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\r\n         */\r\n        const pieces = {\r\n            b: 0,\r\n            n: 0,\r\n            r: 0,\r\n            q: 0,\r\n            k: 0,\r\n            p: 0,\r\n        };\r\n        const bishops = [];\r\n        let numPieces = 0;\r\n        let squareColor = 0;\r\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\r\n            squareColor = (squareColor + 1) % 2;\r\n            if (i & 0x88) {\r\n                i += 7;\r\n                continue;\r\n            }\r\n            const piece = this._board[i];\r\n            if (piece) {\r\n                pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\r\n                if (piece.type === exports.BISHOP) {\r\n                    bishops.push(squareColor);\r\n                }\r\n                numPieces++;\r\n            }\r\n        }\r\n        // k vs. k\r\n        if (numPieces === 2) {\r\n            return true;\r\n        }\r\n        else if (\r\n        // k vs. kn .... or .... k vs. kb\r\n        numPieces === 3 &&\r\n            (pieces[exports.BISHOP] === 1 || pieces[exports.KNIGHT] === 1)) {\r\n            return true;\r\n        }\r\n        else if (numPieces === pieces[exports.BISHOP] + 2) {\r\n            // kb vs. kb where any number of bishops are all on the same color\r\n            let sum = 0;\r\n            const len = bishops.length;\r\n            for (let i = 0; i < len; i++) {\r\n                sum += bishops[i];\r\n            }\r\n            if (sum === 0 || sum === len) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    isThreefoldRepetition() {\r\n        return this._getPositionCount(this._hash) >= 3;\r\n    }\r\n    isDrawByFiftyMoves() {\r\n        return this._halfMoves >= 100; // 50 moves per side = 100 half moves\r\n    }\r\n    isDraw() {\r\n        return (this.isDrawByFiftyMoves() ||\r\n            this.isStalemate() ||\r\n            this.isInsufficientMaterial() ||\r\n            this.isThreefoldRepetition());\r\n    }\r\n    isGameOver() {\r\n        return this.isCheckmate() || this.isDraw();\r\n    }\r\n    moves({ verbose = false, square = undefined, piece = undefined, } = {}) {\r\n        const moves = this._moves({ square, piece });\r\n        if (verbose) {\r\n            return moves.map((move) => new Move(this, move));\r\n        }\r\n        else {\r\n            return moves.map((move) => this._moveToSan(move, moves));\r\n        }\r\n    }\r\n    _moves({ legal = true, piece = undefined, square = undefined, } = {}) {\r\n        const forSquare = square ? square.toLowerCase() : undefined;\r\n        const forPiece = piece?.toLowerCase();\r\n        const moves = [];\r\n        const us = this._turn;\r\n        const them = swapColor(us);\r\n        let firstSquare = Ox88.a8;\r\n        let lastSquare = Ox88.h1;\r\n        let singleSquare = false;\r\n        // are we generating moves for a single square?\r\n        if (forSquare) {\r\n            // illegal square, return empty moves\r\n            if (!(forSquare in Ox88)) {\r\n                return [];\r\n            }\r\n            else {\r\n                firstSquare = lastSquare = Ox88[forSquare];\r\n                singleSquare = true;\r\n            }\r\n        }\r\n        for (let from = firstSquare; from <= lastSquare; from++) {\r\n            // did we run off the end of the board\r\n            if (from & 0x88) {\r\n                from += 7;\r\n                continue;\r\n            }\r\n            // empty square or opponent, skip\r\n            if (!this._board[from] || this._board[from].color === them) {\r\n                continue;\r\n            }\r\n            const { type } = this._board[from];\r\n            let to;\r\n            if (type === exports.PAWN) {\r\n                if (forPiece && forPiece !== type)\r\n                    continue;\r\n                // single square, non-capturing\r\n                to = from + PAWN_OFFSETS[us][0];\r\n                if (!this._board[to]) {\r\n                    addMove(moves, us, from, to, exports.PAWN);\r\n                    // double square\r\n                    to = from + PAWN_OFFSETS[us][1];\r\n                    if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\r\n                        addMove(moves, us, from, to, exports.PAWN, undefined, BITS.BIG_PAWN);\r\n                    }\r\n                }\r\n                // pawn captures\r\n                for (let j = 2; j < 4; j++) {\r\n                    to = from + PAWN_OFFSETS[us][j];\r\n                    if (to & 0x88)\r\n                        continue;\r\n                    if (this._board[to]?.color === them) {\r\n                        addMove(moves, us, from, to, exports.PAWN, this._board[to].type, BITS.CAPTURE);\r\n                    }\r\n                    else if (to === this._epSquare) {\r\n                        addMove(moves, us, from, to, exports.PAWN, exports.PAWN, BITS.EP_CAPTURE);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (forPiece && forPiece !== type)\r\n                    continue;\r\n                for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {\r\n                    const offset = PIECE_OFFSETS[type][j];\r\n                    to = from;\r\n                    while (true) {\r\n                        to += offset;\r\n                        if (to & 0x88)\r\n                            break;\r\n                        if (!this._board[to]) {\r\n                            addMove(moves, us, from, to, type);\r\n                        }\r\n                        else {\r\n                            // own color, stop loop\r\n                            if (this._board[to].color === us)\r\n                                break;\r\n                            addMove(moves, us, from, to, type, this._board[to].type, BITS.CAPTURE);\r\n                            break;\r\n                        }\r\n                        /* break, if knight or king */\r\n                        if (type === exports.KNIGHT || type === exports.KING)\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        /*\r\n         * check for castling if we're:\r\n         *   a) generating all moves, or\r\n         *   b) doing single square move generation on the king's square\r\n         */\r\n        if (forPiece === undefined || forPiece === exports.KING) {\r\n            if (!singleSquare || lastSquare === this._kings[us]) {\r\n                // king-side castling\r\n                if (this._castling[us] & BITS.KSIDE_CASTLE) {\r\n                    const castlingFrom = this._kings[us];\r\n                    const castlingTo = castlingFrom + 2;\r\n                    if (!this._board[castlingFrom + 1] &&\r\n                        !this._board[castlingTo] &&\r\n                        !this._attacked(them, this._kings[us]) &&\r\n                        !this._attacked(them, castlingFrom + 1) &&\r\n                        !this._attacked(them, castlingTo)) {\r\n                        addMove(moves, us, this._kings[us], castlingTo, exports.KING, undefined, BITS.KSIDE_CASTLE);\r\n                    }\r\n                }\r\n                // queen-side castling\r\n                if (this._castling[us] & BITS.QSIDE_CASTLE) {\r\n                    const castlingFrom = this._kings[us];\r\n                    const castlingTo = castlingFrom - 2;\r\n                    if (!this._board[castlingFrom - 1] &&\r\n                        !this._board[castlingFrom - 2] &&\r\n                        !this._board[castlingFrom - 3] &&\r\n                        !this._attacked(them, this._kings[us]) &&\r\n                        !this._attacked(them, castlingFrom - 1) &&\r\n                        !this._attacked(them, castlingTo)) {\r\n                        addMove(moves, us, this._kings[us], castlingTo, exports.KING, undefined, BITS.QSIDE_CASTLE);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        /*\r\n         * return all pseudo-legal moves (this includes moves that allow the king\r\n         * to be captured)\r\n         */\r\n        if (!legal || this._kings[us] === -1) {\r\n            return moves;\r\n        }\r\n        // filter out illegal moves\r\n        const legalMoves = [];\r\n        for (let i = 0, len = moves.length; i < len; i++) {\r\n            this._makeMove(moves[i]);\r\n            if (!this._isKingAttacked(us)) {\r\n                legalMoves.push(moves[i]);\r\n            }\r\n            this._undoMove();\r\n        }\r\n        return legalMoves;\r\n    }\r\n    move(move, { strict = false } = {}) {\r\n        /*\r\n         * The move function can be called with in the following parameters:\r\n         *\r\n         * .move('Nxb7')       <- argument is a case-sensitive SAN string\r\n         *\r\n         * .move({ from: 'h7', <- argument is a move object\r\n         *         to :'h8',\r\n         *         promotion: 'q' })\r\n         *\r\n         *\r\n         * An optional strict argument may be supplied to tell chess.js to\r\n         * strictly follow the SAN specification.\r\n         */\r\n        let moveObj = null;\r\n        if (typeof move === 'string') {\r\n            moveObj = this._moveFromSan(move, strict);\r\n        }\r\n        else if (typeof move === 'object') {\r\n            const moves = this._moves();\r\n            // convert the pretty move object to an ugly move object\r\n            for (let i = 0, len = moves.length; i < len; i++) {\r\n                if (move.from === algebraic(moves[i].from) &&\r\n                    move.to === algebraic(moves[i].to) &&\r\n                    (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)) {\r\n                    moveObj = moves[i];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // failed to find move\r\n        if (!moveObj) {\r\n            if (typeof move === 'string') {\r\n                throw new Error(`Invalid move: ${move}`);\r\n            }\r\n            else {\r\n                throw new Error(`Invalid move: ${JSON.stringify(move)}`);\r\n            }\r\n        }\r\n        /*\r\n         * need to make a copy of move because we can't generate SAN after the move\r\n         * is made\r\n         */\r\n        const prettyMove = new Move(this, moveObj);\r\n        this._makeMove(moveObj);\r\n        this._incPositionCount();\r\n        return prettyMove;\r\n    }\r\n    _push(move) {\r\n        this._history.push({\r\n            move,\r\n            kings: { b: this._kings.b, w: this._kings.w },\r\n            turn: this._turn,\r\n            castling: { b: this._castling.b, w: this._castling.w },\r\n            epSquare: this._epSquare,\r\n            halfMoves: this._halfMoves,\r\n            moveNumber: this._moveNumber,\r\n        });\r\n    }\r\n    _movePiece(from, to) {\r\n        this._hash ^= this._pieceKey(from);\r\n        this._board[to] = this._board[from];\r\n        delete this._board[from];\r\n        this._hash ^= this._pieceKey(to);\r\n    }\r\n    _makeMove(move) {\r\n        const us = this._turn;\r\n        const them = swapColor(us);\r\n        this._push(move);\r\n        this._hash ^= this._epKey();\r\n        this._hash ^= this._castlingKey();\r\n        if (move.captured) {\r\n            this._hash ^= this._pieceKey(move.to);\r\n        }\r\n        this._movePiece(move.from, move.to);\r\n        // if ep capture, remove the captured pawn\r\n        if (move.flags & BITS.EP_CAPTURE) {\r\n            if (this._turn === exports.BLACK) {\r\n                this._clear(move.to - 16);\r\n            }\r\n            else {\r\n                this._clear(move.to + 16);\r\n            }\r\n        }\r\n        // if pawn promotion, replace with new piece\r\n        if (move.promotion) {\r\n            this._clear(move.to);\r\n            this._set(move.to, { type: move.promotion, color: us });\r\n        }\r\n        // if we moved the king\r\n        if (this._board[move.to].type === exports.KING) {\r\n            this._kings[us] = move.to;\r\n            // if we castled, move the rook next to the king\r\n            if (move.flags & BITS.KSIDE_CASTLE) {\r\n                const castlingTo = move.to - 1;\r\n                const castlingFrom = move.to + 1;\r\n                this._movePiece(castlingFrom, castlingTo);\r\n            }\r\n            else if (move.flags & BITS.QSIDE_CASTLE) {\r\n                const castlingTo = move.to + 1;\r\n                const castlingFrom = move.to - 2;\r\n                this._movePiece(castlingFrom, castlingTo);\r\n            }\r\n            // turn off castling\r\n            this._castling[us] = 0;\r\n        }\r\n        // turn off castling if we move a rook\r\n        if (this._castling[us]) {\r\n            for (let i = 0, len = ROOKS[us].length; i < len; i++) {\r\n                if (move.from === ROOKS[us][i].square &&\r\n                    this._castling[us] & ROOKS[us][i].flag) {\r\n                    this._castling[us] ^= ROOKS[us][i].flag;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // turn off castling if we capture a rook\r\n        if (this._castling[them]) {\r\n            for (let i = 0, len = ROOKS[them].length; i < len; i++) {\r\n                if (move.to === ROOKS[them][i].square &&\r\n                    this._castling[them] & ROOKS[them][i].flag) {\r\n                    this._castling[them] ^= ROOKS[them][i].flag;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        this._hash ^= this._castlingKey();\r\n        // if big pawn move, update the en passant square\r\n        if (move.flags & BITS.BIG_PAWN) {\r\n            let epSquare;\r\n            if (us === exports.BLACK) {\r\n                epSquare = move.to - 16;\r\n            }\r\n            else {\r\n                epSquare = move.to + 16;\r\n            }\r\n            if ((!((move.to - 1) & 0x88) &&\r\n                this._board[move.to - 1]?.type === exports.PAWN &&\r\n                this._board[move.to - 1]?.color === them) ||\r\n                (!((move.to + 1) & 0x88) &&\r\n                    this._board[move.to + 1]?.type === exports.PAWN &&\r\n                    this._board[move.to + 1]?.color === them)) {\r\n                this._epSquare = epSquare;\r\n                this._hash ^= this._epKey();\r\n            }\r\n            else {\r\n                this._epSquare = EMPTY;\r\n            }\r\n        }\r\n        else {\r\n            this._epSquare = EMPTY;\r\n        }\r\n        // reset the 50 move counter if a pawn is moved or a piece is captured\r\n        if (move.piece === exports.PAWN) {\r\n            this._halfMoves = 0;\r\n        }\r\n        else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\r\n            this._halfMoves = 0;\r\n        }\r\n        else {\r\n            this._halfMoves++;\r\n        }\r\n        if (us === exports.BLACK) {\r\n            this._moveNumber++;\r\n        }\r\n        this._turn = them;\r\n        this._hash ^= SIDE_KEY;\r\n    }\r\n    undo() {\r\n        const hash = this._hash;\r\n        const move = this._undoMove();\r\n        if (move) {\r\n            const prettyMove = new Move(this, move);\r\n            this._decPositionCount(hash);\r\n            return prettyMove;\r\n        }\r\n        return null;\r\n    }\r\n    _undoMove() {\r\n        const old = this._history.pop();\r\n        if (old === undefined) {\r\n            return null;\r\n        }\r\n        this._hash ^= this._epKey();\r\n        this._hash ^= this._castlingKey();\r\n        const move = old.move;\r\n        this._kings = old.kings;\r\n        this._turn = old.turn;\r\n        this._castling = old.castling;\r\n        this._epSquare = old.epSquare;\r\n        this._halfMoves = old.halfMoves;\r\n        this._moveNumber = old.moveNumber;\r\n        this._hash ^= this._epKey();\r\n        this._hash ^= this._castlingKey();\r\n        this._hash ^= SIDE_KEY;\r\n        const us = this._turn;\r\n        const them = swapColor(us);\r\n        this._movePiece(move.to, move.from);\r\n        // to undo any promotions\r\n        if (move.piece) {\r\n            this._clear(move.from);\r\n            this._set(move.from, { type: move.piece, color: us });\r\n        }\r\n        if (move.captured) {\r\n            if (move.flags & BITS.EP_CAPTURE) {\r\n                // en passant capture\r\n                let index;\r\n                if (us === exports.BLACK) {\r\n                    index = move.to - 16;\r\n                }\r\n                else {\r\n                    index = move.to + 16;\r\n                }\r\n                this._set(index, { type: exports.PAWN, color: them });\r\n            }\r\n            else {\r\n                // regular capture\r\n                this._set(move.to, { type: move.captured, color: them });\r\n            }\r\n        }\r\n        if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\r\n            let castlingTo, castlingFrom;\r\n            if (move.flags & BITS.KSIDE_CASTLE) {\r\n                castlingTo = move.to + 1;\r\n                castlingFrom = move.to - 1;\r\n            }\r\n            else {\r\n                castlingTo = move.to - 2;\r\n                castlingFrom = move.to + 1;\r\n            }\r\n            this._movePiece(castlingFrom, castlingTo);\r\n        }\r\n        return move;\r\n    }\r\n    pgn({ newline = '\\n', maxWidth = 0, } = {}) {\r\n        /*\r\n         * using the specification from http://www.chessclub.com/help/PGN-spec\r\n         * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\r\n         */\r\n        const result = [];\r\n        let headerExists = false;\r\n        /* add the PGN header information */\r\n        for (const i in this._header) {\r\n            /*\r\n             * TODO: order of enumerated properties in header object is not\r\n             * guaranteed, see ECMA-262 spec (section 12.6.4)\r\n             *\r\n             * By using HEADER_TEMPLATE, the order of tags should be preserved; we\r\n             * do have to check for null placeholders, though, and omit them\r\n             */\r\n            const headerTag = this._header[i];\r\n            if (headerTag)\r\n                result.push(`[${i} \"${this._header[i]}\"]` + newline);\r\n            headerExists = true;\r\n        }\r\n        if (headerExists && this._history.length) {\r\n            result.push(newline);\r\n        }\r\n        const appendComment = (moveString) => {\r\n            const comment = this._comments[this.fen()];\r\n            if (typeof comment !== 'undefined') {\r\n                const delimiter = moveString.length > 0 ? ' ' : '';\r\n                moveString = `${moveString}${delimiter}{${comment}}`;\r\n            }\r\n            return moveString;\r\n        };\r\n        // pop all of history onto reversed_history\r\n        const reversedHistory = [];\r\n        while (this._history.length > 0) {\r\n            reversedHistory.push(this._undoMove());\r\n        }\r\n        const moves = [];\r\n        let moveString = '';\r\n        // special case of a commented starting position with no moves\r\n        if (reversedHistory.length === 0) {\r\n            moves.push(appendComment(''));\r\n        }\r\n        // build the list of moves.  a move_string looks like: \"3. e3 e6\"\r\n        while (reversedHistory.length > 0) {\r\n            moveString = appendComment(moveString);\r\n            const move = reversedHistory.pop();\r\n            // make TypeScript stop complaining about move being undefined\r\n            if (!move) {\r\n                break;\r\n            }\r\n            // if the position started with black to move, start PGN with #. ...\r\n            if (!this._history.length && move.color === 'b') {\r\n                const prefix = `${this._moveNumber}. ...`;\r\n                // is there a comment preceding the first move?\r\n                moveString = moveString ? `${moveString} ${prefix}` : prefix;\r\n            }\r\n            else if (move.color === 'w') {\r\n                // store the previous generated move_string if we have one\r\n                if (moveString.length) {\r\n                    moves.push(moveString);\r\n                }\r\n                moveString = this._moveNumber + '.';\r\n            }\r\n            moveString =\r\n                moveString + ' ' + this._moveToSan(move, this._moves({ legal: true }));\r\n            this._makeMove(move);\r\n        }\r\n        // are there any other leftover moves?\r\n        if (moveString.length) {\r\n            moves.push(appendComment(moveString));\r\n        }\r\n        // is there a result? (there ALWAYS has to be a result according to spec; see Seven Tag Roster)\r\n        moves.push(this._header.Result || '*');\r\n        /*\r\n         * history should be back to what it was before we started generating PGN,\r\n         * so join together moves\r\n         */\r\n        if (maxWidth === 0) {\r\n            return result.join('') + moves.join(' ');\r\n        }\r\n        // TODO (jah): huh?\r\n        const strip = function () {\r\n            if (result.length > 0 && result[result.length - 1] === ' ') {\r\n                result.pop();\r\n                return true;\r\n            }\r\n            return false;\r\n        };\r\n        // NB: this does not preserve comment whitespace.\r\n        const wrapComment = function (width, move) {\r\n            for (const token of move.split(' ')) {\r\n                if (!token) {\r\n                    continue;\r\n                }\r\n                if (width + token.length > maxWidth) {\r\n                    while (strip()) {\r\n                        width--;\r\n                    }\r\n                    result.push(newline);\r\n                    width = 0;\r\n                }\r\n                result.push(token);\r\n                width += token.length;\r\n                result.push(' ');\r\n                width++;\r\n            }\r\n            if (strip()) {\r\n                width--;\r\n            }\r\n            return width;\r\n        };\r\n        // wrap the PGN output at max_width\r\n        let currentWidth = 0;\r\n        for (let i = 0; i < moves.length; i++) {\r\n            if (currentWidth + moves[i].length > maxWidth) {\r\n                if (moves[i].includes('{')) {\r\n                    currentWidth = wrapComment(currentWidth, moves[i]);\r\n                    continue;\r\n                }\r\n            }\r\n            // if the current move will push past max_width\r\n            if (currentWidth + moves[i].length > maxWidth && i !== 0) {\r\n                // don't end the line with whitespace\r\n                if (result[result.length - 1] === ' ') {\r\n                    result.pop();\r\n                }\r\n                result.push(newline);\r\n                currentWidth = 0;\r\n            }\r\n            else if (i !== 0) {\r\n                result.push(' ');\r\n                currentWidth++;\r\n            }\r\n            result.push(moves[i]);\r\n            currentWidth += moves[i].length;\r\n        }\r\n        return result.join('');\r\n    }\r\n    /**\r\n     * @deprecated Use `setHeader` and `getHeaders` instead. This method will return null header tags (which is not what you want)\r\n     */\r\n    header(...args) {\r\n        for (let i = 0; i < args.length; i += 2) {\r\n            if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\r\n                this._header[args[i]] = args[i + 1];\r\n            }\r\n        }\r\n        return this._header;\r\n    }\r\n    // TODO: value validation per spec\r\n    setHeader(key, value) {\r\n        this._header[key] = value ?? exports.SEVEN_TAG_ROSTER[key] ?? null;\r\n        return this.getHeaders();\r\n    }\r\n    removeHeader(key) {\r\n        if (key in this._header) {\r\n            this._header[key] = exports.SEVEN_TAG_ROSTER[key] || null;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // return only non-null headers (omit placemarker nulls)\r\n    getHeaders() {\r\n        const nonNullHeaders = {};\r\n        for (const [key, value] of Object.entries(this._header)) {\r\n            if (value !== null) {\r\n                nonNullHeaders[key] = value;\r\n            }\r\n        }\r\n        return nonNullHeaders;\r\n    }\r\n    loadPgn(pgn, { strict = false, newlineChar = '\\r?\\n', } = {}) {\r\n        // If newlineChar is not the default, replace all instances with \\n\r\n        if (newlineChar !== '\\r?\\n') {\r\n            pgn = pgn.replace(new RegExp(newlineChar, 'g'), '\\n');\r\n        }\r\n        const parsedPgn = (0, pgn_1.parse)(pgn);\r\n        // Put the board in the starting position\r\n        this.reset();\r\n        // parse PGN header\r\n        const headers = parsedPgn.headers;\r\n        let fen = '';\r\n        for (const key in headers) {\r\n            // check to see user is including fen (possibly with wrong tag case)\r\n            if (key.toLowerCase() === 'fen') {\r\n                fen = headers[key];\r\n            }\r\n            this.header(key, headers[key]);\r\n        }\r\n        /*\r\n         * the permissive parser should attempt to load a fen tag, even if it's the\r\n         * wrong case and doesn't include a corresponding [SetUp \"1\"] tag\r\n         */\r\n        if (!strict) {\r\n            if (fen) {\r\n                this.load(fen, { preserveHeaders: true });\r\n            }\r\n        }\r\n        else {\r\n            /*\r\n             * strict parser - load the starting position indicated by [Setup '1']\r\n             * and [FEN position]\r\n             */\r\n            if (headers['SetUp'] === '1') {\r\n                if (!('FEN' in headers)) {\r\n                    throw new Error('Invalid PGN: FEN tag must be supplied with SetUp tag');\r\n                }\r\n                // don't clear the headers when loading\r\n                this.load(headers['FEN'], { preserveHeaders: true });\r\n            }\r\n        }\r\n        let node = parsedPgn.root;\r\n        while (node) {\r\n            if (node.move) {\r\n                const move = this._moveFromSan(node.move, strict);\r\n                if (move == null) {\r\n                    throw new Error(`Invalid move in PGN: ${node.move}`);\r\n                }\r\n                else {\r\n                    this._makeMove(move);\r\n                    this._incPositionCount();\r\n                }\r\n            }\r\n            if (node.comment !== undefined) {\r\n                this._comments[this.fen()] = node.comment;\r\n            }\r\n            node = node.variations[0];\r\n        }\r\n        /*\r\n         * Per section 8.2.6 of the PGN spec, the Result tag pair must match match\r\n         * the termination marker. Only do this when headers are present, but the\r\n         * result tag is missing\r\n         */\r\n        const result = parsedPgn.result;\r\n        if (result &&\r\n            Object.keys(this._header).length &&\r\n            this._header['Result'] !== result) {\r\n            this.setHeader('Result', result);\r\n        }\r\n    }\r\n    /*\r\n     * Convert a move from 0x88 coordinates to Standard Algebraic Notation\r\n     * (SAN)\r\n     *\r\n     * @param {boolean} strict Use the strict SAN parser. It will throw errors\r\n     * on overly disambiguated moves (see below):\r\n     *\r\n     * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\r\n     * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\r\n     * 4. ... Ne7 is technically the valid SAN\r\n     */\r\n    _moveToSan(move, moves) {\r\n        let output = '';\r\n        if (move.flags & BITS.KSIDE_CASTLE) {\r\n            output = 'O-O';\r\n        }\r\n        else if (move.flags & BITS.QSIDE_CASTLE) {\r\n            output = 'O-O-O';\r\n        }\r\n        else {\r\n            if (move.piece !== exports.PAWN) {\r\n                const disambiguator = getDisambiguator(move, moves);\r\n                output += move.piece.toUpperCase() + disambiguator;\r\n            }\r\n            if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\r\n                if (move.piece === exports.PAWN) {\r\n                    output += algebraic(move.from)[0];\r\n                }\r\n                output += 'x';\r\n            }\r\n            output += algebraic(move.to);\r\n            if (move.promotion) {\r\n                output += '=' + move.promotion.toUpperCase();\r\n            }\r\n        }\r\n        this._makeMove(move);\r\n        if (this.isCheck()) {\r\n            if (this.isCheckmate()) {\r\n                output += '#';\r\n            }\r\n            else {\r\n                output += '+';\r\n            }\r\n        }\r\n        this._undoMove();\r\n        return output;\r\n    }\r\n    // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\r\n    _moveFromSan(move, strict = false) {\r\n        // strip off any move decorations: e.g Nf3+?! becomes Nf3\r\n        let cleanMove = strippedSan(move);\r\n        if (!strict) {\r\n            if (cleanMove === '0-0') {\r\n                cleanMove = 'O-O';\r\n            }\r\n            else if (cleanMove === '0-0-0') {\r\n                cleanMove = 'O-O-O';\r\n            }\r\n        }\r\n        let pieceType = inferPieceType(cleanMove);\r\n        let moves = this._moves({ legal: true, piece: pieceType });\r\n        // strict parser\r\n        for (let i = 0, len = moves.length; i < len; i++) {\r\n            if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\r\n                return moves[i];\r\n            }\r\n        }\r\n        // the strict parser failed\r\n        if (strict) {\r\n            return null;\r\n        }\r\n        let piece = undefined;\r\n        let matches = undefined;\r\n        let from = undefined;\r\n        let to = undefined;\r\n        let promotion = undefined;\r\n        /*\r\n         * The default permissive (non-strict) parser allows the user to parse\r\n         * non-standard chess notations. This parser is only run after the strict\r\n         * Standard Algebraic Notation (SAN) parser has failed.\r\n         *\r\n         * When running the permissive parser, we'll run a regex to grab the piece, the\r\n         * to/from square, and an optional promotion piece. This regex will\r\n         * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\r\n         * f7f8q, b1c3\r\n         *\r\n         * NOTE: Some positions and moves may be ambiguous when using the permissive\r\n         * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\r\n         * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop\r\n         * move). In these cases, the permissive parser will default to the most\r\n         * basic interpretation (which is b1c3 parsing to Nc3).\r\n         */\r\n        let overlyDisambiguated = false;\r\n        matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/);\r\n        if (matches) {\r\n            piece = matches[1];\r\n            from = matches[2];\r\n            to = matches[3];\r\n            promotion = matches[4];\r\n            if (from.length == 1) {\r\n                overlyDisambiguated = true;\r\n            }\r\n        }\r\n        else {\r\n            /*\r\n             * The [a-h]?[1-8]? portion of the regex below handles moves that may be\r\n             * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when\r\n             * there is one legal knight move to e7). In this case, the value of\r\n             * 'from' variable will be a rank or file, not a square.\r\n             */\r\n            matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/);\r\n            if (matches) {\r\n                piece = matches[1];\r\n                from = matches[2];\r\n                to = matches[3];\r\n                promotion = matches[4];\r\n                if (from.length == 1) {\r\n                    overlyDisambiguated = true;\r\n                }\r\n            }\r\n        }\r\n        pieceType = inferPieceType(cleanMove);\r\n        moves = this._moves({\r\n            legal: true,\r\n            piece: piece ? piece : pieceType,\r\n        });\r\n        if (!to) {\r\n            return null;\r\n        }\r\n        for (let i = 0, len = moves.length; i < len; i++) {\r\n            if (!from) {\r\n                // if there is no from square, it could be just 'x' missing from a capture\r\n                if (cleanMove ===\r\n                    strippedSan(this._moveToSan(moves[i], moves)).replace('x', '')) {\r\n                    return moves[i];\r\n                }\r\n                // hand-compare move properties with the results from our permissive regex\r\n            }\r\n            else if ((!piece || piece.toLowerCase() == moves[i].piece) &&\r\n                Ox88[from] == moves[i].from &&\r\n                Ox88[to] == moves[i].to &&\r\n                (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\r\n                return moves[i];\r\n            }\r\n            else if (overlyDisambiguated) {\r\n                /*\r\n                 * SPECIAL CASE: we parsed a move string that may have an unneeded\r\n                 * rank/file disambiguator (e.g. Nge7).  The 'from' variable will\r\n                 */\r\n                const square = algebraic(moves[i].from);\r\n                if ((!piece || piece.toLowerCase() == moves[i].piece) &&\r\n                    Ox88[to] == moves[i].to &&\r\n                    (from == square[0] || from == square[1]) &&\r\n                    (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\r\n                    return moves[i];\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    ascii() {\r\n        let s = '   +------------------------+\\n';\r\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\r\n            // display the rank\r\n            if (file(i) === 0) {\r\n                s += ' ' + '87654321'[rank(i)] + ' |';\r\n            }\r\n            if (this._board[i]) {\r\n                const piece = this._board[i].type;\r\n                const color = this._board[i].color;\r\n                const symbol = color === exports.WHITE ? piece.toUpperCase() : piece.toLowerCase();\r\n                s += ' ' + symbol + ' ';\r\n            }\r\n            else {\r\n                s += ' . ';\r\n            }\r\n            if ((i + 1) & 0x88) {\r\n                s += '|\\n';\r\n                i += 8;\r\n            }\r\n        }\r\n        s += '   +------------------------+\\n';\r\n        s += '     a  b  c  d  e  f  g  h';\r\n        return s;\r\n    }\r\n    perft(depth) {\r\n        const moves = this._moves({ legal: false });\r\n        let nodes = 0;\r\n        const color = this._turn;\r\n        for (let i = 0, len = moves.length; i < len; i++) {\r\n            this._makeMove(moves[i]);\r\n            if (!this._isKingAttacked(color)) {\r\n                if (depth - 1 > 0) {\r\n                    nodes += this.perft(depth - 1);\r\n                }\r\n                else {\r\n                    nodes++;\r\n                }\r\n            }\r\n            this._undoMove();\r\n        }\r\n        return nodes;\r\n    }\r\n    turn() {\r\n        return this._turn;\r\n    }\r\n    board() {\r\n        const output = [];\r\n        let row = [];\r\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\r\n            if (this._board[i] == null) {\r\n                row.push(null);\r\n            }\r\n            else {\r\n                row.push({\r\n                    square: algebraic(i),\r\n                    type: this._board[i].type,\r\n                    color: this._board[i].color,\r\n                });\r\n            }\r\n            if ((i + 1) & 0x88) {\r\n                output.push(row);\r\n                row = [];\r\n                i += 8;\r\n            }\r\n        }\r\n        return output;\r\n    }\r\n    squareColor(square) {\r\n        if (square in Ox88) {\r\n            const sq = Ox88[square];\r\n            return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark';\r\n        }\r\n        return null;\r\n    }\r\n    history({ verbose = false } = {}) {\r\n        const reversedHistory = [];\r\n        const moveHistory = [];\r\n        while (this._history.length > 0) {\r\n            reversedHistory.push(this._undoMove());\r\n        }\r\n        while (true) {\r\n            const move = reversedHistory.pop();\r\n            if (!move) {\r\n                break;\r\n            }\r\n            if (verbose) {\r\n                moveHistory.push(new Move(this, move));\r\n            }\r\n            else {\r\n                moveHistory.push(this._moveToSan(move, this._moves()));\r\n            }\r\n            this._makeMove(move);\r\n        }\r\n        return moveHistory;\r\n    }\r\n    /*\r\n     * Keeps track of position occurrence counts for the purpose of repetition\r\n     * checking. Old positions are removed from the map if their counts are reduced to 0.\r\n     */\r\n    _getPositionCount(hash) {\r\n        return this._positionCount.get(hash) ?? 0;\r\n    }\r\n    _incPositionCount() {\r\n        this._positionCount.set(this._hash, (this._positionCount.get(this._hash) ?? 0) + 1);\r\n    }\r\n    _decPositionCount(hash) {\r\n        const currentCount = this._positionCount.get(hash) ?? 0;\r\n        if (currentCount === 1) {\r\n            this._positionCount.delete(hash);\r\n        }\r\n        else {\r\n            this._positionCount.set(hash, currentCount - 1);\r\n        }\r\n    }\r\n    _pruneComments() {\r\n        const reversedHistory = [];\r\n        const currentComments = {};\r\n        const copyComment = (fen) => {\r\n            if (fen in this._comments) {\r\n                currentComments[fen] = this._comments[fen];\r\n            }\r\n        };\r\n        while (this._history.length > 0) {\r\n            reversedHistory.push(this._undoMove());\r\n        }\r\n        copyComment(this.fen());\r\n        while (true) {\r\n            const move = reversedHistory.pop();\r\n            if (!move) {\r\n                break;\r\n            }\r\n            this._makeMove(move);\r\n            copyComment(this.fen());\r\n        }\r\n        this._comments = currentComments;\r\n    }\r\n    getComment() {\r\n        return this._comments[this.fen()];\r\n    }\r\n    setComment(comment) {\r\n        this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']');\r\n    }\r\n    /**\r\n     * @deprecated Renamed to `removeComment` for consistency\r\n     */\r\n    deleteComment() {\r\n        return this.removeComment();\r\n    }\r\n    removeComment() {\r\n        const comment = this._comments[this.fen()];\r\n        delete this._comments[this.fen()];\r\n        return comment;\r\n    }\r\n    getComments() {\r\n        this._pruneComments();\r\n        return Object.keys(this._comments).map((fen) => {\r\n            return { fen: fen, comment: this._comments[fen] };\r\n        });\r\n    }\r\n    /**\r\n     * @deprecated Renamed to `removeComments` for consistency\r\n     */\r\n    deleteComments() {\r\n        return this.removeComments();\r\n    }\r\n    removeComments() {\r\n        this._pruneComments();\r\n        return Object.keys(this._comments).map((fen) => {\r\n            const comment = this._comments[fen];\r\n            delete this._comments[fen];\r\n            return { fen: fen, comment: comment };\r\n        });\r\n    }\r\n    setCastlingRights(color, rights) {\r\n        for (const side of [exports.KING, exports.QUEEN]) {\r\n            if (rights[side] !== undefined) {\r\n                if (rights[side]) {\r\n                    this._castling[color] |= SIDES[side];\r\n                }\r\n                else {\r\n                    this._castling[color] &= ~SIDES[side];\r\n                }\r\n            }\r\n        }\r\n        this._updateCastlingRights();\r\n        const result = this.getCastlingRights(color);\r\n        return ((rights[exports.KING] === undefined || rights[exports.KING] === result[exports.KING]) &&\r\n            (rights[exports.QUEEN] === undefined || rights[exports.QUEEN] === result[exports.QUEEN]));\r\n    }\r\n    getCastlingRights(color) {\r\n        return {\r\n            [exports.KING]: (this._castling[color] & SIDES[exports.KING]) !== 0,\r\n            [exports.QUEEN]: (this._castling[color] & SIDES[exports.QUEEN]) !== 0,\r\n        };\r\n    }\r\n    moveNumber() {\r\n        return this._moveNumber;\r\n    }\r\n}\r\nexports.Chess = Chess;\r\n//# sourceMappingURL=chess.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hlc3MuanMvZGlzdC9janMvY2hlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLCtCQUErQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsR0FBRyxtQkFBbUIsR0FBRyx3QkFBd0IsR0FBRyxlQUFlLEdBQUcsWUFBWSxHQUFHLHdCQUF3QixHQUFHLFlBQVksR0FBRyxhQUFhLEdBQUcsWUFBWSxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsWUFBWSxHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsb0JBQW9CO0FBQ2hSLGNBQWMsbUJBQU8sQ0FBQyw0REFBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsZ0NBQWdDLFdBQVcscUJBQXFCLFdBQVcscUJBQXFCLGFBQWE7QUFDN0csNkJBQTZCLFdBQVc7QUFDeEMsbUNBQW1DLFlBQVk7QUFDL0M7QUFDQSxhQUFhO0FBQ2IsYUFBYTtBQUNiLFlBQVk7QUFDWixjQUFjO0FBQ2QsY0FBYztBQUNkLFlBQVk7QUFDWixhQUFhO0FBQ2IsWUFBWTtBQUNaLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBcUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUY7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwwQ0FBMEM7QUFDcEQsVUFBVSwwQ0FBMEM7QUFDcEQ7QUFDQTtBQUNBLFVBQVUsMENBQTBDO0FBQ3BELFVBQVUsMENBQTBDO0FBQ3BEO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFD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QUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGtCQUFrQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2NoZXNzLmpzL2Rpc3QvY2pzL2NoZXNzLmpzPzIzZjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjUsIEplZmYgSGx5d2EgKGpobHl3YUBnbWFpbC5jb20pXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxyXG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuICpcclxuICogMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gKiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxyXG4gKiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbiAqICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cclxuICogICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcbiAqXHJcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXHJcbiAqIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcclxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcclxuICogQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFXHJcbiAqIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcclxuICogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcclxuICogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXHJcbiAqIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXHJcbiAqIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXHJcbiAqIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXHJcbiAqIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkNoZXNzID0gZXhwb3J0cy52YWxpZGF0ZUZlbiA9IGV4cG9ydHMuU0VWRU5fVEFHX1JPU1RFUiA9IGV4cG9ydHMuU1FVQVJFUyA9IGV4cG9ydHMuTW92ZSA9IGV4cG9ydHMuREVGQVVMVF9QT1NJVElPTiA9IGV4cG9ydHMuS0lORyA9IGV4cG9ydHMuUVVFRU4gPSBleHBvcnRzLlJPT0sgPSBleHBvcnRzLkJJU0hPUCA9IGV4cG9ydHMuS05JR0hUID0gZXhwb3J0cy5QQVdOID0gZXhwb3J0cy5CTEFDSyA9IGV4cG9ydHMuV0hJVEUgPSBleHBvcnRzLnhvcm9zaGlybzEyOCA9IHZvaWQgMDtcclxuY29uc3QgcGduXzEgPSByZXF1aXJlKFwiLi9wZ25cIik7XHJcbmNvbnN0IE1BU0s2NCA9IDB4ZmZmZmZmZmZmZmZmZmZmZm47XHJcbmZ1bmN0aW9uIHJvdGwoeCwgaykge1xyXG4gICAgcmV0dXJuICgoeCA8PCBrKSB8ICh4ID4+ICg2NG4gLSBrKSkpICYgMHhmZmZmZmZmZmZmZmZmZmZmbjtcclxufVxyXG5mdW5jdGlvbiB3cmFwcGluZ011bCh4LCB5KSB7XHJcbiAgICByZXR1cm4gKHggKiB5KSAmIE1BU0s2NDtcclxufVxyXG4vLyB4b3Jvc2hpcm8xMjgqKlxyXG5mdW5jdGlvbiB4b3Jvc2hpcm8xMjgoc3RhdGUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgbGV0IHMwID0gQmlnSW50KHN0YXRlICYgTUFTSzY0KTtcclxuICAgICAgICBsZXQgczEgPSBCaWdJbnQoKHN0YXRlID4+IDY0bikgJiBNQVNLNjQpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHdyYXBwaW5nTXVsKHJvdGwod3JhcHBpbmdNdWwoczAsIDVuKSwgN24pLCA5bik7XHJcbiAgICAgICAgczEgXj0gczA7XHJcbiAgICAgICAgczAgPSAocm90bChzMCwgMjRuKSBeIHMxIF4gKHMxIDw8IDE2bikpICYgTUFTSzY0O1xyXG4gICAgICAgIHMxID0gcm90bChzMSwgMzduKTtcclxuICAgICAgICBzdGF0ZSA9IChzMSA8PCA2NG4pIHwgczA7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy54b3Jvc2hpcm8xMjggPSB4b3Jvc2hpcm8xMjg7XHJcbmNvbnN0IHJhbmQgPSB4b3Jvc2hpcm8xMjgoMHhhMTg3ZWIzOWNkY2FlZDhmMzFjNGIzNjViMTAyZTAxZW4pO1xyXG5jb25zdCBQSUVDRV9LRVlTID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMiB9LCAoKSA9PiBBcnJheS5mcm9tKHsgbGVuZ3RoOiA2IH0sICgpID0+IEFycmF5LmZyb20oeyBsZW5ndGg6IDEyOCB9LCAoKSA9PiByYW5kKCkpKSk7XHJcbmNvbnN0IEVQX0tFWVMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiA4IH0sICgpID0+IHJhbmQoKSk7XHJcbmNvbnN0IENBU1RMSU5HX0tFWVMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxNiB9LCAoKSA9PiByYW5kKCkpO1xyXG5jb25zdCBTSURFX0tFWSA9IHJhbmQoKTtcclxuZXhwb3J0cy5XSElURSA9ICd3JztcclxuZXhwb3J0cy5CTEFDSyA9ICdiJztcclxuZXhwb3J0cy5QQVdOID0gJ3AnO1xyXG5leHBvcnRzLktOSUdIVCA9ICduJztcclxuZXhwb3J0cy5CSVNIT1AgPSAnYic7XHJcbmV4cG9ydHMuUk9PSyA9ICdyJztcclxuZXhwb3J0cy5RVUVFTiA9ICdxJztcclxuZXhwb3J0cy5LSU5HID0gJ2snO1xyXG5leHBvcnRzLkRFRkFVTFRfUE9TSVRJT04gPSAncm5icWtibnIvcHBwcHBwcHAvOC84LzgvOC9QUFBQUFBQUC9STkJRS0JOUiB3IEtRa3EgLSAwIDEnO1xyXG5jbGFzcyBNb3ZlIHtcclxuICAgIGNvbG9yO1xyXG4gICAgZnJvbTtcclxuICAgIHRvO1xyXG4gICAgcGllY2U7XHJcbiAgICBjYXB0dXJlZDtcclxuICAgIHByb21vdGlvbjtcclxuICAgIC8qKlxyXG4gICAgICogQGRlcHJlY2F0ZWQgVGhpcyBmaWVsZCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdmVyc2lvbiAyLjAuMC5cclxuICAgICAqIFBsZWFzZSB1c2UgbW92ZSBkZXNjcmlwdG9yIGZ1bmN0aW9ucyBpbnN0ZWFkOiBgaXNDYXB0dXJlYCwgYGlzUHJvbW90aW9uYCxcclxuICAgICAqIGBpc0VuUGFzc2FudGAsIGBpc0tpbmdzaWRlQ2FzdGxlYCwgYGlzUXVlZW5zaWRlQ2FzdGxlYCwgYGlzQ2FzdGxlYCwgYW5kXHJcbiAgICAgKiBgaXNCaWdQYXduYFxyXG4gICAgICovXHJcbiAgICBmbGFncztcclxuICAgIHNhbjtcclxuICAgIGxhbjtcclxuICAgIGJlZm9yZTtcclxuICAgIGFmdGVyO1xyXG4gICAgY29uc3RydWN0b3IoY2hlc3MsIGludGVybmFsKSB7XHJcbiAgICAgICAgY29uc3QgeyBjb2xvciwgcGllY2UsIGZyb20sIHRvLCBmbGFncywgY2FwdHVyZWQsIHByb21vdGlvbiB9ID0gaW50ZXJuYWw7XHJcbiAgICAgICAgY29uc3QgZnJvbUFsZ2VicmFpYyA9IGFsZ2VicmFpYyhmcm9tKTtcclxuICAgICAgICBjb25zdCB0b0FsZ2VicmFpYyA9IGFsZ2VicmFpYyh0byk7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xyXG4gICAgICAgIHRoaXMucGllY2UgPSBwaWVjZTtcclxuICAgICAgICB0aGlzLmZyb20gPSBmcm9tQWxnZWJyYWljO1xyXG4gICAgICAgIHRoaXMudG8gPSB0b0FsZ2VicmFpYztcclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIEhBQ0s6IFRoZSBjaGVzc1snX21ldGhvZCddKCkgY2FsbHMgYmVsb3cgaW52b2tlIHByaXZhdGUgbWV0aG9kcyBpbiB0aGVcclxuICAgICAgICAgKiBDaGVzcyBjbGFzcyB0byBnZW5lcmF0ZSBTQU4gYW5kIEZFTi4gSXQncyBhIGJpdCBvZiBhIGhhY2ssIGJ1dCBtYWtlcyB0aGVcclxuICAgICAgICAgKiBjb2RlIGNsZWFuZXIgZWxzZXdoZXJlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc2FuID0gY2hlc3NbJ19tb3ZlVG9TYW4nXShpbnRlcm5hbCwgY2hlc3NbJ19tb3ZlcyddKHsgbGVnYWw6IHRydWUgfSkpO1xyXG4gICAgICAgIHRoaXMubGFuID0gZnJvbUFsZ2VicmFpYyArIHRvQWxnZWJyYWljO1xyXG4gICAgICAgIHRoaXMuYmVmb3JlID0gY2hlc3MuZmVuKCk7XHJcbiAgICAgICAgLy8gR2VuZXJhdGUgdGhlIEZFTiBmb3IgdGhlICdhZnRlcicga2V5XHJcbiAgICAgICAgY2hlc3NbJ19tYWtlTW92ZSddKGludGVybmFsKTtcclxuICAgICAgICB0aGlzLmFmdGVyID0gY2hlc3MuZmVuKCk7XHJcbiAgICAgICAgY2hlc3NbJ191bmRvTW92ZSddKCk7XHJcbiAgICAgICAgLy8gQnVpbGQgdGhlIHRleHQgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1vdmUgZmxhZ3NcclxuICAgICAgICB0aGlzLmZsYWdzID0gJyc7XHJcbiAgICAgICAgZm9yIChjb25zdCBmbGFnIGluIEJJVFMpIHtcclxuICAgICAgICAgICAgaWYgKEJJVFNbZmxhZ10gJiBmbGFncykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mbGFncyArPSBGTEFHU1tmbGFnXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2FwdHVyZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5jYXB0dXJlZCA9IGNhcHR1cmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJvbW90aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvbW90aW9uID0gcHJvbW90aW9uO1xyXG4gICAgICAgICAgICB0aGlzLmxhbiArPSBwcm9tb3Rpb247XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNDYXB0dXJlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdzLmluZGV4T2YoRkxBR1NbJ0NBUFRVUkUnXSkgPiAtMTtcclxuICAgIH1cclxuICAgIGlzUHJvbW90aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdzLmluZGV4T2YoRkxBR1NbJ1BST01PVElPTiddKSA+IC0xO1xyXG4gICAgfVxyXG4gICAgaXNFblBhc3NhbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ3MuaW5kZXhPZihGTEFHU1snRVBfQ0FQVFVSRSddKSA+IC0xO1xyXG4gICAgfVxyXG4gICAgaXNLaW5nc2lkZUNhc3RsZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mbGFncy5pbmRleE9mKEZMQUdTWydLU0lERV9DQVNUTEUnXSkgPiAtMTtcclxuICAgIH1cclxuICAgIGlzUXVlZW5zaWRlQ2FzdGxlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdzLmluZGV4T2YoRkxBR1NbJ1FTSURFX0NBU1RMRSddKSA+IC0xO1xyXG4gICAgfVxyXG4gICAgaXNCaWdQYXduKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdzLmluZGV4T2YoRkxBR1NbJ0JJR19QQVdOJ10pID4gLTE7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5Nb3ZlID0gTW92ZTtcclxuY29uc3QgRU1QVFkgPSAtMTtcclxuY29uc3QgRkxBR1MgPSB7XHJcbiAgICBOT1JNQUw6ICduJyxcclxuICAgIENBUFRVUkU6ICdjJyxcclxuICAgIEJJR19QQVdOOiAnYicsXHJcbiAgICBFUF9DQVBUVVJFOiAnZScsXHJcbiAgICBQUk9NT1RJT046ICdwJyxcclxuICAgIEtTSURFX0NBU1RMRTogJ2snLFxyXG4gICAgUVNJREVfQ0FTVExFOiAncScsXHJcbn07XHJcbi8vIHByZXR0aWVyLWlnbm9yZVxyXG5leHBvcnRzLlNRVUFSRVMgPSBbXHJcbiAgICAnYTgnLCAnYjgnLCAnYzgnLCAnZDgnLCAnZTgnLCAnZjgnLCAnZzgnLCAnaDgnLFxyXG4gICAgJ2E3JywgJ2I3JywgJ2M3JywgJ2Q3JywgJ2U3JywgJ2Y3JywgJ2c3JywgJ2g3JyxcclxuICAgICdhNicsICdiNicsICdjNicsICdkNicsICdlNicsICdmNicsICdnNicsICdoNicsXHJcbiAgICAnYTUnLCAnYjUnLCAnYzUnLCAnZDUnLCAnZTUnLCAnZjUnLCAnZzUnLCAnaDUnLFxyXG4gICAgJ2E0JywgJ2I0JywgJ2M0JywgJ2Q0JywgJ2U0JywgJ2Y0JywgJ2c0JywgJ2g0JyxcclxuICAgICdhMycsICdiMycsICdjMycsICdkMycsICdlMycsICdmMycsICdnMycsICdoMycsXHJcbiAgICAnYTInLCAnYjInLCAnYzInLCAnZDInLCAnZTInLCAnZjInLCAnZzInLCAnaDInLFxyXG4gICAgJ2ExJywgJ2IxJywgJ2MxJywgJ2QxJywgJ2UxJywgJ2YxJywgJ2cxJywgJ2gxJ1xyXG5dO1xyXG5jb25zdCBCSVRTID0ge1xyXG4gICAgTk9STUFMOiAxLFxyXG4gICAgQ0FQVFVSRTogMixcclxuICAgIEJJR19QQVdOOiA0LFxyXG4gICAgRVBfQ0FQVFVSRTogOCxcclxuICAgIFBST01PVElPTjogMTYsXHJcbiAgICBLU0lERV9DQVNUTEU6IDMyLFxyXG4gICAgUVNJREVfQ0FTVExFOiA2NCxcclxufTtcclxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uICovXHJcbi8vIHRoZXNlIGFyZSByZXF1aXJlZCwgYWNjb3JkaW5nIHRvIHNwZWNcclxuZXhwb3J0cy5TRVZFTl9UQUdfUk9TVEVSID0ge1xyXG4gICAgRXZlbnQ6ICc/JyxcclxuICAgIFNpdGU6ICc/JyxcclxuICAgIERhdGU6ICc/Pz8/Lj8/Lj8/JyxcclxuICAgIFJvdW5kOiAnPycsXHJcbiAgICBXaGl0ZTogJz8nLFxyXG4gICAgQmxhY2s6ICc/JyxcclxuICAgIFJlc3VsdDogJyonLFxyXG59O1xyXG4vKipcclxuICogVGhlc2UgbnVsbHMgYXJlIHBsYWNlaG9sZGVycyB0byBmaXggdGhlIG9yZGVyIG9mIHRhZ3MgKGFzIHRoZXkgYXBwZWFyIGluIFBHTiBzcGVjKTsgbnVsbCB2YWx1ZXMgd2lsbCBiZVxyXG4gKiBlbGltaW5hdGVkIGluIGdldEhlYWRlcnMoKVxyXG4gKi9cclxuY29uc3QgU1VQTEVNRU5UQUxfVEFHUyA9IHtcclxuICAgIFdoaXRlVGl0bGU6IG51bGwsXHJcbiAgICBCbGFja1RpdGxlOiBudWxsLFxyXG4gICAgV2hpdGVFbG86IG51bGwsXHJcbiAgICBCbGFja0VsbzogbnVsbCxcclxuICAgIFdoaXRlVVNDRjogbnVsbCxcclxuICAgIEJsYWNrVVNDRjogbnVsbCxcclxuICAgIFdoaXRlTkE6IG51bGwsXHJcbiAgICBCbGFja05BOiBudWxsLFxyXG4gICAgV2hpdGVUeXBlOiBudWxsLFxyXG4gICAgQmxhY2tUeXBlOiBudWxsLFxyXG4gICAgRXZlbnREYXRlOiBudWxsLFxyXG4gICAgRXZlbnRTcG9uc29yOiBudWxsLFxyXG4gICAgU2VjdGlvbjogbnVsbCxcclxuICAgIFN0YWdlOiBudWxsLFxyXG4gICAgQm9hcmQ6IG51bGwsXHJcbiAgICBPcGVuaW5nOiBudWxsLFxyXG4gICAgVmFyaWF0aW9uOiBudWxsLFxyXG4gICAgU3ViVmFyaWF0aW9uOiBudWxsLFxyXG4gICAgRUNPOiBudWxsLFxyXG4gICAgTklDOiBudWxsLFxyXG4gICAgVGltZTogbnVsbCxcclxuICAgIFVUQ1RpbWU6IG51bGwsXHJcbiAgICBVVENEYXRlOiBudWxsLFxyXG4gICAgVGltZUNvbnRyb2w6IG51bGwsXHJcbiAgICBTZXRVcDogbnVsbCxcclxuICAgIEZFTjogbnVsbCxcclxuICAgIFRlcm1pbmF0aW9uOiBudWxsLFxyXG4gICAgQW5ub3RhdG9yOiBudWxsLFxyXG4gICAgTW9kZTogbnVsbCxcclxuICAgIFBseUNvdW50OiBudWxsLFxyXG59O1xyXG5jb25zdCBIRUFERVJfVEVNUExBVEUgPSB7XHJcbiAgICAuLi5leHBvcnRzLlNFVkVOX1RBR19ST1NURVIsXHJcbiAgICAuLi5TVVBMRU1FTlRBTF9UQUdTLFxyXG59O1xyXG4vKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAqL1xyXG4vKlxyXG4gKiBOT1RFUyBBQk9VVCAweDg4IE1PVkUgR0VORVJBVElPTiBBTEdPUklUSE1cclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9qaGx5d2EvY2hlc3MuanMvaXNzdWVzLzIzMFxyXG4gKlxyXG4gKiBBIGxvdCBvZiBwZW9wbGUgYXJlIGNvbmZ1c2VkIHdoZW4gdGhleSBmaXJzdCBzZWUgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uXHJcbiAqIG9mIGNoZXNzLmpzLiBJdCB1c2VzIHRoZSAweDg4IE1vdmUgR2VuZXJhdGlvbiBBbGdvcml0aG0gd2hpY2ggaW50ZXJuYWxseVxyXG4gKiBzdG9yZXMgdGhlIGJvYXJkIGFzIGFuIDh4MTYgYXJyYXkuIFRoaXMgaXMgcHVyZWx5IGZvciBlZmZpY2llbmN5IGJ1dCBoYXMgYVxyXG4gKiBjb3VwbGUgb2YgaW50ZXJlc3RpbmcgYmVuZWZpdHM6XHJcbiAqXHJcbiAqIDEuIDB4ODggb2ZmZXJzIGEgdmVyeSBpbmV4cGVuc2l2ZSBcIm9mZiB0aGUgYm9hcmRcIiBjaGVjay4gQml0d2lzZSBBTkQgKCYpIGFueVxyXG4gKiAgICBzcXVhcmUgd2l0aCAweDg4LCBpZiB0aGUgcmVzdWx0IGlzIG5vbi16ZXJvIHRoZW4gdGhlIHNxdWFyZSBpcyBvZmYgdGhlXHJcbiAqICAgIGJvYXJkLiBGb3IgZXhhbXBsZSwgYXNzdW1pbmcgYSBrbmlnaHQgc3F1YXJlIEE4ICgwIGluIDB4ODggbm90YXRpb24pLFxyXG4gKiAgICB0aGVyZSBhcmUgOCBwb3NzaWJsZSBkaXJlY3Rpb25zIGluIHdoaWNoIHRoZSBrbmlnaHQgY2FuIG1vdmUuIFRoZXNlXHJcbiAqICAgIGRpcmVjdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoZSA4eDE2IGJvYXJkIGFuZCBhcmUgc3RvcmVkIGluIHRoZVxyXG4gKiAgICBQSUVDRV9PRkZTRVRTIG1hcC4gT25lIHBvc3NpYmxlIG1vdmUgaXMgQTggLSAxOCAodXAgb25lIHNxdWFyZSwgYW5kIHR3b1xyXG4gKiAgICBzcXVhcmVzIHRvIHRoZSBsZWZ0IC0gd2hpY2ggaXMgb2ZmIHRoZSBib2FyZCkuIDAgLSAxOCA9IC0xOCAmIDB4ODggPSAweDg4XHJcbiAqICAgIChiZWNhdXNlIG9mIHR3by1jb21wbGVtZW50IHJlcHJlc2VudGF0aW9uIG9mIC0xOCkuIFRoZSBub24temVybyByZXN1bHRcclxuICogICAgbWVhbnMgdGhlIHNxdWFyZSBpcyBvZmYgdGhlIGJvYXJkIGFuZCB0aGUgbW92ZSBpcyBpbGxlZ2FsLiBUYWtlIHRoZVxyXG4gKiAgICBvcHBvc2l0ZSBtb3ZlIChmcm9tIEE4IHRvIEM3KSwgMCArIDE4ID0gMTggJiAweDg4ID0gMC4gQSByZXN1bHQgb2YgemVyb1xyXG4gKiAgICBtZWFucyB0aGUgc3F1YXJlIGlzIG9uIHRoZSBib2FyZC5cclxuICpcclxuICogMi4gVGhlIHJlbGF0aXZlIGRpc3RhbmNlIChvciBkaWZmZXJlbmNlKSBiZXR3ZWVuIHR3byBzcXVhcmVzIG9uIGEgOHgxNiBib2FyZFxyXG4gKiAgICBpcyB1bmlxdWUgYW5kIGNhbiBiZSB1c2VkIHRvIGluZXhwZW5zaXZlbHkgZGV0ZXJtaW5lIGlmIGEgcGllY2Ugb24gYVxyXG4gKiAgICBzcXVhcmUgY2FuIGF0dGFjayBhbnkgb3RoZXIgYXJiaXRyYXJ5IHNxdWFyZS4gRm9yIGV4YW1wbGUsIGxldCdzIHNlZSBpZiBhXHJcbiAqICAgIHBhd24gb24gRTcgY2FuIGF0dGFjayBFMi4gVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBFNyAoMjApIC0gRTIgKDEwMCkgaXNcclxuICogICAgLTgwLiBXZSBhZGQgMTE5IHRvIG1ha2UgdGhlIEFUVEFDS1MgYXJyYXkgaW5kZXggbm9uLW5lZ2F0aXZlIChiZWNhdXNlIHRoZVxyXG4gKiAgICB3b3JzdCBjYXNlIGRpZmZlcmVuY2UgaXMgQTggLSBIMSA9IC0xMTkpLiBUaGUgQVRUQUNLUyBhcnJheSBjb250YWlucyBhXHJcbiAqICAgIGJpdG1hc2sgb2YgcGllY2VzIHRoYXQgY2FuIGF0dGFjayBmcm9tIHRoYXQgZGlzdGFuY2UgYW5kIGRpcmVjdGlvbi5cclxuICogICAgQVRUQUNLU1stODAgKyAxMTk9MzldIGdpdmVzIHVzIDI0IG9yIDBiMTEwMDAgaW4gYmluYXJ5LiBMb29rIGF0IHRoZVxyXG4gKiAgICBQSUVDRV9NQVNLUyBtYXAgdG8gZGV0ZXJtaW5lIHRoZSBtYXNrIGZvciBhIGdpdmVuIHBpZWNlIHR5cGUuIEluIG91ciBwYXduXHJcbiAqICAgIGV4YW1wbGUsIHdlIHdvdWxkIGNoZWNrIHRvIHNlZSBpZiAyNCAmIDB4MSBpcyBub24temVybywgd2hpY2ggaXQgaXNcclxuICogICAgbm90LiBTbywgbmF0dXJhbGx5LCBhIHBhd24gb24gRTcgY2FuJ3QgYXR0YWNrIGEgcGllY2Ugb24gRTIuIEhvd2V2ZXIsIGFcclxuICogICAgcm9vayBjYW4gc2luY2UgMjQgJiAweDggaXMgbm9uLXplcm8uIFRoZSBvbmx5IHRoaW5nIGxlZnQgdG8gY2hlY2sgaXMgdGhhdFxyXG4gKiAgICB0aGVyZSBhcmUgbm8gYmxvY2tpbmcgcGllY2VzIGJldHdlZW4gRTcgYW5kIEUyLiBUaGF0J3Mgd2hlcmUgdGhlIFJBWVNcclxuICogICAgYXJyYXkgY29tZXMgaW4uIEl0IHByb3ZpZGVzIGFuIG9mZnNldCAoaW4gdGhpcyBjYXNlIDE2KSB0byBhZGQgdG8gRTcgKDIwKVxyXG4gKiAgICB0byBjaGVjayBmb3IgYmxvY2tpbmcgcGllY2VzLiBFNyAoMjApICsgMTYgPSBFNiAoMzYpICsgMTYgPSBFNSAoNTIpIGV0Yy5cclxuICovXHJcbi8vIHByZXR0aWVyLWlnbm9yZVxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuY29uc3QgT3g4OCA9IHtcclxuICAgIGE4OiAwLCBiODogMSwgYzg6IDIsIGQ4OiAzLCBlODogNCwgZjg6IDUsIGc4OiA2LCBoODogNyxcclxuICAgIGE3OiAxNiwgYjc6IDE3LCBjNzogMTgsIGQ3OiAxOSwgZTc6IDIwLCBmNzogMjEsIGc3OiAyMiwgaDc6IDIzLFxyXG4gICAgYTY6IDMyLCBiNjogMzMsIGM2OiAzNCwgZDY6IDM1LCBlNjogMzYsIGY2OiAzNywgZzY6IDM4LCBoNjogMzksXHJcbiAgICBhNTogNDgsIGI1OiA0OSwgYzU6IDUwLCBkNTogNTEsIGU1OiA1MiwgZjU6IDUzLCBnNTogNTQsIGg1OiA1NSxcclxuICAgIGE0OiA2NCwgYjQ6IDY1LCBjNDogNjYsIGQ0OiA2NywgZTQ6IDY4LCBmNDogNjksIGc0OiA3MCwgaDQ6IDcxLFxyXG4gICAgYTM6IDgwLCBiMzogODEsIGMzOiA4MiwgZDM6IDgzLCBlMzogODQsIGYzOiA4NSwgZzM6IDg2LCBoMzogODcsXHJcbiAgICBhMjogOTYsIGIyOiA5NywgYzI6IDk4LCBkMjogOTksIGUyOiAxMDAsIGYyOiAxMDEsIGcyOiAxMDIsIGgyOiAxMDMsXHJcbiAgICBhMTogMTEyLCBiMTogMTEzLCBjMTogMTE0LCBkMTogMTE1LCBlMTogMTE2LCBmMTogMTE3LCBnMTogMTE4LCBoMTogMTE5XHJcbn07XHJcbmNvbnN0IFBBV05fT0ZGU0VUUyA9IHtcclxuICAgIGI6IFsxNiwgMzIsIDE3LCAxNV0sXHJcbiAgICB3OiBbLTE2LCAtMzIsIC0xNywgLTE1XSxcclxufTtcclxuY29uc3QgUElFQ0VfT0ZGU0VUUyA9IHtcclxuICAgIG46IFstMTgsIC0zMywgLTMxLCAtMTQsIDE4LCAzMywgMzEsIDE0XSxcclxuICAgIGI6IFstMTcsIC0xNSwgMTcsIDE1XSxcclxuICAgIHI6IFstMTYsIDEsIDE2LCAtMV0sXHJcbiAgICBxOiBbLTE3LCAtMTYsIC0xNSwgMSwgMTcsIDE2LCAxNSwgLTFdLFxyXG4gICAgazogWy0xNywgLTE2LCAtMTUsIDEsIDE3LCAxNiwgMTUsIC0xXSxcclxufTtcclxuLy8gcHJldHRpZXItaWdub3JlXHJcbmNvbnN0IEFUVEFDS1MgPSBbXHJcbiAgICAyMCwgMCwgMCwgMCwgMCwgMCwgMCwgMjQsIDAsIDAsIDAsIDAsIDAsIDAsIDIwLCAwLFxyXG4gICAgMCwgMjAsIDAsIDAsIDAsIDAsIDAsIDI0LCAwLCAwLCAwLCAwLCAwLCAyMCwgMCwgMCxcclxuICAgIDAsIDAsIDIwLCAwLCAwLCAwLCAwLCAyNCwgMCwgMCwgMCwgMCwgMjAsIDAsIDAsIDAsXHJcbiAgICAwLCAwLCAwLCAyMCwgMCwgMCwgMCwgMjQsIDAsIDAsIDAsIDIwLCAwLCAwLCAwLCAwLFxyXG4gICAgMCwgMCwgMCwgMCwgMjAsIDAsIDAsIDI0LCAwLCAwLCAyMCwgMCwgMCwgMCwgMCwgMCxcclxuICAgIDAsIDAsIDAsIDAsIDAsIDIwLCAyLCAyNCwgMiwgMjAsIDAsIDAsIDAsIDAsIDAsIDAsXHJcbiAgICAwLCAwLCAwLCAwLCAwLCAyLCA1MywgNTYsIDUzLCAyLCAwLCAwLCAwLCAwLCAwLCAwLFxyXG4gICAgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgNTYsIDAsIDU2LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAwLFxyXG4gICAgMCwgMCwgMCwgMCwgMCwgMiwgNTMsIDU2LCA1MywgMiwgMCwgMCwgMCwgMCwgMCwgMCxcclxuICAgIDAsIDAsIDAsIDAsIDAsIDIwLCAyLCAyNCwgMiwgMjAsIDAsIDAsIDAsIDAsIDAsIDAsXHJcbiAgICAwLCAwLCAwLCAwLCAyMCwgMCwgMCwgMjQsIDAsIDAsIDIwLCAwLCAwLCAwLCAwLCAwLFxyXG4gICAgMCwgMCwgMCwgMjAsIDAsIDAsIDAsIDI0LCAwLCAwLCAwLCAyMCwgMCwgMCwgMCwgMCxcclxuICAgIDAsIDAsIDIwLCAwLCAwLCAwLCAwLCAyNCwgMCwgMCwgMCwgMCwgMjAsIDAsIDAsIDAsXHJcbiAgICAwLCAyMCwgMCwgMCwgMCwgMCwgMCwgMjQsIDAsIDAsIDAsIDAsIDAsIDIwLCAwLCAwLFxyXG4gICAgMjAsIDAsIDAsIDAsIDAsIDAsIDAsIDI0LCAwLCAwLCAwLCAwLCAwLCAwLCAyMFxyXG5dO1xyXG4vLyBwcmV0dGllci1pZ25vcmVcclxuY29uc3QgUkFZUyA9IFtcclxuICAgIDE3LCAwLCAwLCAwLCAwLCAwLCAwLCAxNiwgMCwgMCwgMCwgMCwgMCwgMCwgMTUsIDAsXHJcbiAgICAwLCAxNywgMCwgMCwgMCwgMCwgMCwgMTYsIDAsIDAsIDAsIDAsIDAsIDE1LCAwLCAwLFxyXG4gICAgMCwgMCwgMTcsIDAsIDAsIDAsIDAsIDE2LCAwLCAwLCAwLCAwLCAxNSwgMCwgMCwgMCxcclxuICAgIDAsIDAsIDAsIDE3LCAwLCAwLCAwLCAxNiwgMCwgMCwgMCwgMTUsIDAsIDAsIDAsIDAsXHJcbiAgICAwLCAwLCAwLCAwLCAxNywgMCwgMCwgMTYsIDAsIDAsIDE1LCAwLCAwLCAwLCAwLCAwLFxyXG4gICAgMCwgMCwgMCwgMCwgMCwgMTcsIDAsIDE2LCAwLCAxNSwgMCwgMCwgMCwgMCwgMCwgMCxcclxuICAgIDAsIDAsIDAsIDAsIDAsIDAsIDE3LCAxNiwgMTUsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXHJcbiAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgMCxcclxuICAgIDAsIDAsIDAsIDAsIDAsIDAsIC0xNSwgLTE2LCAtMTcsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXHJcbiAgICAwLCAwLCAwLCAwLCAwLCAtMTUsIDAsIC0xNiwgMCwgLTE3LCAwLCAwLCAwLCAwLCAwLCAwLFxyXG4gICAgMCwgMCwgMCwgMCwgLTE1LCAwLCAwLCAtMTYsIDAsIDAsIC0xNywgMCwgMCwgMCwgMCwgMCxcclxuICAgIDAsIDAsIDAsIC0xNSwgMCwgMCwgMCwgLTE2LCAwLCAwLCAwLCAtMTcsIDAsIDAsIDAsIDAsXHJcbiAgICAwLCAwLCAtMTUsIDAsIDAsIDAsIDAsIC0xNiwgMCwgMCwgMCwgMCwgLTE3LCAwLCAwLCAwLFxyXG4gICAgMCwgLTE1LCAwLCAwLCAwLCAwLCAwLCAtMTYsIDAsIDAsIDAsIDAsIDAsIC0xNywgMCwgMCxcclxuICAgIC0xNSwgMCwgMCwgMCwgMCwgMCwgMCwgLTE2LCAwLCAwLCAwLCAwLCAwLCAwLCAtMTdcclxuXTtcclxuY29uc3QgUElFQ0VfTUFTS1MgPSB7IHA6IDB4MSwgbjogMHgyLCBiOiAweDQsIHI6IDB4OCwgcTogMHgxMCwgazogMHgyMCB9O1xyXG5jb25zdCBTWU1CT0xTID0gJ3BuYnJxa1BOQlJRSyc7XHJcbmNvbnN0IFBST01PVElPTlMgPSBbZXhwb3J0cy5LTklHSFQsIGV4cG9ydHMuQklTSE9QLCBleHBvcnRzLlJPT0ssIGV4cG9ydHMuUVVFRU5dO1xyXG5jb25zdCBSQU5LXzEgPSA3O1xyXG5jb25zdCBSQU5LXzIgPSA2O1xyXG4vKlxyXG4gKiBjb25zdCBSQU5LXzMgPSA1XHJcbiAqIGNvbnN0IFJBTktfNCA9IDRcclxuICogY29uc3QgUkFOS181ID0gM1xyXG4gKiBjb25zdCBSQU5LXzYgPSAyXHJcbiAqL1xyXG5jb25zdCBSQU5LXzcgPSAxO1xyXG5jb25zdCBSQU5LXzggPSAwO1xyXG5jb25zdCBTSURFUyA9IHtcclxuICAgIFtleHBvcnRzLktJTkddOiBCSVRTLktTSURFX0NBU1RMRSxcclxuICAgIFtleHBvcnRzLlFVRUVOXTogQklUUy5RU0lERV9DQVNUTEUsXHJcbn07XHJcbmNvbnN0IFJPT0tTID0ge1xyXG4gICAgdzogW1xyXG4gICAgICAgIHsgc3F1YXJlOiBPeDg4LmExLCBmbGFnOiBCSVRTLlFTSURFX0NBU1RMRSB9LFxyXG4gICAgICAgIHsgc3F1YXJlOiBPeDg4LmgxLCBmbGFnOiBCSVRTLktTSURFX0NBU1RMRSB9LFxyXG4gICAgXSxcclxuICAgIGI6IFtcclxuICAgICAgICB7IHNxdWFyZTogT3g4OC5hOCwgZmxhZzogQklUUy5RU0lERV9DQVNUTEUgfSxcclxuICAgICAgICB7IHNxdWFyZTogT3g4OC5oOCwgZmxhZzogQklUUy5LU0lERV9DQVNUTEUgfSxcclxuICAgIF0sXHJcbn07XHJcbmNvbnN0IFNFQ09ORF9SQU5LID0geyBiOiBSQU5LXzcsIHc6IFJBTktfMiB9O1xyXG4vLyBFeHRyYWN0cyB0aGUgemVyby1iYXNlZCByYW5rIG9mIGFuIDB4ODggc3F1YXJlLlxyXG5mdW5jdGlvbiByYW5rKHNxdWFyZSkge1xyXG4gICAgcmV0dXJuIHNxdWFyZSA+PiA0O1xyXG59XHJcbi8vIEV4dHJhY3RzIHRoZSB6ZXJvLWJhc2VkIGZpbGUgb2YgYW4gMHg4OCBzcXVhcmUuXHJcbmZ1bmN0aW9uIGZpbGUoc3F1YXJlKSB7XHJcbiAgICByZXR1cm4gc3F1YXJlICYgMHhmO1xyXG59XHJcbmZ1bmN0aW9uIGlzRGlnaXQoYykge1xyXG4gICAgcmV0dXJuICcwMTIzNDU2Nzg5Jy5pbmRleE9mKGMpICE9PSAtMTtcclxufVxyXG4vLyBDb252ZXJ0cyBhIDB4ODggc3F1YXJlIHRvIGFsZ2VicmFpYyBub3RhdGlvbi5cclxuZnVuY3Rpb24gYWxnZWJyYWljKHNxdWFyZSkge1xyXG4gICAgY29uc3QgZiA9IGZpbGUoc3F1YXJlKTtcclxuICAgIGNvbnN0IHIgPSByYW5rKHNxdWFyZSk7XHJcbiAgICByZXR1cm4gKCdhYmNkZWZnaCcuc3Vic3RyaW5nKGYsIGYgKyAxKSArXHJcbiAgICAgICAgJzg3NjU0MzIxJy5zdWJzdHJpbmcociwgciArIDEpKTtcclxufVxyXG5mdW5jdGlvbiBzd2FwQ29sb3IoY29sb3IpIHtcclxuICAgIHJldHVybiBjb2xvciA9PT0gZXhwb3J0cy5XSElURSA/IGV4cG9ydHMuQkxBQ0sgOiBleHBvcnRzLldISVRFO1xyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlRmVuKGZlbikge1xyXG4gICAgLy8gMXN0IGNyaXRlcmlvbjogNiBzcGFjZS1zZXBlcmF0ZWQgZmllbGRzP1xyXG4gICAgY29uc3QgdG9rZW5zID0gZmVuLnNwbGl0KC9cXHMrLyk7XHJcbiAgICBpZiAodG9rZW5zLmxlbmd0aCAhPT0gNikge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG9rOiBmYWxzZSxcclxuICAgICAgICAgICAgZXJyb3I6ICdJbnZhbGlkIEZFTjogbXVzdCBjb250YWluIHNpeCBzcGFjZS1kZWxpbWl0ZWQgZmllbGRzJyxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLy8gMm5kIGNyaXRlcmlvbjogbW92ZSBudW1iZXIgZmllbGQgaXMgYSBpbnRlZ2VyIHZhbHVlID4gMD9cclxuICAgIGNvbnN0IG1vdmVOdW1iZXIgPSBwYXJzZUludCh0b2tlbnNbNV0sIDEwKTtcclxuICAgIGlmIChpc05hTihtb3ZlTnVtYmVyKSB8fCBtb3ZlTnVtYmVyIDw9IDApIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBvazogZmFsc2UsXHJcbiAgICAgICAgICAgIGVycm9yOiAnSW52YWxpZCBGRU46IG1vdmUgbnVtYmVyIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLy8gM3JkIGNyaXRlcmlvbjogaGFsZiBtb3ZlIGNvdW50ZXIgaXMgYW4gaW50ZWdlciA+PSAwP1xyXG4gICAgY29uc3QgaGFsZk1vdmVzID0gcGFyc2VJbnQodG9rZW5zWzRdLCAxMCk7XHJcbiAgICBpZiAoaXNOYU4oaGFsZk1vdmVzKSB8fCBoYWxmTW92ZXMgPCAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgb2s6IGZhbHNlLFxyXG4gICAgICAgICAgICBlcnJvcjogJ0ludmFsaWQgRkVOOiBoYWxmIG1vdmUgY291bnRlciBudW1iZXIgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyJyxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLy8gNHRoIGNyaXRlcmlvbjogNHRoIGZpZWxkIGlzIGEgdmFsaWQgZS5wLi1zdHJpbmc/XHJcbiAgICBpZiAoIS9eKC18W2FiY2RlZmdoXVszNl0pJC8udGVzdCh0b2tlbnNbM10pKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ0ludmFsaWQgRkVOOiBlbi1wYXNzYW50IHNxdWFyZSBpcyBpbnZhbGlkJyB9O1xyXG4gICAgfVxyXG4gICAgLy8gNXRoIGNyaXRlcmlvbjogM3RoIGZpZWxkIGlzIGEgdmFsaWQgY2FzdGxlLXN0cmluZz9cclxuICAgIGlmICgvW15rS3FRLV0vLnRlc3QodG9rZW5zWzJdKSkge1xyXG4gICAgICAgIHJldHVybiB7IG9rOiBmYWxzZSwgZXJyb3I6ICdJbnZhbGlkIEZFTjogY2FzdGxpbmcgYXZhaWxhYmlsaXR5IGlzIGludmFsaWQnIH07XHJcbiAgICB9XHJcbiAgICAvLyA2dGggY3JpdGVyaW9uOiAybmQgZmllbGQgaXMgXCJ3XCIgKHdoaXRlKSBvciBcImJcIiAoYmxhY2spP1xyXG4gICAgaWYgKCEvXih3fGIpJC8udGVzdCh0b2tlbnNbMV0pKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ0ludmFsaWQgRkVOOiBzaWRlLXRvLW1vdmUgaXMgaW52YWxpZCcgfTtcclxuICAgIH1cclxuICAgIC8vIDd0aCBjcml0ZXJpb246IDFzdCBmaWVsZCBjb250YWlucyA4IHJvd3M/XHJcbiAgICBjb25zdCByb3dzID0gdG9rZW5zWzBdLnNwbGl0KCcvJyk7XHJcbiAgICBpZiAocm93cy5sZW5ndGggIT09IDgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBvazogZmFsc2UsXHJcbiAgICAgICAgICAgIGVycm9yOiBcIkludmFsaWQgRkVOOiBwaWVjZSBkYXRhIGRvZXMgbm90IGNvbnRhaW4gOCAnLyctZGVsaW1pdGVkIHJvd3NcIixcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLy8gOHRoIGNyaXRlcmlvbjogZXZlcnkgcm93IGlzIHZhbGlkP1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgLy8gY2hlY2sgZm9yIHJpZ2h0IHN1bSBvZiBmaWVsZHMgQU5EIG5vdCB0d28gbnVtYmVycyBpbiBzdWNjZXNzaW9uXHJcbiAgICAgICAgbGV0IHN1bUZpZWxkcyA9IDA7XHJcbiAgICAgICAgbGV0IHByZXZpb3VzV2FzTnVtYmVyID0gZmFsc2U7XHJcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCByb3dzW2ldLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0RpZ2l0KHJvd3NbaV1ba10pKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNXYXNOdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvazogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiAnSW52YWxpZCBGRU46IHBpZWNlIGRhdGEgaXMgaW52YWxpZCAoY29uc2VjdXRpdmUgbnVtYmVyKScsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN1bUZpZWxkcyArPSBwYXJzZUludChyb3dzW2ldW2tdLCAxMCk7XHJcbiAgICAgICAgICAgICAgICBwcmV2aW91c1dhc051bWJlciA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIS9eW3BybmJxa1BSTkJRS10kLy50ZXN0KHJvd3NbaV1ba10pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2s6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogJ0ludmFsaWQgRkVOOiBwaWVjZSBkYXRhIGlzIGludmFsaWQgKGludmFsaWQgcGllY2UpJyxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3VtRmllbGRzICs9IDE7XHJcbiAgICAgICAgICAgICAgICBwcmV2aW91c1dhc051bWJlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdW1GaWVsZHMgIT09IDgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIG9rOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGVycm9yOiAnSW52YWxpZCBGRU46IHBpZWNlIGRhdGEgaXMgaW52YWxpZCAodG9vIG1hbnkgc3F1YXJlcyBpbiByYW5rKScsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gOXRoIGNyaXRlcmlvbjogaXMgZW4tcGFzc2FudCBzcXVhcmUgbGVnYWw/XHJcbiAgICBpZiAoKHRva2Vuc1szXVsxXSA9PSAnMycgJiYgdG9rZW5zWzFdID09ICd3JykgfHxcclxuICAgICAgICAodG9rZW5zWzNdWzFdID09ICc2JyAmJiB0b2tlbnNbMV0gPT0gJ2InKSkge1xyXG4gICAgICAgIHJldHVybiB7IG9rOiBmYWxzZSwgZXJyb3I6ICdJbnZhbGlkIEZFTjogaWxsZWdhbCBlbi1wYXNzYW50IHNxdWFyZScgfTtcclxuICAgIH1cclxuICAgIC8vIDEwdGggY3JpdGVyaW9uOiBkb2VzIGNoZXNzIHBvc2l0aW9uIGNvbnRhaW4gZXhhY3QgdHdvIGtpbmdzP1xyXG4gICAgY29uc3Qga2luZ3MgPSBbXHJcbiAgICAgICAgeyBjb2xvcjogJ3doaXRlJywgcmVnZXg6IC9LL2cgfSxcclxuICAgICAgICB7IGNvbG9yOiAnYmxhY2snLCByZWdleDogL2svZyB9LFxyXG4gICAgXTtcclxuICAgIGZvciAoY29uc3QgeyBjb2xvciwgcmVnZXggfSBvZiBraW5ncykge1xyXG4gICAgICAgIGlmICghcmVnZXgudGVzdCh0b2tlbnNbMF0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IG9rOiBmYWxzZSwgZXJyb3I6IGBJbnZhbGlkIEZFTjogbWlzc2luZyAke2NvbG9yfSBraW5nYCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHRva2Vuc1swXS5tYXRjaChyZWdleCkgfHwgW10pLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogYEludmFsaWQgRkVOOiB0b28gbWFueSAke2NvbG9yfSBraW5nc2AgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyAxMXRoIGNyaXRlcmlvbjogYXJlIGFueSBwYXducyBvbiB0aGUgZmlyc3Qgb3IgZWlnaHRoIHJvd3M/XHJcbiAgICBpZiAoQXJyYXkuZnJvbShyb3dzWzBdICsgcm93c1s3XSkuc29tZSgoY2hhcikgPT4gY2hhci50b1VwcGVyQ2FzZSgpID09PSAnUCcpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgb2s6IGZhbHNlLFxyXG4gICAgICAgICAgICBlcnJvcjogJ0ludmFsaWQgRkVOOiBzb21lIHBhd25zIGFyZSBvbiB0aGUgZWRnZSByb3dzJyxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgb2s6IHRydWUgfTtcclxufVxyXG5leHBvcnRzLnZhbGlkYXRlRmVuID0gdmFsaWRhdGVGZW47XHJcbi8vIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byB1bmlxdWVseSBpZGVudGlmeSBhbWJpZ3VvdXMgbW92ZXNcclxuZnVuY3Rpb24gZ2V0RGlzYW1iaWd1YXRvcihtb3ZlLCBtb3Zlcykge1xyXG4gICAgY29uc3QgZnJvbSA9IG1vdmUuZnJvbTtcclxuICAgIGNvbnN0IHRvID0gbW92ZS50bztcclxuICAgIGNvbnN0IHBpZWNlID0gbW92ZS5waWVjZTtcclxuICAgIGxldCBhbWJpZ3VpdGllcyA9IDA7XHJcbiAgICBsZXQgc2FtZVJhbmsgPSAwO1xyXG4gICAgbGV0IHNhbWVGaWxlID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBtb3Zlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGFtYmlnRnJvbSA9IG1vdmVzW2ldLmZyb207XHJcbiAgICAgICAgY29uc3QgYW1iaWdUbyA9IG1vdmVzW2ldLnRvO1xyXG4gICAgICAgIGNvbnN0IGFtYmlnUGllY2UgPSBtb3Zlc1tpXS5waWVjZTtcclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIGlmIGEgbW92ZSBvZiB0aGUgc2FtZSBwaWVjZSB0eXBlIGVuZHMgb24gdGhlIHNhbWUgdG8gc3F1YXJlLCB3ZSdsbCBuZWVkXHJcbiAgICAgICAgICogdG8gYWRkIGEgZGlzYW1iaWd1YXRvciB0byB0aGUgYWxnZWJyYWljIG5vdGF0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaWYgKHBpZWNlID09PSBhbWJpZ1BpZWNlICYmIGZyb20gIT09IGFtYmlnRnJvbSAmJiB0byA9PT0gYW1iaWdUbykge1xyXG4gICAgICAgICAgICBhbWJpZ3VpdGllcysrO1xyXG4gICAgICAgICAgICBpZiAocmFuayhmcm9tKSA9PT0gcmFuayhhbWJpZ0Zyb20pKSB7XHJcbiAgICAgICAgICAgICAgICBzYW1lUmFuaysrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmaWxlKGZyb20pID09PSBmaWxlKGFtYmlnRnJvbSkpIHtcclxuICAgICAgICAgICAgICAgIHNhbWVGaWxlKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoYW1iaWd1aXRpZXMgPiAwKSB7XHJcbiAgICAgICAgaWYgKHNhbWVSYW5rID4gMCAmJiBzYW1lRmlsZSA+IDApIHtcclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICogaWYgdGhlcmUgZXhpc3RzIGEgc2ltaWxhciBtb3ZpbmcgcGllY2Ugb24gdGhlIHNhbWUgcmFuayBhbmQgZmlsZSBhc1xyXG4gICAgICAgICAgICAgKiB0aGUgbW92ZSBpbiBxdWVzdGlvbiwgdXNlIHRoZSBzcXVhcmUgYXMgdGhlIGRpc2FtYmlndWF0b3JcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHJldHVybiBhbGdlYnJhaWMoZnJvbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNhbWVGaWxlID4gMCkge1xyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgKiBpZiB0aGUgbW92aW5nIHBpZWNlIHJlc3RzIG9uIHRoZSBzYW1lIGZpbGUsIHVzZSB0aGUgcmFuayBzeW1ib2wgYXMgdGhlXHJcbiAgICAgICAgICAgICAqIGRpc2FtYmlndWF0b3JcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHJldHVybiBhbGdlYnJhaWMoZnJvbSkuY2hhckF0KDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZWxzZSB1c2UgdGhlIGZpbGUgc3ltYm9sXHJcbiAgICAgICAgICAgIHJldHVybiBhbGdlYnJhaWMoZnJvbSkuY2hhckF0KDApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAnJztcclxufVxyXG5mdW5jdGlvbiBhZGRNb3ZlKG1vdmVzLCBjb2xvciwgZnJvbSwgdG8sIHBpZWNlLCBjYXB0dXJlZCA9IHVuZGVmaW5lZCwgZmxhZ3MgPSBCSVRTLk5PUk1BTCkge1xyXG4gICAgY29uc3QgciA9IHJhbmsodG8pO1xyXG4gICAgaWYgKHBpZWNlID09PSBleHBvcnRzLlBBV04gJiYgKHIgPT09IFJBTktfMSB8fCByID09PSBSQU5LXzgpKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBQUk9NT1RJT05TLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb21vdGlvbiA9IFBST01PVElPTlNbaV07XHJcbiAgICAgICAgICAgIG1vdmVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgY29sb3IsXHJcbiAgICAgICAgICAgICAgICBmcm9tLFxyXG4gICAgICAgICAgICAgICAgdG8sXHJcbiAgICAgICAgICAgICAgICBwaWVjZSxcclxuICAgICAgICAgICAgICAgIGNhcHR1cmVkLFxyXG4gICAgICAgICAgICAgICAgcHJvbW90aW9uLFxyXG4gICAgICAgICAgICAgICAgZmxhZ3M6IGZsYWdzIHwgQklUUy5QUk9NT1RJT04sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG1vdmVzLnB1c2goe1xyXG4gICAgICAgICAgICBjb2xvcixcclxuICAgICAgICAgICAgZnJvbSxcclxuICAgICAgICAgICAgdG8sXHJcbiAgICAgICAgICAgIHBpZWNlLFxyXG4gICAgICAgICAgICBjYXB0dXJlZCxcclxuICAgICAgICAgICAgZmxhZ3MsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaW5mZXJQaWVjZVR5cGUoc2FuKSB7XHJcbiAgICBsZXQgcGllY2VUeXBlID0gc2FuLmNoYXJBdCgwKTtcclxuICAgIGlmIChwaWVjZVR5cGUgPj0gJ2EnICYmIHBpZWNlVHlwZSA8PSAnaCcpIHtcclxuICAgICAgICBjb25zdCBtYXRjaGVzID0gc2FuLm1hdGNoKC9bYS1oXVxcZC4qW2EtaF1cXGQvKTtcclxuICAgICAgICBpZiAobWF0Y2hlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXhwb3J0cy5QQVdOO1xyXG4gICAgfVxyXG4gICAgcGllY2VUeXBlID0gcGllY2VUeXBlLnRvTG93ZXJDYXNlKCk7XHJcbiAgICBpZiAocGllY2VUeXBlID09PSAnbycpIHtcclxuICAgICAgICByZXR1cm4gZXhwb3J0cy5LSU5HO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBpZWNlVHlwZTtcclxufVxyXG4vLyBwYXJzZXMgYWxsIG9mIHRoZSBkZWNvcmF0b3JzIG91dCBvZiBhIFNBTiBzdHJpbmdcclxuZnVuY3Rpb24gc3RyaXBwZWRTYW4obW92ZSkge1xyXG4gICAgcmV0dXJuIG1vdmUucmVwbGFjZSgvPS8sICcnKS5yZXBsYWNlKC9bKyNdP1s/IV0qJC8sICcnKTtcclxufVxyXG5jbGFzcyBDaGVzcyB7XHJcbiAgICBfYm9hcmQgPSBuZXcgQXJyYXkoMTI4KTtcclxuICAgIF90dXJuID0gZXhwb3J0cy5XSElURTtcclxuICAgIF9oZWFkZXIgPSB7fTtcclxuICAgIF9raW5ncyA9IHsgdzogRU1QVFksIGI6IEVNUFRZIH07XHJcbiAgICBfZXBTcXVhcmUgPSAtMTtcclxuICAgIF9oYWxmTW92ZXMgPSAwO1xyXG4gICAgX21vdmVOdW1iZXIgPSAwO1xyXG4gICAgX2hpc3RvcnkgPSBbXTtcclxuICAgIF9jb21tZW50cyA9IHt9O1xyXG4gICAgX2Nhc3RsaW5nID0geyB3OiAwLCBiOiAwIH07XHJcbiAgICBfaGFzaCA9IDBuO1xyXG4gICAgLy8gdHJhY2tzIG51bWJlciBvZiB0aW1lcyBhIHBvc2l0aW9uIGhhcyBiZWVuIHNlZW4gZm9yIHJlcGV0aXRpb24gY2hlY2tpbmdcclxuICAgIF9wb3NpdGlvbkNvdW50ID0gbmV3IE1hcCgpO1xyXG4gICAgY29uc3RydWN0b3IoZmVuID0gZXhwb3J0cy5ERUZBVUxUX1BPU0lUSU9OLCB7IHNraXBWYWxpZGF0aW9uID0gZmFsc2UgfSA9IHt9KSB7XHJcbiAgICAgICAgdGhpcy5sb2FkKGZlbiwgeyBza2lwVmFsaWRhdGlvbiB9KTtcclxuICAgIH1cclxuICAgIGNsZWFyKHsgcHJlc2VydmVIZWFkZXJzID0gZmFsc2UgfSA9IHt9KSB7XHJcbiAgICAgICAgdGhpcy5fYm9hcmQgPSBuZXcgQXJyYXkoMTI4KTtcclxuICAgICAgICB0aGlzLl9raW5ncyA9IHsgdzogRU1QVFksIGI6IEVNUFRZIH07XHJcbiAgICAgICAgdGhpcy5fdHVybiA9IGV4cG9ydHMuV0hJVEU7XHJcbiAgICAgICAgdGhpcy5fY2FzdGxpbmcgPSB7IHc6IDAsIGI6IDAgfTtcclxuICAgICAgICB0aGlzLl9lcFNxdWFyZSA9IEVNUFRZO1xyXG4gICAgICAgIHRoaXMuX2hhbGZNb3ZlcyA9IDA7XHJcbiAgICAgICAgdGhpcy5fbW92ZU51bWJlciA9IDE7XHJcbiAgICAgICAgdGhpcy5faGlzdG9yeSA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2NvbW1lbnRzID0ge307XHJcbiAgICAgICAgdGhpcy5faGVhZGVyID0gcHJlc2VydmVIZWFkZXJzID8gdGhpcy5faGVhZGVyIDogeyAuLi5IRUFERVJfVEVNUExBVEUgfTtcclxuICAgICAgICB0aGlzLl9oYXNoID0gdGhpcy5fY29tcHV0ZUhhc2goKTtcclxuICAgICAgICB0aGlzLl9wb3NpdGlvbkNvdW50ID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogRGVsZXRlIHRoZSBTZXRVcCBhbmQgRkVOIGhlYWRlcnMgKGlmIHByZXNlcnZlZCksIHRoZSBib2FyZCBpcyBlbXB0eSBhbmRcclxuICAgICAgICAgKiB0aGVzZSBoZWFkZXJzIGRvbid0IG1ha2Ugc2Vuc2UgaW4gdGhpcyBzdGF0ZS4gVGhleSdsbCBnZXQgYWRkZWQgbGF0ZXJcclxuICAgICAgICAgKiB2aWEgLmxvYWQoKSBvciAucHV0KClcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9oZWFkZXJbJ1NldFVwJ10gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2hlYWRlclsnRkVOJ10gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgbG9hZChmZW4sIHsgc2tpcFZhbGlkYXRpb24gPSBmYWxzZSwgcHJlc2VydmVIZWFkZXJzID0gZmFsc2UgfSA9IHt9KSB7XHJcbiAgICAgICAgbGV0IHRva2VucyA9IGZlbi5zcGxpdCgvXFxzKy8pO1xyXG4gICAgICAgIC8vIGFwcGVuZCBjb21tb25seSBvbWl0dGVkIGZlbiB0b2tlbnNcclxuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA+PSAyICYmIHRva2Vucy5sZW5ndGggPCA2KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFkanVzdG1lbnRzID0gWyctJywgJy0nLCAnMCcsICcxJ107XHJcbiAgICAgICAgICAgIGZlbiA9IHRva2Vucy5jb25jYXQoYWRqdXN0bWVudHMuc2xpY2UoLSg2IC0gdG9rZW5zLmxlbmd0aCkpKS5qb2luKCcgJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRva2VucyA9IGZlbi5zcGxpdCgvXFxzKy8pO1xyXG4gICAgICAgIGlmICghc2tpcFZhbGlkYXRpb24pIHtcclxuICAgICAgICAgICAgY29uc3QgeyBvaywgZXJyb3IgfSA9IHZhbGlkYXRlRmVuKGZlbik7XHJcbiAgICAgICAgICAgIGlmICghb2spIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0b2tlbnNbMF07XHJcbiAgICAgICAgbGV0IHNxdWFyZSA9IDA7XHJcbiAgICAgICAgdGhpcy5jbGVhcih7IHByZXNlcnZlSGVhZGVycyB9KTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9uLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBpZWNlID0gcG9zaXRpb24uY2hhckF0KGkpO1xyXG4gICAgICAgICAgICBpZiAocGllY2UgPT09ICcvJykge1xyXG4gICAgICAgICAgICAgICAgc3F1YXJlICs9IDg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNEaWdpdChwaWVjZSkpIHtcclxuICAgICAgICAgICAgICAgIHNxdWFyZSArPSBwYXJzZUludChwaWVjZSwgMTApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3IgPSBwaWVjZSA8ICdhJyA/IGV4cG9ydHMuV0hJVEUgOiBleHBvcnRzLkJMQUNLO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHV0KHsgdHlwZTogcGllY2UudG9Mb3dlckNhc2UoKSwgY29sb3IgfSwgYWxnZWJyYWljKHNxdWFyZSkpO1xyXG4gICAgICAgICAgICAgICAgc3F1YXJlKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdHVybiA9IHRva2Vuc1sxXTtcclxuICAgICAgICBpZiAodG9rZW5zWzJdLmluZGV4T2YoJ0snKSA+IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nLncgfD0gQklUUy5LU0lERV9DQVNUTEU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0b2tlbnNbMl0uaW5kZXhPZignUScpID4gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmcudyB8PSBCSVRTLlFTSURFX0NBU1RMRTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRva2Vuc1syXS5pbmRleE9mKCdrJykgPiAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLl9jYXN0bGluZy5iIHw9IEJJVFMuS1NJREVfQ0FTVExFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodG9rZW5zWzJdLmluZGV4T2YoJ3EnKSA+IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nLmIgfD0gQklUUy5RU0lERV9DQVNUTEU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2VwU3F1YXJlID0gdG9rZW5zWzNdID09PSAnLScgPyBFTVBUWSA6IE94ODhbdG9rZW5zWzNdXTtcclxuICAgICAgICB0aGlzLl9oYWxmTW92ZXMgPSBwYXJzZUludCh0b2tlbnNbNF0sIDEwKTtcclxuICAgICAgICB0aGlzLl9tb3ZlTnVtYmVyID0gcGFyc2VJbnQodG9rZW5zWzVdLCAxMCk7XHJcbiAgICAgICAgdGhpcy5faGFzaCA9IHRoaXMuX2NvbXB1dGVIYXNoKCk7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlU2V0dXAoZmVuKTtcclxuICAgICAgICB0aGlzLl9pbmNQb3NpdGlvbkNvdW50KCk7XHJcbiAgICB9XHJcbiAgICBmZW4oeyBmb3JjZUVucGFzc2FudFNxdWFyZSA9IGZhbHNlLCB9ID0ge30pIHtcclxuICAgICAgICBsZXQgZW1wdHkgPSAwO1xyXG4gICAgICAgIGxldCBmZW4gPSAnJztcclxuICAgICAgICBmb3IgKGxldCBpID0gT3g4OC5hODsgaSA8PSBPeDg4LmgxOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2JvYXJkW2ldKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZW1wdHkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmVuICs9IGVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgIGVtcHR5ID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgY29sb3IsIHR5cGU6IHBpZWNlIH0gPSB0aGlzLl9ib2FyZFtpXTtcclxuICAgICAgICAgICAgICAgIGZlbiArPSBjb2xvciA9PT0gZXhwb3J0cy5XSElURSA/IHBpZWNlLnRvVXBwZXJDYXNlKCkgOiBwaWVjZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZW1wdHkrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKGkgKyAxKSAmIDB4ODgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbXB0eSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBmZW4gKz0gZW1wdHk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaSAhPT0gT3g4OC5oMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZlbiArPSAnLyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbXB0eSA9IDA7XHJcbiAgICAgICAgICAgICAgICBpICs9IDg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGNhc3RsaW5nID0gJyc7XHJcbiAgICAgICAgaWYgKHRoaXMuX2Nhc3RsaW5nW2V4cG9ydHMuV0hJVEVdICYgQklUUy5LU0lERV9DQVNUTEUpIHtcclxuICAgICAgICAgICAgY2FzdGxpbmcgKz0gJ0snO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fY2FzdGxpbmdbZXhwb3J0cy5XSElURV0gJiBCSVRTLlFTSURFX0NBU1RMRSkge1xyXG4gICAgICAgICAgICBjYXN0bGluZyArPSAnUSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9jYXN0bGluZ1tleHBvcnRzLkJMQUNLXSAmIEJJVFMuS1NJREVfQ0FTVExFKSB7XHJcbiAgICAgICAgICAgIGNhc3RsaW5nICs9ICdrJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2Nhc3RsaW5nW2V4cG9ydHMuQkxBQ0tdICYgQklUUy5RU0lERV9DQVNUTEUpIHtcclxuICAgICAgICAgICAgY2FzdGxpbmcgKz0gJ3EnO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkbyB3ZSBoYXZlIGFuIGVtcHR5IGNhc3RsaW5nIGZsYWc/XHJcbiAgICAgICAgY2FzdGxpbmcgPSBjYXN0bGluZyB8fCAnLSc7XHJcbiAgICAgICAgbGV0IGVwU3F1YXJlID0gJy0nO1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogb25seSBwcmludCB0aGUgZXAgc3F1YXJlIGlmIGVuIHBhc3NhbnQgaXMgYSB2YWxpZCBtb3ZlIChwYXduIGlzIHByZXNlbnRcclxuICAgICAgICAgKiBhbmQgZXAgY2FwdHVyZSBpcyBub3QgcGlubmVkKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlmICh0aGlzLl9lcFNxdWFyZSAhPT0gRU1QVFkpIHtcclxuICAgICAgICAgICAgaWYgKGZvcmNlRW5wYXNzYW50U3F1YXJlKSB7XHJcbiAgICAgICAgICAgICAgICBlcFNxdWFyZSA9IGFsZ2VicmFpYyh0aGlzLl9lcFNxdWFyZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiaWdQYXduU3F1YXJlID0gdGhpcy5fZXBTcXVhcmUgKyAodGhpcy5fdHVybiA9PT0gZXhwb3J0cy5XSElURSA/IDE2IDogLTE2KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNxdWFyZXMgPSBbYmlnUGF3blNxdWFyZSArIDEsIGJpZ1Bhd25TcXVhcmUgLSAxXTtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3F1YXJlIG9mIHNxdWFyZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpcyB0aGUgc3F1YXJlIG9mZiB0aGUgYm9hcmQ/XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNxdWFyZSAmIDB4ODgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gdGhpcy5fdHVybjtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpcyB0aGVyZSBhIHBhd24gdGhhdCBjYW4gY2FwdHVyZSB0aGUgZXBTcXVhcmU/XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2JvYXJkW3NxdWFyZV0/LmNvbG9yID09PSBjb2xvciAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ib2FyZFtzcXVhcmVdPy50eXBlID09PSBleHBvcnRzLlBBV04pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHBhd24gbWFrZXMgYW4gZXAgY2FwdHVyZSwgZG9lcyBpdCBsZWF2ZSBpdHMga2luZyBpbiBjaGVjaz9cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFrZU1vdmUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBzcXVhcmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogdGhpcy5fZXBTcXVhcmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaWVjZTogZXhwb3J0cy5QQVdOLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FwdHVyZWQ6IGV4cG9ydHMuUEFXTixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzOiBCSVRTLkVQX0NBUFRVUkUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0xlZ2FsID0gIXRoaXMuX2lzS2luZ0F0dGFja2VkKGNvbG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdW5kb01vdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgZXAgaXMgbGVnYWwsIGJyZWFrIGFuZCBzZXQgdGhlIGVwIHNxdWFyZSBpbiB0aGUgRkVOIG91dHB1dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNMZWdhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXBTcXVhcmUgPSBhbGdlYnJhaWModGhpcy5fZXBTcXVhcmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgZmVuLFxyXG4gICAgICAgICAgICB0aGlzLl90dXJuLFxyXG4gICAgICAgICAgICBjYXN0bGluZyxcclxuICAgICAgICAgICAgZXBTcXVhcmUsXHJcbiAgICAgICAgICAgIHRoaXMuX2hhbGZNb3ZlcyxcclxuICAgICAgICAgICAgdGhpcy5fbW92ZU51bWJlcixcclxuICAgICAgICBdLmpvaW4oJyAnKTtcclxuICAgIH1cclxuICAgIF9waWVjZUtleShpKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9ib2FyZFtpXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMG47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgY29sb3IsIHR5cGUgfSA9IHRoaXMuX2JvYXJkW2ldO1xyXG4gICAgICAgIGNvbnN0IGNvbG9ySW5kZXggPSB7XHJcbiAgICAgICAgICAgIHc6IDAsXHJcbiAgICAgICAgICAgIGI6IDEsXHJcbiAgICAgICAgfVtjb2xvcl07XHJcbiAgICAgICAgY29uc3QgdHlwZUluZGV4ID0ge1xyXG4gICAgICAgICAgICBwOiAwLFxyXG4gICAgICAgICAgICBuOiAxLFxyXG4gICAgICAgICAgICBiOiAyLFxyXG4gICAgICAgICAgICByOiAzLFxyXG4gICAgICAgICAgICBxOiA0LFxyXG4gICAgICAgICAgICBrOiA1LFxyXG4gICAgICAgIH1bdHlwZV07XHJcbiAgICAgICAgcmV0dXJuIFBJRUNFX0tFWVNbY29sb3JJbmRleF1bdHlwZUluZGV4XVtpXTtcclxuICAgIH1cclxuICAgIF9lcEtleSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZXBTcXVhcmUgPT09IEVNUFRZID8gMG4gOiBFUF9LRVlTW3RoaXMuX2VwU3F1YXJlICYgN107XHJcbiAgICB9XHJcbiAgICBfY2FzdGxpbmdLZXkoKSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSAodGhpcy5fY2FzdGxpbmcudyA+PiA1KSB8ICh0aGlzLl9jYXN0bGluZy5iID4+IDMpO1xyXG4gICAgICAgIHJldHVybiBDQVNUTElOR19LRVlTW2luZGV4XTtcclxuICAgIH1cclxuICAgIF9jb21wdXRlSGFzaCgpIHtcclxuICAgICAgICBsZXQgaGFzaCA9IDBuO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBPeDg4LmE4OyBpIDw9IE94ODguaDE7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBkaWQgd2UgcnVuIG9mZiB0aGUgZW5kIG9mIHRoZSBib2FyZFxyXG4gICAgICAgICAgICBpZiAoaSAmIDB4ODgpIHtcclxuICAgICAgICAgICAgICAgIGkgKz0gNztcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9ib2FyZFtpXSkge1xyXG4gICAgICAgICAgICAgICAgaGFzaCBePSB0aGlzLl9waWVjZUtleShpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBoYXNoIF49IHRoaXMuX2VwS2V5KCk7XHJcbiAgICAgICAgaGFzaCBePSB0aGlzLl9jYXN0bGluZ0tleSgpO1xyXG4gICAgICAgIGlmICh0aGlzLl90dXJuID09PSAnYicpIHtcclxuICAgICAgICAgICAgaGFzaCBePSBTSURFX0tFWTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhhc2g7XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGluaXRpYWwgYm9hcmQgc2V0dXAgaXMgY2hhbmdlZCB3aXRoIHB1dCgpIG9yIHJlbW92ZSgpLlxyXG4gICAgICogbW9kaWZpZXMgdGhlIFNldFVwIGFuZCBGRU4gcHJvcGVydGllcyBvZiB0aGUgaGVhZGVyIG9iamVjdC4gSWYgdGhlIEZFTlxyXG4gICAgICogaXMgZXF1YWwgdG8gdGhlIGRlZmF1bHQgcG9zaXRpb24sIHRoZSBTZXRVcCBhbmQgRkVOIGFyZSBkZWxldGVkIHRoZSBzZXR1cFxyXG4gICAgICogaXMgb25seSB1cGRhdGVkIGlmIGhpc3RvcnkubGVuZ3RoIGlzIHplcm8sIGllIG1vdmVzIGhhdmVuJ3QgYmVlbiBtYWRlLlxyXG4gICAgICovXHJcbiAgICBfdXBkYXRlU2V0dXAoZmVuKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2hpc3RvcnkubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGlmIChmZW4gIT09IGV4cG9ydHMuREVGQVVMVF9QT1NJVElPTikge1xyXG4gICAgICAgICAgICB0aGlzLl9oZWFkZXJbJ1NldFVwJ10gPSAnMSc7XHJcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlclsnRkVOJ10gPSBmZW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9oZWFkZXJbJ1NldFVwJ10gPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9oZWFkZXJbJ0ZFTiddID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLmxvYWQoZXhwb3J0cy5ERUZBVUxUX1BPU0lUSU9OKTtcclxuICAgIH1cclxuICAgIGdldChzcXVhcmUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYm9hcmRbT3g4OFtzcXVhcmVdXTtcclxuICAgIH1cclxuICAgIGZpbmRQaWVjZShwaWVjZSkge1xyXG4gICAgICAgIGNvbnN0IHNxdWFyZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gT3g4OC5hODsgaSA8PSBPeDg4LmgxOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gZGlkIHdlIHJ1biBvZmYgdGhlIGVuZCBvZiB0aGUgYm9hcmRcclxuICAgICAgICAgICAgaWYgKGkgJiAweDg4KSB7XHJcbiAgICAgICAgICAgICAgICBpICs9IDc7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpZiBlbXB0eSBzcXVhcmUgb3Igd3JvbmcgY29sb3JcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9ib2FyZFtpXSB8fCB0aGlzLl9ib2FyZFtpXT8uY29sb3IgIT09IHBpZWNlLmNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjaGVjayBpZiBzcXVhcmUgY29udGFpbnMgdGhlIHJlcXVlc3RlZCBwaWVjZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fYm9hcmRbaV0uY29sb3IgPT09IHBpZWNlLmNvbG9yICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ib2FyZFtpXS50eXBlID09PSBwaWVjZS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBzcXVhcmVzLnB1c2goYWxnZWJyYWljKGkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3F1YXJlcztcclxuICAgIH1cclxuICAgIHB1dCh7IHR5cGUsIGNvbG9yIH0sIHNxdWFyZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9wdXQoeyB0eXBlLCBjb2xvciB9LCBzcXVhcmUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNhc3RsaW5nUmlnaHRzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUVuUGFzc2FudFNxdWFyZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVTZXR1cCh0aGlzLmZlbigpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIF9zZXQoc3EsIHBpZWNlKSB7XHJcbiAgICAgICAgdGhpcy5faGFzaCBePSB0aGlzLl9waWVjZUtleShzcSk7XHJcbiAgICAgICAgdGhpcy5fYm9hcmRbc3FdID0gcGllY2U7XHJcbiAgICAgICAgdGhpcy5faGFzaCBePSB0aGlzLl9waWVjZUtleShzcSk7XHJcbiAgICB9XHJcbiAgICBfcHV0KHsgdHlwZSwgY29sb3IgfSwgc3F1YXJlKSB7XHJcbiAgICAgICAgLy8gY2hlY2sgZm9yIHBpZWNlXHJcbiAgICAgICAgaWYgKFNZTUJPTFMuaW5kZXhPZih0eXBlLnRvTG93ZXJDYXNlKCkpID09PSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNoZWNrIGZvciB2YWxpZCBzcXVhcmVcclxuICAgICAgICBpZiAoIShzcXVhcmUgaW4gT3g4OCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzcSA9IE94ODhbc3F1YXJlXTtcclxuICAgICAgICAvLyBkb24ndCBsZXQgdGhlIHVzZXIgcGxhY2UgbW9yZSB0aGFuIG9uZSBraW5nXHJcbiAgICAgICAgaWYgKHR5cGUgPT0gZXhwb3J0cy5LSU5HICYmXHJcbiAgICAgICAgICAgICEodGhpcy5fa2luZ3NbY29sb3JdID09IEVNUFRZIHx8IHRoaXMuX2tpbmdzW2NvbG9yXSA9PSBzcSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjdXJyZW50UGllY2VPblNxdWFyZSA9IHRoaXMuX2JvYXJkW3NxXTtcclxuICAgICAgICAvLyBpZiBvbmUgb2YgdGhlIGtpbmdzIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIHBpZWNlIGZyb20gYXJncywgc2V0IHRoZSBgX2tpbmdzYCByZXNwZWN0aXZlIGVudHJ5IHRvIGBFTVBUWWBcclxuICAgICAgICBpZiAoY3VycmVudFBpZWNlT25TcXVhcmUgJiYgY3VycmVudFBpZWNlT25TcXVhcmUudHlwZSA9PT0gZXhwb3J0cy5LSU5HKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2tpbmdzW2N1cnJlbnRQaWVjZU9uU3F1YXJlLmNvbG9yXSA9IEVNUFRZO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zZXQoc3EsIHsgdHlwZTogdHlwZSwgY29sb3I6IGNvbG9yIH0pO1xyXG4gICAgICAgIGlmICh0eXBlID09PSBleHBvcnRzLktJTkcpIHtcclxuICAgICAgICAgICAgdGhpcy5fa2luZ3NbY29sb3JdID0gc3E7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgX2NsZWFyKHNxKSB7XHJcbiAgICAgICAgdGhpcy5faGFzaCBePSB0aGlzLl9waWVjZUtleShzcSk7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX2JvYXJkW3NxXTtcclxuICAgIH1cclxuICAgIHJlbW92ZShzcXVhcmUpIHtcclxuICAgICAgICBjb25zdCBwaWVjZSA9IHRoaXMuZ2V0KHNxdWFyZSk7XHJcbiAgICAgICAgdGhpcy5fY2xlYXIoT3g4OFtzcXVhcmVdKTtcclxuICAgICAgICBpZiAocGllY2UgJiYgcGllY2UudHlwZSA9PT0gZXhwb3J0cy5LSU5HKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2tpbmdzW3BpZWNlLmNvbG9yXSA9IEVNUFRZO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl91cGRhdGVDYXN0bGluZ1JpZ2h0cygpO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUVuUGFzc2FudFNxdWFyZSgpO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZVNldHVwKHRoaXMuZmVuKCkpO1xyXG4gICAgICAgIHJldHVybiBwaWVjZTtcclxuICAgIH1cclxuICAgIF91cGRhdGVDYXN0bGluZ1JpZ2h0cygpIHtcclxuICAgICAgICB0aGlzLl9oYXNoIF49IHRoaXMuX2Nhc3RsaW5nS2V5KCk7XHJcbiAgICAgICAgY29uc3Qgd2hpdGVLaW5nSW5QbGFjZSA9IHRoaXMuX2JvYXJkW094ODguZTFdPy50eXBlID09PSBleHBvcnRzLktJTkcgJiZcclxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbT3g4OC5lMV0/LmNvbG9yID09PSBleHBvcnRzLldISVRFO1xyXG4gICAgICAgIGNvbnN0IGJsYWNrS2luZ0luUGxhY2UgPSB0aGlzLl9ib2FyZFtPeDg4LmU4XT8udHlwZSA9PT0gZXhwb3J0cy5LSU5HICYmXHJcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW094ODguZThdPy5jb2xvciA9PT0gZXhwb3J0cy5CTEFDSztcclxuICAgICAgICBpZiAoIXdoaXRlS2luZ0luUGxhY2UgfHxcclxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbT3g4OC5hMV0/LnR5cGUgIT09IGV4cG9ydHMuUk9PSyB8fFxyXG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtPeDg4LmExXT8uY29sb3IgIT09IGV4cG9ydHMuV0hJVEUpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmcudyAmPSB+QklUUy5RU0lERV9DQVNUTEU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghd2hpdGVLaW5nSW5QbGFjZSB8fFxyXG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtPeDg4LmgxXT8udHlwZSAhPT0gZXhwb3J0cy5ST09LIHx8XHJcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW094ODguaDFdPy5jb2xvciAhPT0gZXhwb3J0cy5XSElURSkge1xyXG4gICAgICAgICAgICB0aGlzLl9jYXN0bGluZy53ICY9IH5CSVRTLktTSURFX0NBU1RMRTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFibGFja0tpbmdJblBsYWNlIHx8XHJcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW094ODguYThdPy50eXBlICE9PSBleHBvcnRzLlJPT0sgfHxcclxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbT3g4OC5hOF0/LmNvbG9yICE9PSBleHBvcnRzLkJMQUNLKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nLmIgJj0gfkJJVFMuUVNJREVfQ0FTVExFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWJsYWNrS2luZ0luUGxhY2UgfHxcclxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbT3g4OC5oOF0/LnR5cGUgIT09IGV4cG9ydHMuUk9PSyB8fFxyXG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtPeDg4Lmg4XT8uY29sb3IgIT09IGV4cG9ydHMuQkxBQ0spIHtcclxuICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmcuYiAmPSB+QklUUy5LU0lERV9DQVNUTEU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2hhc2ggXj0gdGhpcy5fY2FzdGxpbmdLZXkoKTtcclxuICAgIH1cclxuICAgIF91cGRhdGVFblBhc3NhbnRTcXVhcmUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2VwU3F1YXJlID09PSBFTVBUWSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHN0YXJ0U3F1YXJlID0gdGhpcy5fZXBTcXVhcmUgKyAodGhpcy5fdHVybiA9PT0gZXhwb3J0cy5XSElURSA/IC0xNiA6IDE2KTtcclxuICAgICAgICBjb25zdCBjdXJyZW50U3F1YXJlID0gdGhpcy5fZXBTcXVhcmUgKyAodGhpcy5fdHVybiA9PT0gZXhwb3J0cy5XSElURSA/IDE2IDogLTE2KTtcclxuICAgICAgICBjb25zdCBhdHRhY2tlcnMgPSBbY3VycmVudFNxdWFyZSArIDEsIGN1cnJlbnRTcXVhcmUgLSAxXTtcclxuICAgICAgICBpZiAodGhpcy5fYm9hcmRbc3RhcnRTcXVhcmVdICE9PSBudWxsIHx8XHJcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW3RoaXMuX2VwU3F1YXJlXSAhPT0gbnVsbCB8fFxyXG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtjdXJyZW50U3F1YXJlXT8uY29sb3IgIT09IHN3YXBDb2xvcih0aGlzLl90dXJuKSB8fFxyXG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtjdXJyZW50U3F1YXJlXT8udHlwZSAhPT0gZXhwb3J0cy5QQVdOKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhc2ggXj0gdGhpcy5fZXBLZXkoKTtcclxuICAgICAgICAgICAgdGhpcy5fZXBTcXVhcmUgPSBFTVBUWTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjYW5DYXB0dXJlID0gKHNxdWFyZSkgPT4gIShzcXVhcmUgJiAweDg4KSAmJlxyXG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtzcXVhcmVdPy5jb2xvciA9PT0gdGhpcy5fdHVybiAmJlxyXG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtzcXVhcmVdPy50eXBlID09PSBleHBvcnRzLlBBV047XHJcbiAgICAgICAgaWYgKCFhdHRhY2tlcnMuc29tZShjYW5DYXB0dXJlKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9oYXNoIF49IHRoaXMuX2VwS2V5KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2VwU3F1YXJlID0gRU1QVFk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2F0dGFja2VkKGNvbG9yLCBzcXVhcmUsIHZlcmJvc2UpIHtcclxuICAgICAgICBjb25zdCBhdHRhY2tlcnMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gT3g4OC5hODsgaSA8PSBPeDg4LmgxOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gZGlkIHdlIHJ1biBvZmYgdGhlIGVuZCBvZiB0aGUgYm9hcmRcclxuICAgICAgICAgICAgaWYgKGkgJiAweDg4KSB7XHJcbiAgICAgICAgICAgICAgICBpICs9IDc7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpZiBlbXB0eSBzcXVhcmUgb3Igd3JvbmcgY29sb3JcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2JvYXJkW2ldID09PSB1bmRlZmluZWQgfHwgdGhpcy5fYm9hcmRbaV0uY29sb3IgIT09IGNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBwaWVjZSA9IHRoaXMuX2JvYXJkW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBkaWZmZXJlbmNlID0gaSAtIHNxdWFyZTtcclxuICAgICAgICAgICAgLy8gc2tpcCAtIHRvL2Zyb20gc3F1YXJlIGFyZSB0aGUgc2FtZVxyXG4gICAgICAgICAgICBpZiAoZGlmZmVyZW5jZSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBkaWZmZXJlbmNlICsgMTE5O1xyXG4gICAgICAgICAgICBpZiAoQVRUQUNLU1tpbmRleF0gJiBQSUVDRV9NQVNLU1twaWVjZS50eXBlXSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBpZWNlLnR5cGUgPT09IGV4cG9ydHMuUEFXTikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoZGlmZmVyZW5jZSA+IDAgJiYgcGllY2UuY29sb3IgPT09IGV4cG9ydHMuV0hJVEUpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChkaWZmZXJlbmNlIDw9IDAgJiYgcGllY2UuY29sb3IgPT09IGV4cG9ydHMuQkxBQ0spKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmVyYm9zZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2tlcnMucHVzaChhbGdlYnJhaWMoaSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHBpZWNlIGlzIGEga25pZ2h0IG9yIGEga2luZ1xyXG4gICAgICAgICAgICAgICAgaWYgKHBpZWNlLnR5cGUgPT09ICduJyB8fCBwaWVjZS50eXBlID09PSAnaycpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXZlcmJvc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2tlcnMucHVzaChhbGdlYnJhaWMoaSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBSQVlTW2luZGV4XTtcclxuICAgICAgICAgICAgICAgIGxldCBqID0gaSArIG9mZnNldDtcclxuICAgICAgICAgICAgICAgIGxldCBibG9ja2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaiAhPT0gc3F1YXJlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2JvYXJkW2pdICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBqICs9IG9mZnNldDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghYmxvY2tlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdmVyYm9zZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFja2Vycy5wdXNoKGFsZ2VicmFpYyhpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmVyYm9zZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXR0YWNrZXJzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGF0dGFja2VycyhzcXVhcmUsIGF0dGFja2VkQnkpIHtcclxuICAgICAgICBpZiAoIWF0dGFja2VkQnkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2F0dGFja2VkKHRoaXMuX3R1cm4sIE94ODhbc3F1YXJlXSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXR0YWNrZWQoYXR0YWNrZWRCeSwgT3g4OFtzcXVhcmVdLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfaXNLaW5nQXR0YWNrZWQoY29sb3IpIHtcclxuICAgICAgICBjb25zdCBzcXVhcmUgPSB0aGlzLl9raW5nc1tjb2xvcl07XHJcbiAgICAgICAgcmV0dXJuIHNxdWFyZSA9PT0gLTEgPyBmYWxzZSA6IHRoaXMuX2F0dGFja2VkKHN3YXBDb2xvcihjb2xvciksIHNxdWFyZSk7XHJcbiAgICB9XHJcbiAgICBoYXNoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNoLnRvU3RyaW5nKDE2KTtcclxuICAgIH1cclxuICAgIGlzQXR0YWNrZWQoc3F1YXJlLCBhdHRhY2tlZEJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F0dGFja2VkKGF0dGFja2VkQnksIE94ODhbc3F1YXJlXSk7XHJcbiAgICB9XHJcbiAgICBpc0NoZWNrKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0tpbmdBdHRhY2tlZCh0aGlzLl90dXJuKTtcclxuICAgIH1cclxuICAgIGluQ2hlY2soKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDaGVjaygpO1xyXG4gICAgfVxyXG4gICAgaXNDaGVja21hdGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDaGVjaygpICYmIHRoaXMuX21vdmVzKCkubGVuZ3RoID09PSAwO1xyXG4gICAgfVxyXG4gICAgaXNTdGFsZW1hdGUoKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzQ2hlY2soKSAmJiB0aGlzLl9tb3ZlcygpLmxlbmd0aCA9PT0gMDtcclxuICAgIH1cclxuICAgIGlzSW5zdWZmaWNpZW50TWF0ZXJpYWwoKSB7XHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBrLmIuIHZzIGsuYi4gKG9mIG9wcG9zaXRlIGNvbG9ycykgd2l0aCBtYXRlIGluIDE6XHJcbiAgICAgICAgICogOC84LzgvOC8xYjYvOC9CMWs1L0s3IGIgLSAtIDAgMVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogay5iLiB2cyBrLm4uIHdpdGggbWF0ZSBpbiAxOlxyXG4gICAgICAgICAqIDgvOC84LzgvMW42LzgvQjcvSzFrNSBiIC0gLSAyIDFcclxuICAgICAgICAgKi9cclxuICAgICAgICBjb25zdCBwaWVjZXMgPSB7XHJcbiAgICAgICAgICAgIGI6IDAsXHJcbiAgICAgICAgICAgIG46IDAsXHJcbiAgICAgICAgICAgIHI6IDAsXHJcbiAgICAgICAgICAgIHE6IDAsXHJcbiAgICAgICAgICAgIGs6IDAsXHJcbiAgICAgICAgICAgIHA6IDAsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBiaXNob3BzID0gW107XHJcbiAgICAgICAgbGV0IG51bVBpZWNlcyA9IDA7XHJcbiAgICAgICAgbGV0IHNxdWFyZUNvbG9yID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gT3g4OC5hODsgaSA8PSBPeDg4LmgxOyBpKyspIHtcclxuICAgICAgICAgICAgc3F1YXJlQ29sb3IgPSAoc3F1YXJlQ29sb3IgKyAxKSAlIDI7XHJcbiAgICAgICAgICAgIGlmIChpICYgMHg4OCkge1xyXG4gICAgICAgICAgICAgICAgaSArPSA3O1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcGllY2UgPSB0aGlzLl9ib2FyZFtpXTtcclxuICAgICAgICAgICAgaWYgKHBpZWNlKSB7XHJcbiAgICAgICAgICAgICAgICBwaWVjZXNbcGllY2UudHlwZV0gPSBwaWVjZS50eXBlIGluIHBpZWNlcyA/IHBpZWNlc1twaWVjZS50eXBlXSArIDEgOiAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBpZWNlLnR5cGUgPT09IGV4cG9ydHMuQklTSE9QKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmlzaG9wcy5wdXNoKHNxdWFyZUNvbG9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG51bVBpZWNlcysrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGsgdnMuIGtcclxuICAgICAgICBpZiAobnVtUGllY2VzID09PSAyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChcclxuICAgICAgICAvLyBrIHZzLiBrbiAuLi4uIG9yIC4uLi4gayB2cy4ga2JcclxuICAgICAgICBudW1QaWVjZXMgPT09IDMgJiZcclxuICAgICAgICAgICAgKHBpZWNlc1tleHBvcnRzLkJJU0hPUF0gPT09IDEgfHwgcGllY2VzW2V4cG9ydHMuS05JR0hUXSA9PT0gMSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG51bVBpZWNlcyA9PT0gcGllY2VzW2V4cG9ydHMuQklTSE9QXSArIDIpIHtcclxuICAgICAgICAgICAgLy8ga2IgdnMuIGtiIHdoZXJlIGFueSBudW1iZXIgb2YgYmlzaG9wcyBhcmUgYWxsIG9uIHRoZSBzYW1lIGNvbG9yXHJcbiAgICAgICAgICAgIGxldCBzdW0gPSAwO1xyXG4gICAgICAgICAgICBjb25zdCBsZW4gPSBiaXNob3BzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgc3VtICs9IGJpc2hvcHNbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN1bSA9PT0gMCB8fCBzdW0gPT09IGxlbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaXNUaHJlZWZvbGRSZXBldGl0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRQb3NpdGlvbkNvdW50KHRoaXMuX2hhc2gpID49IDM7XHJcbiAgICB9XHJcbiAgICBpc0RyYXdCeUZpZnR5TW92ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbGZNb3ZlcyA+PSAxMDA7IC8vIDUwIG1vdmVzIHBlciBzaWRlID0gMTAwIGhhbGYgbW92ZXNcclxuICAgIH1cclxuICAgIGlzRHJhdygpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuaXNEcmF3QnlGaWZ0eU1vdmVzKCkgfHxcclxuICAgICAgICAgICAgdGhpcy5pc1N0YWxlbWF0ZSgpIHx8XHJcbiAgICAgICAgICAgIHRoaXMuaXNJbnN1ZmZpY2llbnRNYXRlcmlhbCgpIHx8XHJcbiAgICAgICAgICAgIHRoaXMuaXNUaHJlZWZvbGRSZXBldGl0aW9uKCkpO1xyXG4gICAgfVxyXG4gICAgaXNHYW1lT3ZlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc0NoZWNrbWF0ZSgpIHx8IHRoaXMuaXNEcmF3KCk7XHJcbiAgICB9XHJcbiAgICBtb3Zlcyh7IHZlcmJvc2UgPSBmYWxzZSwgc3F1YXJlID0gdW5kZWZpbmVkLCBwaWVjZSA9IHVuZGVmaW5lZCwgfSA9IHt9KSB7XHJcbiAgICAgICAgY29uc3QgbW92ZXMgPSB0aGlzLl9tb3Zlcyh7IHNxdWFyZSwgcGllY2UgfSk7XHJcbiAgICAgICAgaWYgKHZlcmJvc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vdmVzLm1hcCgobW92ZSkgPT4gbmV3IE1vdmUodGhpcywgbW92ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vdmVzLm1hcCgobW92ZSkgPT4gdGhpcy5fbW92ZVRvU2FuKG1vdmUsIG1vdmVzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX21vdmVzKHsgbGVnYWwgPSB0cnVlLCBwaWVjZSA9IHVuZGVmaW5lZCwgc3F1YXJlID0gdW5kZWZpbmVkLCB9ID0ge30pIHtcclxuICAgICAgICBjb25zdCBmb3JTcXVhcmUgPSBzcXVhcmUgPyBzcXVhcmUudG9Mb3dlckNhc2UoKSA6IHVuZGVmaW5lZDtcclxuICAgICAgICBjb25zdCBmb3JQaWVjZSA9IHBpZWNlPy50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGNvbnN0IG1vdmVzID0gW107XHJcbiAgICAgICAgY29uc3QgdXMgPSB0aGlzLl90dXJuO1xyXG4gICAgICAgIGNvbnN0IHRoZW0gPSBzd2FwQ29sb3IodXMpO1xyXG4gICAgICAgIGxldCBmaXJzdFNxdWFyZSA9IE94ODguYTg7XHJcbiAgICAgICAgbGV0IGxhc3RTcXVhcmUgPSBPeDg4LmgxO1xyXG4gICAgICAgIGxldCBzaW5nbGVTcXVhcmUgPSBmYWxzZTtcclxuICAgICAgICAvLyBhcmUgd2UgZ2VuZXJhdGluZyBtb3ZlcyBmb3IgYSBzaW5nbGUgc3F1YXJlP1xyXG4gICAgICAgIGlmIChmb3JTcXVhcmUpIHtcclxuICAgICAgICAgICAgLy8gaWxsZWdhbCBzcXVhcmUsIHJldHVybiBlbXB0eSBtb3Zlc1xyXG4gICAgICAgICAgICBpZiAoIShmb3JTcXVhcmUgaW4gT3g4OCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZpcnN0U3F1YXJlID0gbGFzdFNxdWFyZSA9IE94ODhbZm9yU3F1YXJlXTtcclxuICAgICAgICAgICAgICAgIHNpbmdsZVNxdWFyZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgZnJvbSA9IGZpcnN0U3F1YXJlOyBmcm9tIDw9IGxhc3RTcXVhcmU7IGZyb20rKykge1xyXG4gICAgICAgICAgICAvLyBkaWQgd2UgcnVuIG9mZiB0aGUgZW5kIG9mIHRoZSBib2FyZFxyXG4gICAgICAgICAgICBpZiAoZnJvbSAmIDB4ODgpIHtcclxuICAgICAgICAgICAgICAgIGZyb20gKz0gNztcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGVtcHR5IHNxdWFyZSBvciBvcHBvbmVudCwgc2tpcFxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2JvYXJkW2Zyb21dIHx8IHRoaXMuX2JvYXJkW2Zyb21dLmNvbG9yID09PSB0aGVtKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB7IHR5cGUgfSA9IHRoaXMuX2JvYXJkW2Zyb21dO1xyXG4gICAgICAgICAgICBsZXQgdG87XHJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBleHBvcnRzLlBBV04pIHtcclxuICAgICAgICAgICAgICAgIGlmIChmb3JQaWVjZSAmJiBmb3JQaWVjZSAhPT0gdHlwZSlcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBzcXVhcmUsIG5vbi1jYXB0dXJpbmdcclxuICAgICAgICAgICAgICAgIHRvID0gZnJvbSArIFBBV05fT0ZGU0VUU1t1c11bMF07XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2JvYXJkW3RvXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZE1vdmUobW92ZXMsIHVzLCBmcm9tLCB0bywgZXhwb3J0cy5QQVdOKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBkb3VibGUgc3F1YXJlXHJcbiAgICAgICAgICAgICAgICAgICAgdG8gPSBmcm9tICsgUEFXTl9PRkZTRVRTW3VzXVsxXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoU0VDT05EX1JBTktbdXNdID09PSByYW5rKGZyb20pICYmICF0aGlzLl9ib2FyZFt0b10pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkTW92ZShtb3ZlcywgdXMsIGZyb20sIHRvLCBleHBvcnRzLlBBV04sIHVuZGVmaW5lZCwgQklUUy5CSUdfUEFXTik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gcGF3biBjYXB0dXJlc1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDI7IGogPCA0OyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0byA9IGZyb20gKyBQQVdOX09GRlNFVFNbdXNdW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0byAmIDB4ODgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9ib2FyZFt0b10/LmNvbG9yID09PSB0aGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE1vdmUobW92ZXMsIHVzLCBmcm9tLCB0bywgZXhwb3J0cy5QQVdOLCB0aGlzLl9ib2FyZFt0b10udHlwZSwgQklUUy5DQVBUVVJFKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG8gPT09IHRoaXMuX2VwU3F1YXJlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE1vdmUobW92ZXMsIHVzLCBmcm9tLCB0bywgZXhwb3J0cy5QQVdOLCBleHBvcnRzLlBBV04sIEJJVFMuRVBfQ0FQVFVSRSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGZvclBpZWNlICYmIGZvclBpZWNlICE9PSB0eXBlKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIGxlbiA9IFBJRUNFX09GRlNFVFNbdHlwZV0ubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBQSUVDRV9PRkZTRVRTW3R5cGVdW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRvID0gZnJvbTtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0byArPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0byAmIDB4ODgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9ib2FyZFt0b10pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZE1vdmUobW92ZXMsIHVzLCBmcm9tLCB0bywgdHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvd24gY29sb3IsIHN0b3AgbG9vcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2JvYXJkW3RvXS5jb2xvciA9PT0gdXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRNb3ZlKG1vdmVzLCB1cywgZnJvbSwgdG8sIHR5cGUsIHRoaXMuX2JvYXJkW3RvXS50eXBlLCBCSVRTLkNBUFRVUkUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLyogYnJlYWssIGlmIGtuaWdodCBvciBraW5nICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBleHBvcnRzLktOSUdIVCB8fCB0eXBlID09PSBleHBvcnRzLktJTkcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBjaGVjayBmb3IgY2FzdGxpbmcgaWYgd2UncmU6XHJcbiAgICAgICAgICogICBhKSBnZW5lcmF0aW5nIGFsbCBtb3Zlcywgb3JcclxuICAgICAgICAgKiAgIGIpIGRvaW5nIHNpbmdsZSBzcXVhcmUgbW92ZSBnZW5lcmF0aW9uIG9uIHRoZSBraW5nJ3Mgc3F1YXJlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaWYgKGZvclBpZWNlID09PSB1bmRlZmluZWQgfHwgZm9yUGllY2UgPT09IGV4cG9ydHMuS0lORykge1xyXG4gICAgICAgICAgICBpZiAoIXNpbmdsZVNxdWFyZSB8fCBsYXN0U3F1YXJlID09PSB0aGlzLl9raW5nc1t1c10pIHtcclxuICAgICAgICAgICAgICAgIC8vIGtpbmctc2lkZSBjYXN0bGluZ1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Nhc3RsaW5nW3VzXSAmIEJJVFMuS1NJREVfQ0FTVExFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FzdGxpbmdGcm9tID0gdGhpcy5fa2luZ3NbdXNdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhc3RsaW5nVG8gPSBjYXN0bGluZ0Zyb20gKyAyO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYm9hcmRbY2FzdGxpbmdGcm9tICsgMV0gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuX2JvYXJkW2Nhc3RsaW5nVG9dICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLl9hdHRhY2tlZCh0aGVtLCB0aGlzLl9raW5nc1t1c10pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLl9hdHRhY2tlZCh0aGVtLCBjYXN0bGluZ0Zyb20gKyAxKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5fYXR0YWNrZWQodGhlbSwgY2FzdGxpbmdUbykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkTW92ZShtb3ZlcywgdXMsIHRoaXMuX2tpbmdzW3VzXSwgY2FzdGxpbmdUbywgZXhwb3J0cy5LSU5HLCB1bmRlZmluZWQsIEJJVFMuS1NJREVfQ0FTVExFKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBxdWVlbi1zaWRlIGNhc3RsaW5nXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2FzdGxpbmdbdXNdICYgQklUUy5RU0lERV9DQVNUTEUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYXN0bGluZ0Zyb20gPSB0aGlzLl9raW5nc1t1c107XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FzdGxpbmdUbyA9IGNhc3RsaW5nRnJvbSAtIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9ib2FyZFtjYXN0bGluZ0Zyb20gLSAxXSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5fYm9hcmRbY2FzdGxpbmdGcm9tIC0gMl0gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuX2JvYXJkW2Nhc3RsaW5nRnJvbSAtIDNdICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLl9hdHRhY2tlZCh0aGVtLCB0aGlzLl9raW5nc1t1c10pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLl9hdHRhY2tlZCh0aGVtLCBjYXN0bGluZ0Zyb20gLSAxKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5fYXR0YWNrZWQodGhlbSwgY2FzdGxpbmdUbykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkTW92ZShtb3ZlcywgdXMsIHRoaXMuX2tpbmdzW3VzXSwgY2FzdGxpbmdUbywgZXhwb3J0cy5LSU5HLCB1bmRlZmluZWQsIEJJVFMuUVNJREVfQ0FTVExFKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiByZXR1cm4gYWxsIHBzZXVkby1sZWdhbCBtb3ZlcyAodGhpcyBpbmNsdWRlcyBtb3ZlcyB0aGF0IGFsbG93IHRoZSBraW5nXHJcbiAgICAgICAgICogdG8gYmUgY2FwdHVyZWQpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaWYgKCFsZWdhbCB8fCB0aGlzLl9raW5nc1t1c10gPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb3ZlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZmlsdGVyIG91dCBpbGxlZ2FsIG1vdmVzXHJcbiAgICAgICAgY29uc3QgbGVnYWxNb3ZlcyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBtb3Zlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLl9tYWtlTW92ZShtb3Zlc1tpXSk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNLaW5nQXR0YWNrZWQodXMpKSB7XHJcbiAgICAgICAgICAgICAgICBsZWdhbE1vdmVzLnB1c2gobW92ZXNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3VuZG9Nb3ZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsZWdhbE1vdmVzO1xyXG4gICAgfVxyXG4gICAgbW92ZShtb3ZlLCB7IHN0cmljdCA9IGZhbHNlIH0gPSB7fSkge1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogVGhlIG1vdmUgZnVuY3Rpb24gY2FuIGJlIGNhbGxlZCB3aXRoIGluIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIC5tb3ZlKCdOeGI3JykgICAgICAgPC0gYXJndW1lbnQgaXMgYSBjYXNlLXNlbnNpdGl2ZSBTQU4gc3RyaW5nXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAubW92ZSh7IGZyb206ICdoNycsIDwtIGFyZ3VtZW50IGlzIGEgbW92ZSBvYmplY3RcclxuICAgICAgICAgKiAgICAgICAgIHRvIDonaDgnLFxyXG4gICAgICAgICAqICAgICAgICAgcHJvbW90aW9uOiAncScgfSlcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQW4gb3B0aW9uYWwgc3RyaWN0IGFyZ3VtZW50IG1heSBiZSBzdXBwbGllZCB0byB0ZWxsIGNoZXNzLmpzIHRvXHJcbiAgICAgICAgICogc3RyaWN0bHkgZm9sbG93IHRoZSBTQU4gc3BlY2lmaWNhdGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBsZXQgbW92ZU9iaiA9IG51bGw7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBtb3ZlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBtb3ZlT2JqID0gdGhpcy5fbW92ZUZyb21TYW4obW92ZSwgc3RyaWN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1vdmUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vdmVzID0gdGhpcy5fbW92ZXMoKTtcclxuICAgICAgICAgICAgLy8gY29udmVydCB0aGUgcHJldHR5IG1vdmUgb2JqZWN0IHRvIGFuIHVnbHkgbW92ZSBvYmplY3RcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG1vdmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobW92ZS5mcm9tID09PSBhbGdlYnJhaWMobW92ZXNbaV0uZnJvbSkgJiZcclxuICAgICAgICAgICAgICAgICAgICBtb3ZlLnRvID09PSBhbGdlYnJhaWMobW92ZXNbaV0udG8pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKCEoJ3Byb21vdGlvbicgaW4gbW92ZXNbaV0pIHx8IG1vdmUucHJvbW90aW9uID09PSBtb3Zlc1tpXS5wcm9tb3Rpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW92ZU9iaiA9IG1vdmVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGZhaWxlZCB0byBmaW5kIG1vdmVcclxuICAgICAgICBpZiAoIW1vdmVPYmopIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtb3ZlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1vdmU6ICR7bW92ZX1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtb3ZlOiAke0pTT04uc3RyaW5naWZ5KG1vdmUpfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogbmVlZCB0byBtYWtlIGEgY29weSBvZiBtb3ZlIGJlY2F1c2Ugd2UgY2FuJ3QgZ2VuZXJhdGUgU0FOIGFmdGVyIHRoZSBtb3ZlXHJcbiAgICAgICAgICogaXMgbWFkZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbnN0IHByZXR0eU1vdmUgPSBuZXcgTW92ZSh0aGlzLCBtb3ZlT2JqKTtcclxuICAgICAgICB0aGlzLl9tYWtlTW92ZShtb3ZlT2JqKTtcclxuICAgICAgICB0aGlzLl9pbmNQb3NpdGlvbkNvdW50KCk7XHJcbiAgICAgICAgcmV0dXJuIHByZXR0eU1vdmU7XHJcbiAgICB9XHJcbiAgICBfcHVzaChtb3ZlKSB7XHJcbiAgICAgICAgdGhpcy5faGlzdG9yeS5wdXNoKHtcclxuICAgICAgICAgICAgbW92ZSxcclxuICAgICAgICAgICAga2luZ3M6IHsgYjogdGhpcy5fa2luZ3MuYiwgdzogdGhpcy5fa2luZ3MudyB9LFxyXG4gICAgICAgICAgICB0dXJuOiB0aGlzLl90dXJuLFxyXG4gICAgICAgICAgICBjYXN0bGluZzogeyBiOiB0aGlzLl9jYXN0bGluZy5iLCB3OiB0aGlzLl9jYXN0bGluZy53IH0sXHJcbiAgICAgICAgICAgIGVwU3F1YXJlOiB0aGlzLl9lcFNxdWFyZSxcclxuICAgICAgICAgICAgaGFsZk1vdmVzOiB0aGlzLl9oYWxmTW92ZXMsXHJcbiAgICAgICAgICAgIG1vdmVOdW1iZXI6IHRoaXMuX21vdmVOdW1iZXIsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfbW92ZVBpZWNlKGZyb20sIHRvKSB7XHJcbiAgICAgICAgdGhpcy5faGFzaCBePSB0aGlzLl9waWVjZUtleShmcm9tKTtcclxuICAgICAgICB0aGlzLl9ib2FyZFt0b10gPSB0aGlzLl9ib2FyZFtmcm9tXTtcclxuICAgICAgICBkZWxldGUgdGhpcy5fYm9hcmRbZnJvbV07XHJcbiAgICAgICAgdGhpcy5faGFzaCBePSB0aGlzLl9waWVjZUtleSh0byk7XHJcbiAgICB9XHJcbiAgICBfbWFrZU1vdmUobW92ZSkge1xyXG4gICAgICAgIGNvbnN0IHVzID0gdGhpcy5fdHVybjtcclxuICAgICAgICBjb25zdCB0aGVtID0gc3dhcENvbG9yKHVzKTtcclxuICAgICAgICB0aGlzLl9wdXNoKG1vdmUpO1xyXG4gICAgICAgIHRoaXMuX2hhc2ggXj0gdGhpcy5fZXBLZXkoKTtcclxuICAgICAgICB0aGlzLl9oYXNoIF49IHRoaXMuX2Nhc3RsaW5nS2V5KCk7XHJcbiAgICAgICAgaWYgKG1vdmUuY2FwdHVyZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5faGFzaCBePSB0aGlzLl9waWVjZUtleShtb3ZlLnRvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbW92ZVBpZWNlKG1vdmUuZnJvbSwgbW92ZS50byk7XHJcbiAgICAgICAgLy8gaWYgZXAgY2FwdHVyZSwgcmVtb3ZlIHRoZSBjYXB0dXJlZCBwYXduXHJcbiAgICAgICAgaWYgKG1vdmUuZmxhZ3MgJiBCSVRTLkVQX0NBUFRVUkUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3R1cm4gPT09IGV4cG9ydHMuQkxBQ0spIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFyKG1vdmUudG8gLSAxNik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGVhcihtb3ZlLnRvICsgMTYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIHBhd24gcHJvbW90aW9uLCByZXBsYWNlIHdpdGggbmV3IHBpZWNlXHJcbiAgICAgICAgaWYgKG1vdmUucHJvbW90aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyKG1vdmUudG8pO1xyXG4gICAgICAgICAgICB0aGlzLl9zZXQobW92ZS50bywgeyB0eXBlOiBtb3ZlLnByb21vdGlvbiwgY29sb3I6IHVzIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiB3ZSBtb3ZlZCB0aGUga2luZ1xyXG4gICAgICAgIGlmICh0aGlzLl9ib2FyZFttb3ZlLnRvXS50eXBlID09PSBleHBvcnRzLktJTkcpIHtcclxuICAgICAgICAgICAgdGhpcy5fa2luZ3NbdXNdID0gbW92ZS50bztcclxuICAgICAgICAgICAgLy8gaWYgd2UgY2FzdGxlZCwgbW92ZSB0aGUgcm9vayBuZXh0IHRvIHRoZSBraW5nXHJcbiAgICAgICAgICAgIGlmIChtb3ZlLmZsYWdzICYgQklUUy5LU0lERV9DQVNUTEUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNhc3RsaW5nVG8gPSBtb3ZlLnRvIC0gMTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNhc3RsaW5nRnJvbSA9IG1vdmUudG8gKyAxO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbW92ZVBpZWNlKGNhc3RsaW5nRnJvbSwgY2FzdGxpbmdUbyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobW92ZS5mbGFncyAmIEJJVFMuUVNJREVfQ0FTVExFKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYXN0bGluZ1RvID0gbW92ZS50byArIDE7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYXN0bGluZ0Zyb20gPSBtb3ZlLnRvIC0gMjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21vdmVQaWVjZShjYXN0bGluZ0Zyb20sIGNhc3RsaW5nVG8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHR1cm4gb2ZmIGNhc3RsaW5nXHJcbiAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nW3VzXSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHR1cm4gb2ZmIGNhc3RsaW5nIGlmIHdlIG1vdmUgYSByb29rXHJcbiAgICAgICAgaWYgKHRoaXMuX2Nhc3RsaW5nW3VzXSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gUk9PS1NbdXNdLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobW92ZS5mcm9tID09PSBST09LU1t1c11baV0uc3F1YXJlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmdbdXNdICYgUk9PS1NbdXNdW2ldLmZsYWcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYXN0bGluZ1t1c10gXj0gUk9PS1NbdXNdW2ldLmZsYWc7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdHVybiBvZmYgY2FzdGxpbmcgaWYgd2UgY2FwdHVyZSBhIHJvb2tcclxuICAgICAgICBpZiAodGhpcy5fY2FzdGxpbmdbdGhlbV0pIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IFJPT0tTW3RoZW1dLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobW92ZS50byA9PT0gUk9PS1NbdGhlbV1baV0uc3F1YXJlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmdbdGhlbV0gJiBST09LU1t0aGVtXVtpXS5mbGFnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmdbdGhlbV0gXj0gUk9PS1NbdGhlbV1baV0uZmxhZztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9oYXNoIF49IHRoaXMuX2Nhc3RsaW5nS2V5KCk7XHJcbiAgICAgICAgLy8gaWYgYmlnIHBhd24gbW92ZSwgdXBkYXRlIHRoZSBlbiBwYXNzYW50IHNxdWFyZVxyXG4gICAgICAgIGlmIChtb3ZlLmZsYWdzICYgQklUUy5CSUdfUEFXTikge1xyXG4gICAgICAgICAgICBsZXQgZXBTcXVhcmU7XHJcbiAgICAgICAgICAgIGlmICh1cyA9PT0gZXhwb3J0cy5CTEFDSykge1xyXG4gICAgICAgICAgICAgICAgZXBTcXVhcmUgPSBtb3ZlLnRvIC0gMTY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBlcFNxdWFyZSA9IG1vdmUudG8gKyAxNjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKCEoKG1vdmUudG8gLSAxKSAmIDB4ODgpICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ib2FyZFttb3ZlLnRvIC0gMV0/LnR5cGUgPT09IGV4cG9ydHMuUEFXTiAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fYm9hcmRbbW92ZS50byAtIDFdPy5jb2xvciA9PT0gdGhlbSkgfHxcclxuICAgICAgICAgICAgICAgICghKChtb3ZlLnRvICsgMSkgJiAweDg4KSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JvYXJkW21vdmUudG8gKyAxXT8udHlwZSA9PT0gZXhwb3J0cy5QQVdOICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYm9hcmRbbW92ZS50byArIDFdPy5jb2xvciA9PT0gdGhlbSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VwU3F1YXJlID0gZXBTcXVhcmU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNoIF49IHRoaXMuX2VwS2V5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lcFNxdWFyZSA9IEVNUFRZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9lcFNxdWFyZSA9IEVNUFRZO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZXNldCB0aGUgNTAgbW92ZSBjb3VudGVyIGlmIGEgcGF3biBpcyBtb3ZlZCBvciBhIHBpZWNlIGlzIGNhcHR1cmVkXHJcbiAgICAgICAgaWYgKG1vdmUucGllY2UgPT09IGV4cG9ydHMuUEFXTikge1xyXG4gICAgICAgICAgICB0aGlzLl9oYWxmTW92ZXMgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChtb3ZlLmZsYWdzICYgKEJJVFMuQ0FQVFVSRSB8IEJJVFMuRVBfQ0FQVFVSRSkpIHtcclxuICAgICAgICAgICAgdGhpcy5faGFsZk1vdmVzID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbGZNb3ZlcysrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodXMgPT09IGV4cG9ydHMuQkxBQ0spIHtcclxuICAgICAgICAgICAgdGhpcy5fbW92ZU51bWJlcisrO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl90dXJuID0gdGhlbTtcclxuICAgICAgICB0aGlzLl9oYXNoIF49IFNJREVfS0VZO1xyXG4gICAgfVxyXG4gICAgdW5kbygpIHtcclxuICAgICAgICBjb25zdCBoYXNoID0gdGhpcy5faGFzaDtcclxuICAgICAgICBjb25zdCBtb3ZlID0gdGhpcy5fdW5kb01vdmUoKTtcclxuICAgICAgICBpZiAobW92ZSkge1xyXG4gICAgICAgICAgICBjb25zdCBwcmV0dHlNb3ZlID0gbmV3IE1vdmUodGhpcywgbW92ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2RlY1Bvc2l0aW9uQ291bnQoaGFzaCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcmV0dHlNb3ZlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIF91bmRvTW92ZSgpIHtcclxuICAgICAgICBjb25zdCBvbGQgPSB0aGlzLl9oaXN0b3J5LnBvcCgpO1xyXG4gICAgICAgIGlmIChvbGQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faGFzaCBePSB0aGlzLl9lcEtleSgpO1xyXG4gICAgICAgIHRoaXMuX2hhc2ggXj0gdGhpcy5fY2FzdGxpbmdLZXkoKTtcclxuICAgICAgICBjb25zdCBtb3ZlID0gb2xkLm1vdmU7XHJcbiAgICAgICAgdGhpcy5fa2luZ3MgPSBvbGQua2luZ3M7XHJcbiAgICAgICAgdGhpcy5fdHVybiA9IG9sZC50dXJuO1xyXG4gICAgICAgIHRoaXMuX2Nhc3RsaW5nID0gb2xkLmNhc3RsaW5nO1xyXG4gICAgICAgIHRoaXMuX2VwU3F1YXJlID0gb2xkLmVwU3F1YXJlO1xyXG4gICAgICAgIHRoaXMuX2hhbGZNb3ZlcyA9IG9sZC5oYWxmTW92ZXM7XHJcbiAgICAgICAgdGhpcy5fbW92ZU51bWJlciA9IG9sZC5tb3ZlTnVtYmVyO1xyXG4gICAgICAgIHRoaXMuX2hhc2ggXj0gdGhpcy5fZXBLZXkoKTtcclxuICAgICAgICB0aGlzLl9oYXNoIF49IHRoaXMuX2Nhc3RsaW5nS2V5KCk7XHJcbiAgICAgICAgdGhpcy5faGFzaCBePSBTSURFX0tFWTtcclxuICAgICAgICBjb25zdCB1cyA9IHRoaXMuX3R1cm47XHJcbiAgICAgICAgY29uc3QgdGhlbSA9IHN3YXBDb2xvcih1cyk7XHJcbiAgICAgICAgdGhpcy5fbW92ZVBpZWNlKG1vdmUudG8sIG1vdmUuZnJvbSk7XHJcbiAgICAgICAgLy8gdG8gdW5kbyBhbnkgcHJvbW90aW9uc1xyXG4gICAgICAgIGlmIChtb3ZlLnBpZWNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyKG1vdmUuZnJvbSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldChtb3ZlLmZyb20sIHsgdHlwZTogbW92ZS5waWVjZSwgY29sb3I6IHVzIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobW92ZS5jYXB0dXJlZCkge1xyXG4gICAgICAgICAgICBpZiAobW92ZS5mbGFncyAmIEJJVFMuRVBfQ0FQVFVSRSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZW4gcGFzc2FudCBjYXB0dXJlXHJcbiAgICAgICAgICAgICAgICBsZXQgaW5kZXg7XHJcbiAgICAgICAgICAgICAgICBpZiAodXMgPT09IGV4cG9ydHMuQkxBQ0spIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IG1vdmUudG8gLSAxNjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gbW92ZS50byArIDE2O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0KGluZGV4LCB7IHR5cGU6IGV4cG9ydHMuUEFXTiwgY29sb3I6IHRoZW0gfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZWd1bGFyIGNhcHR1cmVcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldChtb3ZlLnRvLCB7IHR5cGU6IG1vdmUuY2FwdHVyZWQsIGNvbG9yOiB0aGVtIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtb3ZlLmZsYWdzICYgKEJJVFMuS1NJREVfQ0FTVExFIHwgQklUUy5RU0lERV9DQVNUTEUpKSB7XHJcbiAgICAgICAgICAgIGxldCBjYXN0bGluZ1RvLCBjYXN0bGluZ0Zyb207XHJcbiAgICAgICAgICAgIGlmIChtb3ZlLmZsYWdzICYgQklUUy5LU0lERV9DQVNUTEUpIHtcclxuICAgICAgICAgICAgICAgIGNhc3RsaW5nVG8gPSBtb3ZlLnRvICsgMTtcclxuICAgICAgICAgICAgICAgIGNhc3RsaW5nRnJvbSA9IG1vdmUudG8gLSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2FzdGxpbmdUbyA9IG1vdmUudG8gLSAyO1xyXG4gICAgICAgICAgICAgICAgY2FzdGxpbmdGcm9tID0gbW92ZS50byArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbW92ZVBpZWNlKGNhc3RsaW5nRnJvbSwgY2FzdGxpbmdUbyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtb3ZlO1xyXG4gICAgfVxyXG4gICAgcGduKHsgbmV3bGluZSA9ICdcXG4nLCBtYXhXaWR0aCA9IDAsIH0gPSB7fSkge1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogdXNpbmcgdGhlIHNwZWNpZmljYXRpb24gZnJvbSBodHRwOi8vd3d3LmNoZXNzY2x1Yi5jb20vaGVscC9QR04tc3BlY1xyXG4gICAgICAgICAqIGV4YW1wbGUgZm9yIGh0bWwgdXNhZ2U6IC5wZ24oeyBtYXhfd2lkdGg6IDcyLCBuZXdsaW5lX2NoYXI6IFwiPGJyIC8+XCIgfSlcclxuICAgICAgICAgKi9cclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICBsZXQgaGVhZGVyRXhpc3RzID0gZmFsc2U7XHJcbiAgICAgICAgLyogYWRkIHRoZSBQR04gaGVhZGVyIGluZm9ybWF0aW9uICovXHJcbiAgICAgICAgZm9yIChjb25zdCBpIGluIHRoaXMuX2hlYWRlcikge1xyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgKiBUT0RPOiBvcmRlciBvZiBlbnVtZXJhdGVkIHByb3BlcnRpZXMgaW4gaGVhZGVyIG9iamVjdCBpcyBub3RcclxuICAgICAgICAgICAgICogZ3VhcmFudGVlZCwgc2VlIEVDTUEtMjYyIHNwZWMgKHNlY3Rpb24gMTIuNi40KVxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBCeSB1c2luZyBIRUFERVJfVEVNUExBVEUsIHRoZSBvcmRlciBvZiB0YWdzIHNob3VsZCBiZSBwcmVzZXJ2ZWQ7IHdlXHJcbiAgICAgICAgICAgICAqIGRvIGhhdmUgdG8gY2hlY2sgZm9yIG51bGwgcGxhY2Vob2xkZXJzLCB0aG91Z2gsIGFuZCBvbWl0IHRoZW1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclRhZyA9IHRoaXMuX2hlYWRlcltpXTtcclxuICAgICAgICAgICAgaWYgKGhlYWRlclRhZylcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGBbJHtpfSBcIiR7dGhpcy5faGVhZGVyW2ldfVwiXWAgKyBuZXdsaW5lKTtcclxuICAgICAgICAgICAgaGVhZGVyRXhpc3RzID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhlYWRlckV4aXN0cyAmJiB0aGlzLl9oaXN0b3J5Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYXBwZW5kQ29tbWVudCA9IChtb3ZlU3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbW1lbnQgPSB0aGlzLl9jb21tZW50c1t0aGlzLmZlbigpXTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb21tZW50ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGVsaW1pdGVyID0gbW92ZVN0cmluZy5sZW5ndGggPiAwID8gJyAnIDogJyc7XHJcbiAgICAgICAgICAgICAgICBtb3ZlU3RyaW5nID0gYCR7bW92ZVN0cmluZ30ke2RlbGltaXRlcn17JHtjb21tZW50fX1gO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtb3ZlU3RyaW5nO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gcG9wIGFsbCBvZiBoaXN0b3J5IG9udG8gcmV2ZXJzZWRfaGlzdG9yeVxyXG4gICAgICAgIGNvbnN0IHJldmVyc2VkSGlzdG9yeSA9IFtdO1xyXG4gICAgICAgIHdoaWxlICh0aGlzLl9oaXN0b3J5Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgcmV2ZXJzZWRIaXN0b3J5LnB1c2godGhpcy5fdW5kb01vdmUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG1vdmVzID0gW107XHJcbiAgICAgICAgbGV0IG1vdmVTdHJpbmcgPSAnJztcclxuICAgICAgICAvLyBzcGVjaWFsIGNhc2Ugb2YgYSBjb21tZW50ZWQgc3RhcnRpbmcgcG9zaXRpb24gd2l0aCBubyBtb3Zlc1xyXG4gICAgICAgIGlmIChyZXZlcnNlZEhpc3RvcnkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIG1vdmVzLnB1c2goYXBwZW5kQ29tbWVudCgnJykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBidWlsZCB0aGUgbGlzdCBvZiBtb3Zlcy4gIGEgbW92ZV9zdHJpbmcgbG9va3MgbGlrZTogXCIzLiBlMyBlNlwiXHJcbiAgICAgICAgd2hpbGUgKHJldmVyc2VkSGlzdG9yeS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIG1vdmVTdHJpbmcgPSBhcHBlbmRDb21tZW50KG1vdmVTdHJpbmcpO1xyXG4gICAgICAgICAgICBjb25zdCBtb3ZlID0gcmV2ZXJzZWRIaXN0b3J5LnBvcCgpO1xyXG4gICAgICAgICAgICAvLyBtYWtlIFR5cGVTY3JpcHQgc3RvcCBjb21wbGFpbmluZyBhYm91dCBtb3ZlIGJlaW5nIHVuZGVmaW5lZFxyXG4gICAgICAgICAgICBpZiAoIW1vdmUpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwb3NpdGlvbiBzdGFydGVkIHdpdGggYmxhY2sgdG8gbW92ZSwgc3RhcnQgUEdOIHdpdGggIy4gLi4uXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5faGlzdG9yeS5sZW5ndGggJiYgbW92ZS5jb2xvciA9PT0gJ2InKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVmaXggPSBgJHt0aGlzLl9tb3ZlTnVtYmVyfS4gLi4uYDtcclxuICAgICAgICAgICAgICAgIC8vIGlzIHRoZXJlIGEgY29tbWVudCBwcmVjZWRpbmcgdGhlIGZpcnN0IG1vdmU/XHJcbiAgICAgICAgICAgICAgICBtb3ZlU3RyaW5nID0gbW92ZVN0cmluZyA/IGAke21vdmVTdHJpbmd9ICR7cHJlZml4fWAgOiBwcmVmaXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobW92ZS5jb2xvciA9PT0gJ3cnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzdG9yZSB0aGUgcHJldmlvdXMgZ2VuZXJhdGVkIG1vdmVfc3RyaW5nIGlmIHdlIGhhdmUgb25lXHJcbiAgICAgICAgICAgICAgICBpZiAobW92ZVN0cmluZy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBtb3Zlcy5wdXNoKG1vdmVTdHJpbmcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbW92ZVN0cmluZyA9IHRoaXMuX21vdmVOdW1iZXIgKyAnLic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbW92ZVN0cmluZyA9XHJcbiAgICAgICAgICAgICAgICBtb3ZlU3RyaW5nICsgJyAnICsgdGhpcy5fbW92ZVRvU2FuKG1vdmUsIHRoaXMuX21vdmVzKHsgbGVnYWw6IHRydWUgfSkpO1xyXG4gICAgICAgICAgICB0aGlzLl9tYWtlTW92ZShtb3ZlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYXJlIHRoZXJlIGFueSBvdGhlciBsZWZ0b3ZlciBtb3Zlcz9cclxuICAgICAgICBpZiAobW92ZVN0cmluZy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgbW92ZXMucHVzaChhcHBlbmRDb21tZW50KG1vdmVTdHJpbmcpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaXMgdGhlcmUgYSByZXN1bHQ/ICh0aGVyZSBBTFdBWVMgaGFzIHRvIGJlIGEgcmVzdWx0IGFjY29yZGluZyB0byBzcGVjOyBzZWUgU2V2ZW4gVGFnIFJvc3RlcilcclxuICAgICAgICBtb3Zlcy5wdXNoKHRoaXMuX2hlYWRlci5SZXN1bHQgfHwgJyonKTtcclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIGhpc3Rvcnkgc2hvdWxkIGJlIGJhY2sgdG8gd2hhdCBpdCB3YXMgYmVmb3JlIHdlIHN0YXJ0ZWQgZ2VuZXJhdGluZyBQR04sXHJcbiAgICAgICAgICogc28gam9pbiB0b2dldGhlciBtb3Zlc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlmIChtYXhXaWR0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpICsgbW92ZXMuam9pbignICcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPIChqYWgpOiBodWg/XHJcbiAgICAgICAgY29uc3Qgc3RyaXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID09PSAnICcpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wb3AoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIE5COiB0aGlzIGRvZXMgbm90IHByZXNlcnZlIGNvbW1lbnQgd2hpdGVzcGFjZS5cclxuICAgICAgICBjb25zdCB3cmFwQ29tbWVudCA9IGZ1bmN0aW9uICh3aWR0aCwgbW92ZSkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIG1vdmUuc3BsaXQoJyAnKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0b2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoICsgdG9rZW4ubGVuZ3RoID4gbWF4V2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyaXAoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aC0tO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0b2tlbik7XHJcbiAgICAgICAgICAgICAgICB3aWR0aCArPSB0b2tlbi5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnICcpO1xyXG4gICAgICAgICAgICAgICAgd2lkdGgrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3RyaXAoKSkge1xyXG4gICAgICAgICAgICAgICAgd2lkdGgtLTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gd2lkdGg7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyB3cmFwIHRoZSBQR04gb3V0cHV0IGF0IG1heF93aWR0aFxyXG4gICAgICAgIGxldCBjdXJyZW50V2lkdGggPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW92ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRXaWR0aCArIG1vdmVzW2ldLmxlbmd0aCA+IG1heFdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobW92ZXNbaV0uaW5jbHVkZXMoJ3snKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRXaWR0aCA9IHdyYXBDb21tZW50KGN1cnJlbnRXaWR0aCwgbW92ZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IG1vdmUgd2lsbCBwdXNoIHBhc3QgbWF4X3dpZHRoXHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50V2lkdGggKyBtb3Zlc1tpXS5sZW5ndGggPiBtYXhXaWR0aCAmJiBpICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBlbmQgdGhlIGxpbmUgd2l0aCB3aGl0ZXNwYWNlXHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9PT0gJyAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50V2lkdGggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGkgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcgJyk7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50V2lkdGgrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHQucHVzaChtb3Zlc1tpXSk7XHJcbiAgICAgICAgICAgIGN1cnJlbnRXaWR0aCArPSBtb3Zlc1tpXS5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgc2V0SGVhZGVyYCBhbmQgYGdldEhlYWRlcnNgIGluc3RlYWQuIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIG51bGwgaGVhZGVyIHRhZ3MgKHdoaWNoIGlzIG5vdCB3aGF0IHlvdSB3YW50KVxyXG4gICAgICovXHJcbiAgICBoZWFkZXIoLi4uYXJncykge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3NbaV0gPT09ICdzdHJpbmcnICYmIHR5cGVvZiBhcmdzW2kgKyAxXSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hlYWRlclthcmdzW2ldXSA9IGFyZ3NbaSArIDFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXI7XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPOiB2YWx1ZSB2YWxpZGF0aW9uIHBlciBzcGVjXHJcbiAgICBzZXRIZWFkZXIoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2hlYWRlcltrZXldID0gdmFsdWUgPz8gZXhwb3J0cy5TRVZFTl9UQUdfUk9TVEVSW2tleV0gPz8gbnVsbDtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRIZWFkZXJzKCk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVIZWFkZXIoa2V5KSB7XHJcbiAgICAgICAgaWYgKGtleSBpbiB0aGlzLl9oZWFkZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5faGVhZGVyW2tleV0gPSBleHBvcnRzLlNFVkVOX1RBR19ST1NURVJba2V5XSB8fCBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gcmV0dXJuIG9ubHkgbm9uLW51bGwgaGVhZGVycyAob21pdCBwbGFjZW1hcmtlciBudWxscylcclxuICAgIGdldEhlYWRlcnMoKSB7XHJcbiAgICAgICAgY29uc3Qgbm9uTnVsbEhlYWRlcnMgPSB7fTtcclxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLl9oZWFkZXIpKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgbm9uTnVsbEhlYWRlcnNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub25OdWxsSGVhZGVycztcclxuICAgIH1cclxuICAgIGxvYWRQZ24ocGduLCB7IHN0cmljdCA9IGZhbHNlLCBuZXdsaW5lQ2hhciA9ICdcXHI/XFxuJywgfSA9IHt9KSB7XHJcbiAgICAgICAgLy8gSWYgbmV3bGluZUNoYXIgaXMgbm90IHRoZSBkZWZhdWx0LCByZXBsYWNlIGFsbCBpbnN0YW5jZXMgd2l0aCBcXG5cclxuICAgICAgICBpZiAobmV3bGluZUNoYXIgIT09ICdcXHI/XFxuJykge1xyXG4gICAgICAgICAgICBwZ24gPSBwZ24ucmVwbGFjZShuZXcgUmVnRXhwKG5ld2xpbmVDaGFyLCAnZycpLCAnXFxuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBhcnNlZFBnbiA9ICgwLCBwZ25fMS5wYXJzZSkocGduKTtcclxuICAgICAgICAvLyBQdXQgdGhlIGJvYXJkIGluIHRoZSBzdGFydGluZyBwb3NpdGlvblxyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICAvLyBwYXJzZSBQR04gaGVhZGVyXHJcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHBhcnNlZFBnbi5oZWFkZXJzO1xyXG4gICAgICAgIGxldCBmZW4gPSAnJztcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBoZWFkZXJzKSB7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIHRvIHNlZSB1c2VyIGlzIGluY2x1ZGluZyBmZW4gKHBvc3NpYmx5IHdpdGggd3JvbmcgdGFnIGNhc2UpXHJcbiAgICAgICAgICAgIGlmIChrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2ZlbicpIHtcclxuICAgICAgICAgICAgICAgIGZlbiA9IGhlYWRlcnNba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmhlYWRlcihrZXksIGhlYWRlcnNba2V5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogdGhlIHBlcm1pc3NpdmUgcGFyc2VyIHNob3VsZCBhdHRlbXB0IHRvIGxvYWQgYSBmZW4gdGFnLCBldmVuIGlmIGl0J3MgdGhlXHJcbiAgICAgICAgICogd3JvbmcgY2FzZSBhbmQgZG9lc24ndCBpbmNsdWRlIGEgY29ycmVzcG9uZGluZyBbU2V0VXAgXCIxXCJdIHRhZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlmICghc3RyaWN0KSB7XHJcbiAgICAgICAgICAgIGlmIChmZW4pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9hZChmZW4sIHsgcHJlc2VydmVIZWFkZXJzOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgKiBzdHJpY3QgcGFyc2VyIC0gbG9hZCB0aGUgc3RhcnRpbmcgcG9zaXRpb24gaW5kaWNhdGVkIGJ5IFtTZXR1cCAnMSddXHJcbiAgICAgICAgICAgICAqIGFuZCBbRkVOIHBvc2l0aW9uXVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaWYgKGhlYWRlcnNbJ1NldFVwJ10gPT09ICcxJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoJ0ZFTicgaW4gaGVhZGVycykpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUEdOOiBGRU4gdGFnIG11c3QgYmUgc3VwcGxpZWQgd2l0aCBTZXRVcCB0YWcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGRvbid0IGNsZWFyIHRoZSBoZWFkZXJzIHdoZW4gbG9hZGluZ1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkKGhlYWRlcnNbJ0ZFTiddLCB7IHByZXNlcnZlSGVhZGVyczogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbm9kZSA9IHBhcnNlZFBnbi5yb290O1xyXG4gICAgICAgIHdoaWxlIChub2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLm1vdmUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1vdmUgPSB0aGlzLl9tb3ZlRnJvbVNhbihub2RlLm1vdmUsIHN0cmljdCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobW92ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1vdmUgaW4gUEdOOiAke25vZGUubW92ZX1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21ha2VNb3ZlKG1vdmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luY1Bvc2l0aW9uQ291bnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobm9kZS5jb21tZW50ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbW1lbnRzW3RoaXMuZmVuKCldID0gbm9kZS5jb21tZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnZhcmlhdGlvbnNbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUGVyIHNlY3Rpb24gOC4yLjYgb2YgdGhlIFBHTiBzcGVjLCB0aGUgUmVzdWx0IHRhZyBwYWlyIG11c3QgbWF0Y2ggbWF0Y2hcclxuICAgICAgICAgKiB0aGUgdGVybWluYXRpb24gbWFya2VyLiBPbmx5IGRvIHRoaXMgd2hlbiBoZWFkZXJzIGFyZSBwcmVzZW50LCBidXQgdGhlXHJcbiAgICAgICAgICogcmVzdWx0IHRhZyBpcyBtaXNzaW5nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VkUGduLnJlc3VsdDtcclxuICAgICAgICBpZiAocmVzdWx0ICYmXHJcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2hlYWRlcikubGVuZ3RoICYmXHJcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlclsnUmVzdWx0J10gIT09IHJlc3VsdCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldEhlYWRlcignUmVzdWx0JywgcmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgICogQ29udmVydCBhIG1vdmUgZnJvbSAweDg4IGNvb3JkaW5hdGVzIHRvIFN0YW5kYXJkIEFsZ2VicmFpYyBOb3RhdGlvblxyXG4gICAgICogKFNBTilcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0cmljdCBVc2UgdGhlIHN0cmljdCBTQU4gcGFyc2VyLiBJdCB3aWxsIHRocm93IGVycm9yc1xyXG4gICAgICogb24gb3Zlcmx5IGRpc2FtYmlndWF0ZWQgbW92ZXMgKHNlZSBiZWxvdyk6XHJcbiAgICAgKlxyXG4gICAgICogcjFicWtibnIvcHBwMnBwcC8ybjUvMUIxcFAzLzRQMy84L1BQUFAyUFAvUk5CUUsxTlIgYiBLUWtxIC0gMiA0XHJcbiAgICAgKiA0LiAuLi4gTmdlNyBpcyBvdmVybHkgZGlzYW1iaWd1YXRlZCBiZWNhdXNlIHRoZSBrbmlnaHQgb24gYzYgaXMgcGlubmVkXHJcbiAgICAgKiA0LiAuLi4gTmU3IGlzIHRlY2huaWNhbGx5IHRoZSB2YWxpZCBTQU5cclxuICAgICAqL1xyXG4gICAgX21vdmVUb1Nhbihtb3ZlLCBtb3Zlcykge1xyXG4gICAgICAgIGxldCBvdXRwdXQgPSAnJztcclxuICAgICAgICBpZiAobW92ZS5mbGFncyAmIEJJVFMuS1NJREVfQ0FTVExFKSB7XHJcbiAgICAgICAgICAgIG91dHB1dCA9ICdPLU8nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChtb3ZlLmZsYWdzICYgQklUUy5RU0lERV9DQVNUTEUpIHtcclxuICAgICAgICAgICAgb3V0cHV0ID0gJ08tTy1PJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChtb3ZlLnBpZWNlICE9PSBleHBvcnRzLlBBV04pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRpc2FtYmlndWF0b3IgPSBnZXREaXNhbWJpZ3VhdG9yKG1vdmUsIG1vdmVzKTtcclxuICAgICAgICAgICAgICAgIG91dHB1dCArPSBtb3ZlLnBpZWNlLnRvVXBwZXJDYXNlKCkgKyBkaXNhbWJpZ3VhdG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtb3ZlLmZsYWdzICYgKEJJVFMuQ0FQVFVSRSB8IEJJVFMuRVBfQ0FQVFVSRSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtb3ZlLnBpZWNlID09PSBleHBvcnRzLlBBV04pIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gYWxnZWJyYWljKG1vdmUuZnJvbSlbMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gJ3gnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG91dHB1dCArPSBhbGdlYnJhaWMobW92ZS50byk7XHJcbiAgICAgICAgICAgIGlmIChtb3ZlLnByb21vdGlvbikge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9ICc9JyArIG1vdmUucHJvbW90aW9uLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbWFrZU1vdmUobW92ZSk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNDaGVjaygpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ2hlY2ttYXRlKCkpIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dCArPSAnIyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gJysnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3VuZG9Nb3ZlKCk7XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH1cclxuICAgIC8vIGNvbnZlcnQgYSBtb3ZlIGZyb20gU3RhbmRhcmQgQWxnZWJyYWljIE5vdGF0aW9uIChTQU4pIHRvIDB4ODggY29vcmRpbmF0ZXNcclxuICAgIF9tb3ZlRnJvbVNhbihtb3ZlLCBzdHJpY3QgPSBmYWxzZSkge1xyXG4gICAgICAgIC8vIHN0cmlwIG9mZiBhbnkgbW92ZSBkZWNvcmF0aW9uczogZS5nIE5mMys/ISBiZWNvbWVzIE5mM1xyXG4gICAgICAgIGxldCBjbGVhbk1vdmUgPSBzdHJpcHBlZFNhbihtb3ZlKTtcclxuICAgICAgICBpZiAoIXN0cmljdCkge1xyXG4gICAgICAgICAgICBpZiAoY2xlYW5Nb3ZlID09PSAnMC0wJykge1xyXG4gICAgICAgICAgICAgICAgY2xlYW5Nb3ZlID0gJ08tTyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2xlYW5Nb3ZlID09PSAnMC0wLTAnKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhbk1vdmUgPSAnTy1PLU8nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBwaWVjZVR5cGUgPSBpbmZlclBpZWNlVHlwZShjbGVhbk1vdmUpO1xyXG4gICAgICAgIGxldCBtb3ZlcyA9IHRoaXMuX21vdmVzKHsgbGVnYWw6IHRydWUsIHBpZWNlOiBwaWVjZVR5cGUgfSk7XHJcbiAgICAgICAgLy8gc3RyaWN0IHBhcnNlclxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBtb3Zlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoY2xlYW5Nb3ZlID09PSBzdHJpcHBlZFNhbih0aGlzLl9tb3ZlVG9TYW4obW92ZXNbaV0sIG1vdmVzKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtb3Zlc1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0aGUgc3RyaWN0IHBhcnNlciBmYWlsZWRcclxuICAgICAgICBpZiAoc3RyaWN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcGllY2UgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgbGV0IG1hdGNoZXMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgbGV0IGZyb20gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgbGV0IHRvID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGxldCBwcm9tb3Rpb24gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBwZXJtaXNzaXZlIChub24tc3RyaWN0KSBwYXJzZXIgYWxsb3dzIHRoZSB1c2VyIHRvIHBhcnNlXHJcbiAgICAgICAgICogbm9uLXN0YW5kYXJkIGNoZXNzIG5vdGF0aW9ucy4gVGhpcyBwYXJzZXIgaXMgb25seSBydW4gYWZ0ZXIgdGhlIHN0cmljdFxyXG4gICAgICAgICAqIFN0YW5kYXJkIEFsZ2VicmFpYyBOb3RhdGlvbiAoU0FOKSBwYXJzZXIgaGFzIGZhaWxlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFdoZW4gcnVubmluZyB0aGUgcGVybWlzc2l2ZSBwYXJzZXIsIHdlJ2xsIHJ1biBhIHJlZ2V4IHRvIGdyYWIgdGhlIHBpZWNlLCB0aGVcclxuICAgICAgICAgKiB0by9mcm9tIHNxdWFyZSwgYW5kIGFuIG9wdGlvbmFsIHByb21vdGlvbiBwaWVjZS4gVGhpcyByZWdleCB3aWxsXHJcbiAgICAgICAgICogcGFyc2UgY29tbW9uIG5vbi1zdGFuZGFyZCBub3RhdGlvbiBsaWtlOiBQZTItZTQsIFJjMWM0LCBRZjN4ZjcsXHJcbiAgICAgICAgICogZjdmOHEsIGIxYzNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIE5PVEU6IFNvbWUgcG9zaXRpb25zIGFuZCBtb3ZlcyBtYXkgYmUgYW1iaWd1b3VzIHdoZW4gdXNpbmcgdGhlIHBlcm1pc3NpdmVcclxuICAgICAgICAgKiBwYXJzZXIuIEZvciBleGFtcGxlLCBpbiB0aGlzIHBvc2l0aW9uOiA2azEvOC84L0I3LzgvOC84L0JONEsxIHcgLSAtIDAgMSxcclxuICAgICAgICAgKiB0aGUgbW92ZSBiMWMzIG1heSBiZSBpbnRlcnByZXRlZCBhcyBOYzMgb3IgQjFjMyAoYSBkaXNhbWJpZ3VhdGVkIGJpc2hvcFxyXG4gICAgICAgICAqIG1vdmUpLiBJbiB0aGVzZSBjYXNlcywgdGhlIHBlcm1pc3NpdmUgcGFyc2VyIHdpbGwgZGVmYXVsdCB0byB0aGUgbW9zdFxyXG4gICAgICAgICAqIGJhc2ljIGludGVycHJldGF0aW9uICh3aGljaCBpcyBiMWMzIHBhcnNpbmcgdG8gTmMzKS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBsZXQgb3Zlcmx5RGlzYW1iaWd1YXRlZCA9IGZhbHNlO1xyXG4gICAgICAgIG1hdGNoZXMgPSBjbGVhbk1vdmUubWF0Y2goLyhbcG5icnFrUE5CUlFLXSk/KFthLWhdWzEtOF0peD8tPyhbYS1oXVsxLThdKShbcXJiblFSQk5dKT8vKTtcclxuICAgICAgICBpZiAobWF0Y2hlcykge1xyXG4gICAgICAgICAgICBwaWVjZSA9IG1hdGNoZXNbMV07XHJcbiAgICAgICAgICAgIGZyb20gPSBtYXRjaGVzWzJdO1xyXG4gICAgICAgICAgICB0byA9IG1hdGNoZXNbM107XHJcbiAgICAgICAgICAgIHByb21vdGlvbiA9IG1hdGNoZXNbNF07XHJcbiAgICAgICAgICAgIGlmIChmcm9tLmxlbmd0aCA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBvdmVybHlEaXNhbWJpZ3VhdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICogVGhlIFthLWhdP1sxLThdPyBwb3J0aW9uIG9mIHRoZSByZWdleCBiZWxvdyBoYW5kbGVzIG1vdmVzIHRoYXQgbWF5IGJlXHJcbiAgICAgICAgICAgICAqIG92ZXJseSBkaXNhbWJpZ3VhdGVkIChlLmcuIE5nZTcgaXMgdW5uZWNlc3NhcnkgYW5kIG5vbi1zdGFuZGFyZCB3aGVuXHJcbiAgICAgICAgICAgICAqIHRoZXJlIGlzIG9uZSBsZWdhbCBrbmlnaHQgbW92ZSB0byBlNykuIEluIHRoaXMgY2FzZSwgdGhlIHZhbHVlIG9mXHJcbiAgICAgICAgICAgICAqICdmcm9tJyB2YXJpYWJsZSB3aWxsIGJlIGEgcmFuayBvciBmaWxlLCBub3QgYSBzcXVhcmUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBtYXRjaGVzID0gY2xlYW5Nb3ZlLm1hdGNoKC8oW3BuYnJxa1BOQlJRS10pPyhbYS1oXT9bMS04XT8peD8tPyhbYS1oXVsxLThdKShbcXJiblFSQk5dKT8vKTtcclxuICAgICAgICAgICAgaWYgKG1hdGNoZXMpIHtcclxuICAgICAgICAgICAgICAgIHBpZWNlID0gbWF0Y2hlc1sxXTtcclxuICAgICAgICAgICAgICAgIGZyb20gPSBtYXRjaGVzWzJdO1xyXG4gICAgICAgICAgICAgICAgdG8gPSBtYXRjaGVzWzNdO1xyXG4gICAgICAgICAgICAgICAgcHJvbW90aW9uID0gbWF0Y2hlc1s0XTtcclxuICAgICAgICAgICAgICAgIGlmIChmcm9tLmxlbmd0aCA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3Zlcmx5RGlzYW1iaWd1YXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcGllY2VUeXBlID0gaW5mZXJQaWVjZVR5cGUoY2xlYW5Nb3ZlKTtcclxuICAgICAgICBtb3ZlcyA9IHRoaXMuX21vdmVzKHtcclxuICAgICAgICAgICAgbGVnYWw6IHRydWUsXHJcbiAgICAgICAgICAgIHBpZWNlOiBwaWVjZSA/IHBpZWNlIDogcGllY2VUeXBlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICghdG8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBtb3Zlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoIWZyb20pIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGZyb20gc3F1YXJlLCBpdCBjb3VsZCBiZSBqdXN0ICd4JyBtaXNzaW5nIGZyb20gYSBjYXB0dXJlXHJcbiAgICAgICAgICAgICAgICBpZiAoY2xlYW5Nb3ZlID09PVxyXG4gICAgICAgICAgICAgICAgICAgIHN0cmlwcGVkU2FuKHRoaXMuX21vdmVUb1Nhbihtb3Zlc1tpXSwgbW92ZXMpKS5yZXBsYWNlKCd4JywgJycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vdmVzW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gaGFuZC1jb21wYXJlIG1vdmUgcHJvcGVydGllcyB3aXRoIHRoZSByZXN1bHRzIGZyb20gb3VyIHBlcm1pc3NpdmUgcmVnZXhcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgoIXBpZWNlIHx8IHBpZWNlLnRvTG93ZXJDYXNlKCkgPT0gbW92ZXNbaV0ucGllY2UpICYmXHJcbiAgICAgICAgICAgICAgICBPeDg4W2Zyb21dID09IG1vdmVzW2ldLmZyb20gJiZcclxuICAgICAgICAgICAgICAgIE94ODhbdG9dID09IG1vdmVzW2ldLnRvICYmXHJcbiAgICAgICAgICAgICAgICAoIXByb21vdGlvbiB8fCBwcm9tb3Rpb24udG9Mb3dlckNhc2UoKSA9PSBtb3Zlc1tpXS5wcm9tb3Rpb24pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbW92ZXNbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob3Zlcmx5RGlzYW1iaWd1YXRlZCkge1xyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAqIFNQRUNJQUwgQ0FTRTogd2UgcGFyc2VkIGEgbW92ZSBzdHJpbmcgdGhhdCBtYXkgaGF2ZSBhbiB1bm5lZWRlZFxyXG4gICAgICAgICAgICAgICAgICogcmFuay9maWxlIGRpc2FtYmlndWF0b3IgKGUuZy4gTmdlNykuICBUaGUgJ2Zyb20nIHZhcmlhYmxlIHdpbGxcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3F1YXJlID0gYWxnZWJyYWljKG1vdmVzW2ldLmZyb20pO1xyXG4gICAgICAgICAgICAgICAgaWYgKCghcGllY2UgfHwgcGllY2UudG9Mb3dlckNhc2UoKSA9PSBtb3Zlc1tpXS5waWVjZSkgJiZcclxuICAgICAgICAgICAgICAgICAgICBPeDg4W3RvXSA9PSBtb3Zlc1tpXS50byAmJlxyXG4gICAgICAgICAgICAgICAgICAgIChmcm9tID09IHNxdWFyZVswXSB8fCBmcm9tID09IHNxdWFyZVsxXSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAoIXByb21vdGlvbiB8fCBwcm9tb3Rpb24udG9Mb3dlckNhc2UoKSA9PSBtb3Zlc1tpXS5wcm9tb3Rpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vdmVzW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgYXNjaWkoKSB7XHJcbiAgICAgICAgbGV0IHMgPSAnICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcXG4nO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBPeDg4LmE4OyBpIDw9IE94ODguaDE7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBkaXNwbGF5IHRoZSByYW5rXHJcbiAgICAgICAgICAgIGlmIChmaWxlKGkpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBzICs9ICcgJyArICc4NzY1NDMyMSdbcmFuayhpKV0gKyAnIHwnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9ib2FyZFtpXSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGllY2UgPSB0aGlzLl9ib2FyZFtpXS50eXBlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3IgPSB0aGlzLl9ib2FyZFtpXS5jb2xvcjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN5bWJvbCA9IGNvbG9yID09PSBleHBvcnRzLldISVRFID8gcGllY2UudG9VcHBlckNhc2UoKSA6IHBpZWNlLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICBzICs9ICcgJyArIHN5bWJvbCArICcgJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHMgKz0gJyAuICc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChpICsgMSkgJiAweDg4KSB7XHJcbiAgICAgICAgICAgICAgICBzICs9ICd8XFxuJztcclxuICAgICAgICAgICAgICAgIGkgKz0gODtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzICs9ICcgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xcbic7XHJcbiAgICAgICAgcyArPSAnICAgICBhICBiICBjICBkICBlICBmICBnICBoJztcclxuICAgICAgICByZXR1cm4gcztcclxuICAgIH1cclxuICAgIHBlcmZ0KGRlcHRoKSB7XHJcbiAgICAgICAgY29uc3QgbW92ZXMgPSB0aGlzLl9tb3Zlcyh7IGxlZ2FsOiBmYWxzZSB9KTtcclxuICAgICAgICBsZXQgbm9kZXMgPSAwO1xyXG4gICAgICAgIGNvbnN0IGNvbG9yID0gdGhpcy5fdHVybjtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbW92ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5fbWFrZU1vdmUobW92ZXNbaV0pO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzS2luZ0F0dGFja2VkKGNvbG9yKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoIC0gMSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlcyArPSB0aGlzLnBlcmZ0KGRlcHRoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlcysrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3VuZG9Nb3ZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlcztcclxuICAgIH1cclxuICAgIHR1cm4oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R1cm47XHJcbiAgICB9XHJcbiAgICBib2FyZCgpIHtcclxuICAgICAgICBjb25zdCBvdXRwdXQgPSBbXTtcclxuICAgICAgICBsZXQgcm93ID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IE94ODguYTg7IGkgPD0gT3g4OC5oMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9ib2FyZFtpXSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByb3cucHVzaChudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJvdy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBzcXVhcmU6IGFsZ2VicmFpYyhpKSxcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLl9ib2FyZFtpXS50eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiB0aGlzLl9ib2FyZFtpXS5jb2xvcixcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgoaSArIDEpICYgMHg4OCkge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gocm93KTtcclxuICAgICAgICAgICAgICAgIHJvdyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgaSArPSA4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9XHJcbiAgICBzcXVhcmVDb2xvcihzcXVhcmUpIHtcclxuICAgICAgICBpZiAoc3F1YXJlIGluIE94ODgpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3EgPSBPeDg4W3NxdWFyZV07XHJcbiAgICAgICAgICAgIHJldHVybiAocmFuayhzcSkgKyBmaWxlKHNxKSkgJSAyID09PSAwID8gJ2xpZ2h0JyA6ICdkYXJrJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBoaXN0b3J5KHsgdmVyYm9zZSA9IGZhbHNlIH0gPSB7fSkge1xyXG4gICAgICAgIGNvbnN0IHJldmVyc2VkSGlzdG9yeSA9IFtdO1xyXG4gICAgICAgIGNvbnN0IG1vdmVIaXN0b3J5ID0gW107XHJcbiAgICAgICAgd2hpbGUgKHRoaXMuX2hpc3RvcnkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICByZXZlcnNlZEhpc3RvcnkucHVzaCh0aGlzLl91bmRvTW92ZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgY29uc3QgbW92ZSA9IHJldmVyc2VkSGlzdG9yeS5wb3AoKTtcclxuICAgICAgICAgICAgaWYgKCFtb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodmVyYm9zZSkge1xyXG4gICAgICAgICAgICAgICAgbW92ZUhpc3RvcnkucHVzaChuZXcgTW92ZSh0aGlzLCBtb3ZlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtb3ZlSGlzdG9yeS5wdXNoKHRoaXMuX21vdmVUb1Nhbihtb3ZlLCB0aGlzLl9tb3ZlcygpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbWFrZU1vdmUobW92ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtb3ZlSGlzdG9yeTtcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICAgKiBLZWVwcyB0cmFjayBvZiBwb3NpdGlvbiBvY2N1cnJlbmNlIGNvdW50cyBmb3IgdGhlIHB1cnBvc2Ugb2YgcmVwZXRpdGlvblxyXG4gICAgICogY2hlY2tpbmcuIE9sZCBwb3NpdGlvbnMgYXJlIHJlbW92ZWQgZnJvbSB0aGUgbWFwIGlmIHRoZWlyIGNvdW50cyBhcmUgcmVkdWNlZCB0byAwLlxyXG4gICAgICovXHJcbiAgICBfZ2V0UG9zaXRpb25Db3VudChoYXNoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uQ291bnQuZ2V0KGhhc2gpID8/IDA7XHJcbiAgICB9XHJcbiAgICBfaW5jUG9zaXRpb25Db3VudCgpIHtcclxuICAgICAgICB0aGlzLl9wb3NpdGlvbkNvdW50LnNldCh0aGlzLl9oYXNoLCAodGhpcy5fcG9zaXRpb25Db3VudC5nZXQodGhpcy5faGFzaCkgPz8gMCkgKyAxKTtcclxuICAgIH1cclxuICAgIF9kZWNQb3NpdGlvbkNvdW50KGhhc2gpIHtcclxuICAgICAgICBjb25zdCBjdXJyZW50Q291bnQgPSB0aGlzLl9wb3NpdGlvbkNvdW50LmdldChoYXNoKSA/PyAwO1xyXG4gICAgICAgIGlmIChjdXJyZW50Q291bnQgPT09IDEpIHtcclxuICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25Db3VudC5kZWxldGUoaGFzaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9wb3NpdGlvbkNvdW50LnNldChoYXNoLCBjdXJyZW50Q291bnQgLSAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfcHJ1bmVDb21tZW50cygpIHtcclxuICAgICAgICBjb25zdCByZXZlcnNlZEhpc3RvcnkgPSBbXTtcclxuICAgICAgICBjb25zdCBjdXJyZW50Q29tbWVudHMgPSB7fTtcclxuICAgICAgICBjb25zdCBjb3B5Q29tbWVudCA9IChmZW4pID0+IHtcclxuICAgICAgICAgICAgaWYgKGZlbiBpbiB0aGlzLl9jb21tZW50cykge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudENvbW1lbnRzW2Zlbl0gPSB0aGlzLl9jb21tZW50c1tmZW5dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB3aGlsZSAodGhpcy5faGlzdG9yeS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHJldmVyc2VkSGlzdG9yeS5wdXNoKHRoaXMuX3VuZG9Nb3ZlKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb3B5Q29tbWVudCh0aGlzLmZlbigpKTtcclxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICBjb25zdCBtb3ZlID0gcmV2ZXJzZWRIaXN0b3J5LnBvcCgpO1xyXG4gICAgICAgICAgICBpZiAoIW1vdmUpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX21ha2VNb3ZlKG1vdmUpO1xyXG4gICAgICAgICAgICBjb3B5Q29tbWVudCh0aGlzLmZlbigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fY29tbWVudHMgPSBjdXJyZW50Q29tbWVudHM7XHJcbiAgICB9XHJcbiAgICBnZXRDb21tZW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb21tZW50c1t0aGlzLmZlbigpXTtcclxuICAgIH1cclxuICAgIHNldENvbW1lbnQoY29tbWVudCkge1xyXG4gICAgICAgIHRoaXMuX2NvbW1lbnRzW3RoaXMuZmVuKCldID0gY29tbWVudC5yZXBsYWNlKCd7JywgJ1snKS5yZXBsYWNlKCd9JywgJ10nKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGRlcHJlY2F0ZWQgUmVuYW1lZCB0byBgcmVtb3ZlQ29tbWVudGAgZm9yIGNvbnNpc3RlbmN5XHJcbiAgICAgKi9cclxuICAgIGRlbGV0ZUNvbW1lbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlQ29tbWVudCgpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlQ29tbWVudCgpIHtcclxuICAgICAgICBjb25zdCBjb21tZW50ID0gdGhpcy5fY29tbWVudHNbdGhpcy5mZW4oKV07XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX2NvbW1lbnRzW3RoaXMuZmVuKCldO1xyXG4gICAgICAgIHJldHVybiBjb21tZW50O1xyXG4gICAgfVxyXG4gICAgZ2V0Q29tbWVudHMoKSB7XHJcbiAgICAgICAgdGhpcy5fcHJ1bmVDb21tZW50cygpO1xyXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9jb21tZW50cykubWFwKChmZW4pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgZmVuOiBmZW4sIGNvbW1lbnQ6IHRoaXMuX2NvbW1lbnRzW2Zlbl0gfTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGRlcHJlY2F0ZWQgUmVuYW1lZCB0byBgcmVtb3ZlQ29tbWVudHNgIGZvciBjb25zaXN0ZW5jeVxyXG4gICAgICovXHJcbiAgICBkZWxldGVDb21tZW50cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVDb21tZW50cygpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlQ29tbWVudHMoKSB7XHJcbiAgICAgICAgdGhpcy5fcHJ1bmVDb21tZW50cygpO1xyXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9jb21tZW50cykubWFwKChmZW4pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY29tbWVudCA9IHRoaXMuX2NvbW1lbnRzW2Zlbl07XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jb21tZW50c1tmZW5dO1xyXG4gICAgICAgICAgICByZXR1cm4geyBmZW46IGZlbiwgY29tbWVudDogY29tbWVudCB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc2V0Q2FzdGxpbmdSaWdodHMoY29sb3IsIHJpZ2h0cykge1xyXG4gICAgICAgIGZvciAoY29uc3Qgc2lkZSBvZiBbZXhwb3J0cy5LSU5HLCBleHBvcnRzLlFVRUVOXSkge1xyXG4gICAgICAgICAgICBpZiAocmlnaHRzW3NpZGVdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyaWdodHNbc2lkZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYXN0bGluZ1tjb2xvcl0gfD0gU0lERVNbc2lkZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYXN0bGluZ1tjb2xvcl0gJj0gflNJREVTW3NpZGVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUNhc3RsaW5nUmlnaHRzKCk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5nZXRDYXN0bGluZ1JpZ2h0cyhjb2xvcik7XHJcbiAgICAgICAgcmV0dXJuICgocmlnaHRzW2V4cG9ydHMuS0lOR10gPT09IHVuZGVmaW5lZCB8fCByaWdodHNbZXhwb3J0cy5LSU5HXSA9PT0gcmVzdWx0W2V4cG9ydHMuS0lOR10pICYmXHJcbiAgICAgICAgICAgIChyaWdodHNbZXhwb3J0cy5RVUVFTl0gPT09IHVuZGVmaW5lZCB8fCByaWdodHNbZXhwb3J0cy5RVUVFTl0gPT09IHJlc3VsdFtleHBvcnRzLlFVRUVOXSkpO1xyXG4gICAgfVxyXG4gICAgZ2V0Q2FzdGxpbmdSaWdodHMoY29sb3IpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBbZXhwb3J0cy5LSU5HXTogKHRoaXMuX2Nhc3RsaW5nW2NvbG9yXSAmIFNJREVTW2V4cG9ydHMuS0lOR10pICE9PSAwLFxyXG4gICAgICAgICAgICBbZXhwb3J0cy5RVUVFTl06ICh0aGlzLl9jYXN0bGluZ1tjb2xvcl0gJiBTSURFU1tleHBvcnRzLlFVRUVOXSkgIT09IDAsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIG1vdmVOdW1iZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vdmVOdW1iZXI7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5DaGVzcyA9IENoZXNzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chess.js/dist/cjs/chess.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chess.js/dist/cjs/pgn.js":
/*!***********************************************!*\
  !*** ./node_modules/chess.js/dist/cjs/pgn.js ***!
  \***********************************************/
/***/ ((module) => {

eval("// @generated by Peggy 4.2.0.\r\n//\r\n// https://peggyjs.org/\r\n\r\n\r\n\r\n\r\n\r\n  function rootNode(comment) {\r\n  \treturn comment !== null ? { comment, variations: [] } : { variations: []}\r\n  }\r\n\r\n  function node(move, suffix, nag, comment, variations) {\r\n  \tconst node = { move, variations }\r\n\r\n    if (suffix) {\r\n    \tnode.suffix = suffix\r\n    }\r\n\r\n    if (nag) {\r\n    \tnode.nag = nag\r\n    }\r\n\r\n    if (comment !== null) {\r\n    \tnode.comment = comment\r\n    }\r\n\r\n    return node\r\n  }\r\n\r\n  function lineToTree(...nodes) {\r\n  \tconst [root, ...rest] = nodes;\r\n\r\n    let parent = root\r\n\r\n    for (const child of rest) {\r\n    \tif (child !== null) {\r\n        \tparent.variations = [child, ...child.variations]\r\n            child.variations = []\r\n            parent = child\r\n        }\r\n    }\r\n\r\n  \treturn root\r\n  }\r\n\r\n  function pgn(headers, game) {\r\n  \tif (game.marker && game.marker.comment) {\r\n    \tlet node = game.root\r\n        while (true) {\r\n        \tconst next = node.variations[0]\r\n            if (!next) {\r\n            \tnode.comment = game.marker.comment\r\n            \tbreak\r\n            }\r\n            node = next\r\n        }\r\n    }\r\n\r\n  \treturn {\r\n    \theaders,\r\n        root: game.root,\r\n        result: (game.marker && game.marker.result) ?? undefined\r\n    }\r\n  }\r\n\r\nfunction peg$subclass(child, parent) {\r\n  function C() { this.constructor = child; }\r\n  C.prototype = parent.prototype;\r\n  child.prototype = new C();\r\n}\r\n\r\nfunction peg$SyntaxError(message, expected, found, location) {\r\n  var self = Error.call(this, message);\r\n  // istanbul ignore next Check is a necessary evil to support older environments\r\n  if (Object.setPrototypeOf) {\r\n    Object.setPrototypeOf(self, peg$SyntaxError.prototype);\r\n  }\r\n  self.expected = expected;\r\n  self.found = found;\r\n  self.location = location;\r\n  self.name = \"SyntaxError\";\r\n  return self;\r\n}\r\n\r\npeg$subclass(peg$SyntaxError, Error);\r\n\r\nfunction peg$padEnd(str, targetLength, padString) {\r\n  padString = padString || \" \";\r\n  if (str.length > targetLength) { return str; }\r\n  targetLength -= str.length;\r\n  padString += padString.repeat(targetLength);\r\n  return str + padString.slice(0, targetLength);\r\n}\r\n\r\npeg$SyntaxError.prototype.format = function(sources) {\r\n  var str = \"Error: \" + this.message;\r\n  if (this.location) {\r\n    var src = null;\r\n    var k;\r\n    for (k = 0; k < sources.length; k++) {\r\n      if (sources[k].source === this.location.source) {\r\n        src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\r\n        break;\r\n      }\r\n    }\r\n    var s = this.location.start;\r\n    var offset_s = (this.location.source && (typeof this.location.source.offset === \"function\"))\r\n      ? this.location.source.offset(s)\r\n      : s;\r\n    var loc = this.location.source + \":\" + offset_s.line + \":\" + offset_s.column;\r\n    if (src) {\r\n      var e = this.location.end;\r\n      var filler = peg$padEnd(\"\", offset_s.line.toString().length, ' ');\r\n      var line = src[s.line - 1];\r\n      var last = s.line === e.line ? e.column : line.length + 1;\r\n      var hatLen = (last - s.column) || 1;\r\n      str += \"\\n --> \" + loc + \"\\n\"\r\n          + filler + \" |\\n\"\r\n          + offset_s.line + \" | \" + line + \"\\n\"\r\n          + filler + \" | \" + peg$padEnd(\"\", s.column - 1, ' ')\r\n          + peg$padEnd(\"\", hatLen, \"^\");\r\n    } else {\r\n      str += \"\\n at \" + loc;\r\n    }\r\n  }\r\n  return str;\r\n};\r\n\r\npeg$SyntaxError.buildMessage = function(expected, found) {\r\n  var DESCRIBE_EXPECTATION_FNS = {\r\n    literal: function(expectation) {\r\n      return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\r\n    },\r\n\r\n    class: function(expectation) {\r\n      var escapedParts = expectation.parts.map(function(part) {\r\n        return Array.isArray(part)\r\n          ? classEscape(part[0]) + \"-\" + classEscape(part[1])\r\n          : classEscape(part);\r\n      });\r\n\r\n      return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\";\r\n    },\r\n\r\n    any: function() {\r\n      return \"any character\";\r\n    },\r\n\r\n    end: function() {\r\n      return \"end of input\";\r\n    },\r\n\r\n    other: function(expectation) {\r\n      return expectation.description;\r\n    }\r\n  };\r\n\r\n  function hex(ch) {\r\n    return ch.charCodeAt(0).toString(16).toUpperCase();\r\n  }\r\n\r\n  function literalEscape(s) {\r\n    return s\r\n      .replace(/\\\\/g, \"\\\\\\\\\")\r\n      .replace(/\"/g,  \"\\\\\\\"\")\r\n      .replace(/\\0/g, \"\\\\0\")\r\n      .replace(/\\t/g, \"\\\\t\")\r\n      .replace(/\\n/g, \"\\\\n\")\r\n      .replace(/\\r/g, \"\\\\r\")\r\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\r\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\r\n  }\r\n\r\n  function classEscape(s) {\r\n    return s\r\n      .replace(/\\\\/g, \"\\\\\\\\\")\r\n      .replace(/\\]/g, \"\\\\]\")\r\n      .replace(/\\^/g, \"\\\\^\")\r\n      .replace(/-/g,  \"\\\\-\")\r\n      .replace(/\\0/g, \"\\\\0\")\r\n      .replace(/\\t/g, \"\\\\t\")\r\n      .replace(/\\n/g, \"\\\\n\")\r\n      .replace(/\\r/g, \"\\\\r\")\r\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\r\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\r\n  }\r\n\r\n  function describeExpectation(expectation) {\r\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\r\n  }\r\n\r\n  function describeExpected(expected) {\r\n    var descriptions = expected.map(describeExpectation);\r\n    var i, j;\r\n\r\n    descriptions.sort();\r\n\r\n    if (descriptions.length > 0) {\r\n      for (i = 1, j = 1; i < descriptions.length; i++) {\r\n        if (descriptions[i - 1] !== descriptions[i]) {\r\n          descriptions[j] = descriptions[i];\r\n          j++;\r\n        }\r\n      }\r\n      descriptions.length = j;\r\n    }\r\n\r\n    switch (descriptions.length) {\r\n      case 1:\r\n        return descriptions[0];\r\n\r\n      case 2:\r\n        return descriptions[0] + \" or \" + descriptions[1];\r\n\r\n      default:\r\n        return descriptions.slice(0, -1).join(\", \")\r\n          + \", or \"\r\n          + descriptions[descriptions.length - 1];\r\n    }\r\n  }\r\n\r\n  function describeFound(found) {\r\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\r\n  }\r\n\r\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\r\n};\r\n\r\nfunction peg$parse(input, options) {\r\n  options = options !== undefined ? options : {};\r\n\r\n  var peg$FAILED = {};\r\n  var peg$source = options.grammarSource;\r\n\r\n  var peg$startRuleFunctions = { pgn: peg$parsepgn };\r\n  var peg$startRuleFunction = peg$parsepgn;\r\n\r\n  var peg$c0 = \"[\";\r\n  var peg$c1 = \"\\\"\";\r\n  var peg$c2 = \"]\";\r\n  var peg$c3 = \".\";\r\n  var peg$c4 = \"O-O-O\";\r\n  var peg$c5 = \"O-O\";\r\n  var peg$c6 = \"0-0-0\";\r\n  var peg$c7 = \"0-0\";\r\n  var peg$c8 = \"$\";\r\n  var peg$c9 = \"{\";\r\n  var peg$c10 = \"}\";\r\n  var peg$c11 = \";\";\r\n  var peg$c12 = \"(\";\r\n  var peg$c13 = \")\";\r\n  var peg$c14 = \"1-0\";\r\n  var peg$c15 = \"0-1\";\r\n  var peg$c16 = \"1/2-1/2\";\r\n  var peg$c17 = \"*\";\r\n\r\n  var peg$r0 = /^[a-zA-Z]/;\r\n  var peg$r1 = /^[^\"]/;\r\n  var peg$r2 = /^[0-9]/;\r\n  var peg$r3 = /^[.]/;\r\n  var peg$r4 = /^[a-zA-Z1-8\\-=]/;\r\n  var peg$r5 = /^[+#]/;\r\n  var peg$r6 = /^[!?]/;\r\n  var peg$r7 = /^[^}]/;\r\n  var peg$r8 = /^[^\\r\\n]/;\r\n  var peg$r9 = /^[ \\t\\r\\n]/;\r\n\r\n  var peg$e0 = peg$otherExpectation(\"tag pair\");\r\n  var peg$e1 = peg$literalExpectation(\"[\", false);\r\n  var peg$e2 = peg$literalExpectation(\"\\\"\", false);\r\n  var peg$e3 = peg$literalExpectation(\"]\", false);\r\n  var peg$e4 = peg$otherExpectation(\"tag name\");\r\n  var peg$e5 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"]], false, false);\r\n  var peg$e6 = peg$otherExpectation(\"tag value\");\r\n  var peg$e7 = peg$classExpectation([\"\\\"\"], true, false);\r\n  var peg$e8 = peg$otherExpectation(\"move number\");\r\n  var peg$e9 = peg$classExpectation([[\"0\", \"9\"]], false, false);\r\n  var peg$e10 = peg$literalExpectation(\".\", false);\r\n  var peg$e11 = peg$classExpectation([\".\"], false, false);\r\n  var peg$e12 = peg$otherExpectation(\"standard algebraic notation\");\r\n  var peg$e13 = peg$literalExpectation(\"O-O-O\", false);\r\n  var peg$e14 = peg$literalExpectation(\"O-O\", false);\r\n  var peg$e15 = peg$literalExpectation(\"0-0-0\", false);\r\n  var peg$e16 = peg$literalExpectation(\"0-0\", false);\r\n  var peg$e17 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], [\"1\", \"8\"], \"-\", \"=\"], false, false);\r\n  var peg$e18 = peg$classExpectation([\"+\", \"#\"], false, false);\r\n  var peg$e19 = peg$otherExpectation(\"suffix annotation\");\r\n  var peg$e20 = peg$classExpectation([\"!\", \"?\"], false, false);\r\n  var peg$e21 = peg$otherExpectation(\"NAG\");\r\n  var peg$e22 = peg$literalExpectation(\"$\", false);\r\n  var peg$e23 = peg$otherExpectation(\"brace comment\");\r\n  var peg$e24 = peg$literalExpectation(\"{\", false);\r\n  var peg$e25 = peg$classExpectation([\"}\"], true, false);\r\n  var peg$e26 = peg$literalExpectation(\"}\", false);\r\n  var peg$e27 = peg$otherExpectation(\"rest of line comment\");\r\n  var peg$e28 = peg$literalExpectation(\";\", false);\r\n  var peg$e29 = peg$classExpectation([\"\\r\", \"\\n\"], true, false);\r\n  var peg$e30 = peg$otherExpectation(\"variation\");\r\n  var peg$e31 = peg$literalExpectation(\"(\", false);\r\n  var peg$e32 = peg$literalExpectation(\")\", false);\r\n  var peg$e33 = peg$otherExpectation(\"game termination marker\");\r\n  var peg$e34 = peg$literalExpectation(\"1-0\", false);\r\n  var peg$e35 = peg$literalExpectation(\"0-1\", false);\r\n  var peg$e36 = peg$literalExpectation(\"1/2-1/2\", false);\r\n  var peg$e37 = peg$literalExpectation(\"*\", false);\r\n  var peg$e38 = peg$otherExpectation(\"whitespace\");\r\n  var peg$e39 = peg$classExpectation([\" \", \"\\t\", \"\\r\", \"\\n\"], false, false);\r\n\r\n  var peg$f0 = function(headers, game) { return pgn(headers, game) };\r\n  var peg$f1 = function(tagPairs) { return Object.fromEntries(tagPairs) };\r\n  var peg$f2 = function(tagName, tagValue) { return [tagName, tagValue] };\r\n  var peg$f3 = function(root, marker) { return { root, marker} };\r\n  var peg$f4 = function(comment, moves) { return lineToTree(rootNode(comment), ...moves.flat()) };\r\n  var peg$f5 = function(san, suffix, nag, comment, variations) { return node(san, suffix, nag, comment, variations) };\r\n  var peg$f6 = function(nag) { return nag };\r\n  var peg$f7 = function(comment) { return comment.replace(/[\\r\\n]+/g, \" \") };\r\n  var peg$f8 = function(comment) { return comment.trim() };\r\n  var peg$f9 = function(line) { return line };\r\n  var peg$f10 = function(result, comment) { return { result, comment } };\r\n  var peg$currPos = options.peg$currPos | 0;\r\n  var peg$savedPos = peg$currPos;\r\n  var peg$posDetailsCache = [{ line: 1, column: 1 }];\r\n  var peg$maxFailPos = peg$currPos;\r\n  var peg$maxFailExpected = options.peg$maxFailExpected || [];\r\n  var peg$silentFails = options.peg$silentFails | 0;\r\n\r\n  var peg$result;\r\n\r\n  if (options.startRule) {\r\n    if (!(options.startRule in peg$startRuleFunctions)) {\r\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\r\n    }\r\n\r\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\r\n  }\r\n\r\n  function text() {\r\n    return input.substring(peg$savedPos, peg$currPos);\r\n  }\r\n\r\n  function offset() {\r\n    return peg$savedPos;\r\n  }\r\n\r\n  function range() {\r\n    return {\r\n      source: peg$source,\r\n      start: peg$savedPos,\r\n      end: peg$currPos\r\n    };\r\n  }\r\n\r\n  function location() {\r\n    return peg$computeLocation(peg$savedPos, peg$currPos);\r\n  }\r\n\r\n  function expected(description, location) {\r\n    location = location !== undefined\r\n      ? location\r\n      : peg$computeLocation(peg$savedPos, peg$currPos);\r\n\r\n    throw peg$buildStructuredError(\r\n      [peg$otherExpectation(description)],\r\n      input.substring(peg$savedPos, peg$currPos),\r\n      location\r\n    );\r\n  }\r\n\r\n  function error(message, location) {\r\n    location = location !== undefined\r\n      ? location\r\n      : peg$computeLocation(peg$savedPos, peg$currPos);\r\n\r\n    throw peg$buildSimpleError(message, location);\r\n  }\r\n\r\n  function peg$literalExpectation(text, ignoreCase) {\r\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\r\n  }\r\n\r\n  function peg$classExpectation(parts, inverted, ignoreCase) {\r\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\r\n  }\r\n\r\n  function peg$anyExpectation() {\r\n    return { type: \"any\" };\r\n  }\r\n\r\n  function peg$endExpectation() {\r\n    return { type: \"end\" };\r\n  }\r\n\r\n  function peg$otherExpectation(description) {\r\n    return { type: \"other\", description: description };\r\n  }\r\n\r\n  function peg$computePosDetails(pos) {\r\n    var details = peg$posDetailsCache[pos];\r\n    var p;\r\n\r\n    if (details) {\r\n      return details;\r\n    } else {\r\n      if (pos >= peg$posDetailsCache.length) {\r\n        p = peg$posDetailsCache.length - 1;\r\n      } else {\r\n        p = pos;\r\n        while (!peg$posDetailsCache[--p]) {}\r\n      }\r\n\r\n      details = peg$posDetailsCache[p];\r\n      details = {\r\n        line: details.line,\r\n        column: details.column\r\n      };\r\n\r\n      while (p < pos) {\r\n        if (input.charCodeAt(p) === 10) {\r\n          details.line++;\r\n          details.column = 1;\r\n        } else {\r\n          details.column++;\r\n        }\r\n\r\n        p++;\r\n      }\r\n\r\n      peg$posDetailsCache[pos] = details;\r\n\r\n      return details;\r\n    }\r\n  }\r\n\r\n  function peg$computeLocation(startPos, endPos, offset) {\r\n    var startPosDetails = peg$computePosDetails(startPos);\r\n    var endPosDetails = peg$computePosDetails(endPos);\r\n\r\n    var res = {\r\n      source: peg$source,\r\n      start: {\r\n        offset: startPos,\r\n        line: startPosDetails.line,\r\n        column: startPosDetails.column\r\n      },\r\n      end: {\r\n        offset: endPos,\r\n        line: endPosDetails.line,\r\n        column: endPosDetails.column\r\n      }\r\n    };\r\n    if (offset && peg$source && (typeof peg$source.offset === \"function\")) {\r\n      res.start = peg$source.offset(res.start);\r\n      res.end = peg$source.offset(res.end);\r\n    }\r\n    return res;\r\n  }\r\n\r\n  function peg$fail(expected) {\r\n    if (peg$currPos < peg$maxFailPos) { return; }\r\n\r\n    if (peg$currPos > peg$maxFailPos) {\r\n      peg$maxFailPos = peg$currPos;\r\n      peg$maxFailExpected = [];\r\n    }\r\n\r\n    peg$maxFailExpected.push(expected);\r\n  }\r\n\r\n  function peg$buildSimpleError(message, location) {\r\n    return new peg$SyntaxError(message, null, null, location);\r\n  }\r\n\r\n  function peg$buildStructuredError(expected, found, location) {\r\n    return new peg$SyntaxError(\r\n      peg$SyntaxError.buildMessage(expected, found),\r\n      expected,\r\n      found,\r\n      location\r\n    );\r\n  }\r\n\r\n  function peg$parsepgn() {\r\n    var s0, s1, s2;\r\n\r\n    s0 = peg$currPos;\r\n    s1 = peg$parsetagPairSection();\r\n    s2 = peg$parsemoveTextSection();\r\n    peg$savedPos = s0;\r\n    s0 = peg$f0(s1, s2);\r\n\r\n    return s0;\r\n  }\r\n\r\n  function peg$parsetagPairSection() {\r\n    var s0, s1, s2;\r\n\r\n    s0 = peg$currPos;\r\n    s1 = [];\r\n    s2 = peg$parsetagPair();\r\n    while (s2 !== peg$FAILED) {\r\n      s1.push(s2);\r\n      s2 = peg$parsetagPair();\r\n    }\r\n    s2 = peg$parse_();\r\n    peg$savedPos = s0;\r\n    s0 = peg$f1(s1);\r\n\r\n    return s0;\r\n  }\r\n\r\n  function peg$parsetagPair() {\r\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;\r\n\r\n    peg$silentFails++;\r\n    s0 = peg$currPos;\r\n    s1 = peg$parse_();\r\n    if (input.charCodeAt(peg$currPos) === 91) {\r\n      s2 = peg$c0;\r\n      peg$currPos++;\r\n    } else {\r\n      s2 = peg$FAILED;\r\n      if (peg$silentFails === 0) { peg$fail(peg$e1); }\r\n    }\r\n    if (s2 !== peg$FAILED) {\r\n      s3 = peg$parse_();\r\n      s4 = peg$parsetagName();\r\n      if (s4 !== peg$FAILED) {\r\n        s5 = peg$parse_();\r\n        if (input.charCodeAt(peg$currPos) === 34) {\r\n          s6 = peg$c1;\r\n          peg$currPos++;\r\n        } else {\r\n          s6 = peg$FAILED;\r\n          if (peg$silentFails === 0) { peg$fail(peg$e2); }\r\n        }\r\n        if (s6 !== peg$FAILED) {\r\n          s7 = peg$parsetagValue();\r\n          if (input.charCodeAt(peg$currPos) === 34) {\r\n            s8 = peg$c1;\r\n            peg$currPos++;\r\n          } else {\r\n            s8 = peg$FAILED;\r\n            if (peg$silentFails === 0) { peg$fail(peg$e2); }\r\n          }\r\n          if (s8 !== peg$FAILED) {\r\n            s9 = peg$parse_();\r\n            if (input.charCodeAt(peg$currPos) === 93) {\r\n              s10 = peg$c2;\r\n              peg$currPos++;\r\n            } else {\r\n              s10 = peg$FAILED;\r\n              if (peg$silentFails === 0) { peg$fail(peg$e3); }\r\n            }\r\n            if (s10 !== peg$FAILED) {\r\n              peg$savedPos = s0;\r\n              s0 = peg$f2(s4, s7);\r\n            } else {\r\n              peg$currPos = s0;\r\n              s0 = peg$FAILED;\r\n            }\r\n          } else {\r\n            peg$currPos = s0;\r\n            s0 = peg$FAILED;\r\n          }\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$FAILED;\r\n        }\r\n      } else {\r\n        peg$currPos = s0;\r\n        s0 = peg$FAILED;\r\n      }\r\n    } else {\r\n      peg$currPos = s0;\r\n      s0 = peg$FAILED;\r\n    }\r\n    peg$silentFails--;\r\n    if (s0 === peg$FAILED) {\r\n      s1 = peg$FAILED;\r\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\r\n    }\r\n\r\n    return s0;\r\n  }\r\n\r\n  function peg$parsetagName() {\r\n    var s0, s1, s2;\r\n\r\n    peg$silentFails++;\r\n    s0 = peg$currPos;\r\n    s1 = [];\r\n    s2 = input.charAt(peg$currPos);\r\n    if (peg$r0.test(s2)) {\r\n      peg$currPos++;\r\n    } else {\r\n      s2 = peg$FAILED;\r\n      if (peg$silentFails === 0) { peg$fail(peg$e5); }\r\n    }\r\n    if (s2 !== peg$FAILED) {\r\n      while (s2 !== peg$FAILED) {\r\n        s1.push(s2);\r\n        s2 = input.charAt(peg$currPos);\r\n        if (peg$r0.test(s2)) {\r\n          peg$currPos++;\r\n        } else {\r\n          s2 = peg$FAILED;\r\n          if (peg$silentFails === 0) { peg$fail(peg$e5); }\r\n        }\r\n      }\r\n    } else {\r\n      s1 = peg$FAILED;\r\n    }\r\n    if (s1 !== peg$FAILED) {\r\n      s0 = input.substring(s0, peg$currPos);\r\n    } else {\r\n      s0 = s1;\r\n    }\r\n    peg$silentFails--;\r\n    if (s0 === peg$FAILED) {\r\n      s1 = peg$FAILED;\r\n      if (peg$silentFails === 0) { peg$fail(peg$e4); }\r\n    }\r\n\r\n    return s0;\r\n  }\r\n\r\n  function peg$parsetagValue() {\r\n    var s0, s1, s2;\r\n\r\n    peg$silentFails++;\r\n    s0 = peg$currPos;\r\n    s1 = [];\r\n    s2 = input.charAt(peg$currPos);\r\n    if (peg$r1.test(s2)) {\r\n      peg$currPos++;\r\n    } else {\r\n      s2 = peg$FAILED;\r\n      if (peg$silentFails === 0) { peg$fail(peg$e7); }\r\n    }\r\n    while (s2 !== peg$FAILED) {\r\n      s1.push(s2);\r\n      s2 = input.charAt(peg$currPos);\r\n      if (peg$r1.test(s2)) {\r\n        peg$currPos++;\r\n      } else {\r\n        s2 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$e7); }\r\n      }\r\n    }\r\n    s0 = input.substring(s0, peg$currPos);\r\n    peg$silentFails--;\r\n    s1 = peg$FAILED;\r\n    if (peg$silentFails === 0) { peg$fail(peg$e6); }\r\n\r\n    return s0;\r\n  }\r\n\r\n  function peg$parsemoveTextSection() {\r\n    var s0, s1, s2, s3, s4;\r\n\r\n    s0 = peg$currPos;\r\n    s1 = peg$parseline();\r\n    s2 = peg$parse_();\r\n    s3 = peg$parsegameTerminationMarker();\r\n    if (s3 === peg$FAILED) {\r\n      s3 = null;\r\n    }\r\n    s4 = peg$parse_();\r\n    peg$savedPos = s0;\r\n    s0 = peg$f3(s1, s3);\r\n\r\n    return s0;\r\n  }\r\n\r\n  function peg$parseline() {\r\n    var s0, s1, s2, s3;\r\n\r\n    s0 = peg$currPos;\r\n    s1 = peg$parsecomment();\r\n    if (s1 === peg$FAILED) {\r\n      s1 = null;\r\n    }\r\n    s2 = [];\r\n    s3 = peg$parsemove();\r\n    while (s3 !== peg$FAILED) {\r\n      s2.push(s3);\r\n      s3 = peg$parsemove();\r\n    }\r\n    peg$savedPos = s0;\r\n    s0 = peg$f4(s1, s2);\r\n\r\n    return s0;\r\n  }\r\n\r\n  function peg$parsemove() {\r\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;\r\n\r\n    s0 = peg$currPos;\r\n    s1 = peg$parse_();\r\n    s2 = peg$parsemoveNumber();\r\n    if (s2 === peg$FAILED) {\r\n      s2 = null;\r\n    }\r\n    s3 = peg$parse_();\r\n    s4 = peg$parsesan();\r\n    if (s4 !== peg$FAILED) {\r\n      s5 = peg$parsesuffixAnnotation();\r\n      if (s5 === peg$FAILED) {\r\n        s5 = null;\r\n      }\r\n      s6 = [];\r\n      s7 = peg$parsenag();\r\n      while (s7 !== peg$FAILED) {\r\n        s6.push(s7);\r\n        s7 = peg$parsenag();\r\n      }\r\n      s7 = peg$parse_();\r\n      s8 = peg$parsecomment();\r\n      if (s8 === peg$FAILED) {\r\n        s8 = null;\r\n      }\r\n      s9 = [];\r\n      s10 = peg$parsevariation();\r\n      while (s10 !== peg$FAILED) {\r\n        s9.push(s10);\r\n        s10 = peg$parsevariation();\r\n      }\r\n      peg$savedPos = s0;\r\n      s0 = peg$f5(s4, s5, s6, s8, s9);\r\n    } else {\r\n      peg$currPos = s0;\r\n      s0 = peg$FAILED;\r\n    }\r\n\r\n    return s0;\r\n  }\r\n\r\n  function peg$parsemoveNumber() {\r\n    var s0, s1, s2, s3, s4, s5;\r\n\r\n    peg$silentFails++;\r\n    s0 = peg$currPos;\r\n    s1 = [];\r\n    s2 = input.charAt(peg$currPos);\r\n    if (peg$r2.test(s2)) {\r\n      peg$currPos++;\r\n    } else {\r\n      s2 = peg$FAILED;\r\n      if (peg$silentFails === 0) { peg$fail(peg$e9); }\r\n    }\r\n    while (s2 !== peg$FAILED) {\r\n      s1.push(s2);\r\n      s2 = input.charAt(peg$currPos);\r\n      if (peg$r2.test(s2)) {\r\n        peg$currPos++;\r\n      } else {\r\n        s2 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$e9); }\r\n      }\r\n    }\r\n    if (input.charCodeAt(peg$currPos) === 46) {\r\n      s2 = peg$c3;\r\n      peg$currPos++;\r\n    } else {\r\n      s2 = peg$FAILED;\r\n      if (peg$silentFails === 0) { peg$fail(peg$e10); }\r\n    }\r\n    if (s2 !== peg$FAILED) {\r\n      s3 = peg$parse_();\r\n      s4 = [];\r\n      s5 = input.charAt(peg$currPos);\r\n      if (peg$r3.test(s5)) {\r\n        peg$currPos++;\r\n      } else {\r\n        s5 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$e11); }\r\n      }\r\n      while (s5 !== peg$FAILED) {\r\n        s4.push(s5);\r\n        s5 = input.charAt(peg$currPos);\r\n        if (peg$r3.test(s5)) {\r\n          peg$currPos++;\r\n        } else {\r\n          s5 = peg$FAILED;\r\n          if (peg$silentFails === 0) { peg$fail(peg$e11); }\r\n        }\r\n      }\r\n      s1 = [s1, s2, s3, s4];\r\n      s0 = s1;\r\n    } else {\r\n      peg$currPos = s0;\r\n      s0 = peg$FAILED;\r\n    }\r\n    peg$silentFails--;\r\n    if (s0 === peg$FAILED) {\r\n      s1 = peg$FAILED;\r\n      if (peg$silentFails === 0) { peg$fail(peg$e8); }\r\n    }\r\n\r\n    return s0;\r\n  }\r\n\r\n  function peg$parsesan() {\r\n    var s0, s1, s2, s3, s4, s5;\r\n\r\n    peg$silentFails++;\r\n    s0 = peg$currPos;\r\n    s1 = peg$currPos;\r\n    if (input.substr(peg$currPos, 5) === peg$c4) {\r\n      s2 = peg$c4;\r\n      peg$currPos += 5;\r\n    } else {\r\n      s2 = peg$FAILED;\r\n      if (peg$silentFails === 0) { peg$fail(peg$e13); }\r\n    }\r\n    if (s2 === peg$FAILED) {\r\n      if (input.substr(peg$currPos, 3) === peg$c5) {\r\n        s2 = peg$c5;\r\n        peg$currPos += 3;\r\n      } else {\r\n        s2 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$e14); }\r\n      }\r\n      if (s2 === peg$FAILED) {\r\n        if (input.substr(peg$currPos, 5) === peg$c6) {\r\n          s2 = peg$c6;\r\n          peg$currPos += 5;\r\n        } else {\r\n          s2 = peg$FAILED;\r\n          if (peg$silentFails === 0) { peg$fail(peg$e15); }\r\n        }\r\n        if (s2 === peg$FAILED) {\r\n          if (input.substr(peg$currPos, 3) === peg$c7) {\r\n            s2 = peg$c7;\r\n            peg$currPos += 3;\r\n          } else {\r\n            s2 = peg$FAILED;\r\n            if (peg$silentFails === 0) { peg$fail(peg$e16); }\r\n          }\r\n          if (s2 === peg$FAILED) {\r\n            s2 = peg$currPos;\r\n            s3 = input.charAt(peg$currPos);\r\n            if (peg$r0.test(s3)) {\r\n              peg$currPos++;\r\n            } else {\r\n              s3 = peg$FAILED;\r\n              if (peg$silentFails === 0) { peg$fail(peg$e5); }\r\n            }\r\n            if (s3 !== peg$FAILED) {\r\n              s4 = [];\r\n              s5 = input.charAt(peg$currPos);\r\n              if (peg$r4.test(s5)) {\r\n                peg$currPos++;\r\n              } else {\r\n                s5 = peg$FAILED;\r\n                if (peg$silentFails === 0) { peg$fail(peg$e17); }\r\n              }\r\n              if (s5 !== peg$FAILED) {\r\n                while (s5 !== peg$FAILED) {\r\n                  s4.push(s5);\r\n                  s5 = input.charAt(peg$currPos);\r\n                  if (peg$r4.test(s5)) {\r\n                    peg$currPos++;\r\n                  } else {\r\n                    s5 = peg$FAILED;\r\n                    if (peg$silentFails === 0) { peg$fail(peg$e17); }\r\n                  }\r\n                }\r\n              } else {\r\n                s4 = peg$FAILED;\r\n              }\r\n              if (s4 !== peg$FAILED) {\r\n                s3 = [s3, s4];\r\n                s2 = s3;\r\n              } else {\r\n                peg$currPos = s2;\r\n                s2 = peg$FAILED;\r\n              }\r\n            } else {\r\n              peg$currPos = s2;\r\n              s2 = peg$FAILED;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    if (s2 !== peg$FAILED) {\r\n      s3 = input.charAt(peg$currPos);\r\n      if (peg$r5.test(s3)) {\r\n        peg$currPos++;\r\n      } else {\r\n        s3 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$e18); }\r\n      }\r\n      if (s3 === peg$FAILED) {\r\n        s3 = null;\r\n      }\r\n      s2 = [s2, s3];\r\n      s1 = s2;\r\n    } else {\r\n      peg$currPos = s1;\r\n      s1 = peg$FAILED;\r\n    }\r\n    if (s1 !== peg$FAILED) {\r\n      s0 = input.substring(s0, peg$currPos);\r\n    } else {\r\n      s0 = s1;\r\n    }\r\n    peg$silentFails--;\r\n    if (s0 === peg$FAILED) {\r\n      s1 = peg$FAILED;\r\n      if (peg$silentFails === 0) { peg$fail(peg$e12); }\r\n    }\r\n\r\n    return s0;\r\n  }\r\n\r\n  function peg$parsesuffixAnnotation() {\r\n    var s0, s1, s2;\r\n\r\n    peg$silentFails++;\r\n    s0 = peg$currPos;\r\n    s1 = [];\r\n    s2 = input.charAt(peg$currPos);\r\n    if (peg$r6.test(s2)) {\r\n      peg$currPos++;\r\n    } else {\r\n      s2 = peg$FAILED;\r\n      if (peg$silentFails === 0) { peg$fail(peg$e20); }\r\n    }\r\n    while (s2 !== peg$FAILED) {\r\n      s1.push(s2);\r\n      if (s1.length >= 2) {\r\n        s2 = peg$FAILED;\r\n      } else {\r\n        s2 = input.charAt(peg$currPos);\r\n        if (peg$r6.test(s2)) {\r\n          peg$currPos++;\r\n        } else {\r\n          s2 = peg$FAILED;\r\n          if (peg$silentFails === 0) { peg$fail(peg$e20); }\r\n        }\r\n      }\r\n    }\r\n    if (s1.length < 1) {\r\n      peg$currPos = s0;\r\n      s0 = peg$FAILED;\r\n    } else {\r\n      s0 = s1;\r\n    }\r\n    peg$silentFails--;\r\n    if (s0 === peg$FAILED) {\r\n      s1 = peg$FAILED;\r\n      if (peg$silentFails === 0) { peg$fail(peg$e19); }\r\n    }\r\n\r\n    return s0;\r\n  }\r\n\r\n  function peg$parsenag() {\r\n    var s0, s1, s2, s3, s4, s5;\r\n\r\n    peg$silentFails++;\r\n    s0 = peg$currPos;\r\n    s1 = peg$parse_();\r\n    if (input.charCodeAt(peg$currPos) === 36) {\r\n      s2 = peg$c8;\r\n      peg$currPos++;\r\n    } else {\r\n      s2 = peg$FAILED;\r\n      if (peg$silentFails === 0) { peg$fail(peg$e22); }\r\n    }\r\n    if (s2 !== peg$FAILED) {\r\n      s3 = peg$currPos;\r\n      s4 = [];\r\n      s5 = input.charAt(peg$currPos);\r\n      if (peg$r2.test(s5)) {\r\n        peg$currPos++;\r\n      } else {\r\n        s5 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$e9); }\r\n      }\r\n      if (s5 !== peg$FAILED) {\r\n        while (s5 !== peg$FAILED) {\r\n          s4.push(s5);\r\n          s5 = input.charAt(peg$currPos);\r\n          if (peg$r2.test(s5)) {\r\n            peg$currPos++;\r\n          } else {\r\n            s5 = peg$FAILED;\r\n            if (peg$silentFails === 0) { peg$fail(peg$e9); }\r\n          }\r\n        }\r\n      } else {\r\n        s4 = peg$FAILED;\r\n      }\r\n      if (s4 !== peg$FAILED) {\r\n        s3 = input.substring(s3, peg$currPos);\r\n      } else {\r\n        s3 = s4;\r\n      }\r\n      if (s3 !== peg$FAILED) {\r\n        peg$savedPos = s0;\r\n        s0 = peg$f6(s3);\r\n      } else {\r\n        peg$currPos = s0;\r\n        s0 = peg$FAILED;\r\n      }\r\n    } else {\r\n      peg$currPos = s0;\r\n      s0 = peg$FAILED;\r\n    }\r\n    peg$silentFails--;\r\n    if (s0 === peg$FAILED) {\r\n      s1 = peg$FAILED;\r\n      if (peg$silentFails === 0) { peg$fail(peg$e21); }\r\n    }\r\n\r\n    return s0;\r\n  }\r\n\r\n  function peg$parsecomment() {\r\n    var s0;\r\n\r\n    s0 = peg$parsebraceComment();\r\n    if (s0 === peg$FAILED) {\r\n      s0 = peg$parserestOfLineComment();\r\n    }\r\n\r\n    return s0;\r\n  }\r\n\r\n  function peg$parsebraceComment() {\r\n    var s0, s1, s2, s3, s4;\r\n\r\n    peg$silentFails++;\r\n    s0 = peg$currPos;\r\n    if (input.charCodeAt(peg$currPos) === 123) {\r\n      s1 = peg$c9;\r\n      peg$currPos++;\r\n    } else {\r\n      s1 = peg$FAILED;\r\n      if (peg$silentFails === 0) { peg$fail(peg$e24); }\r\n    }\r\n    if (s1 !== peg$FAILED) {\r\n      s2 = peg$currPos;\r\n      s3 = [];\r\n      s4 = input.charAt(peg$currPos);\r\n      if (peg$r7.test(s4)) {\r\n        peg$currPos++;\r\n      } else {\r\n        s4 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$e25); }\r\n      }\r\n      while (s4 !== peg$FAILED) {\r\n        s3.push(s4);\r\n        s4 = input.charAt(peg$currPos);\r\n        if (peg$r7.test(s4)) {\r\n          peg$currPos++;\r\n        } else {\r\n          s4 = peg$FAILED;\r\n          if (peg$silentFails === 0) { peg$fail(peg$e25); }\r\n        }\r\n      }\r\n      s2 = input.substring(s2, peg$currPos);\r\n      if (input.charCodeAt(peg$currPos) === 125) {\r\n        s3 = peg$c10;\r\n        peg$currPos++;\r\n      } else {\r\n        s3 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$e26); }\r\n      }\r\n      if (s3 !== peg$FAILED) {\r\n        peg$savedPos = s0;\r\n        s0 = peg$f7(s2);\r\n      } else {\r\n        peg$currPos = s0;\r\n        s0 = peg$FAILED;\r\n      }\r\n    } else {\r\n      peg$currPos = s0;\r\n      s0 = peg$FAILED;\r\n    }\r\n    peg$silentFails--;\r\n    if (s0 === peg$FAILED) {\r\n      s1 = peg$FAILED;\r\n      if (peg$silentFails === 0) { peg$fail(peg$e23); }\r\n    }\r\n\r\n    return s0;\r\n  }\r\n\r\n  function peg$parserestOfLineComment() {\r\n    var s0, s1, s2, s3, s4;\r\n\r\n    peg$silentFails++;\r\n    s0 = peg$currPos;\r\n    if (input.charCodeAt(peg$currPos) === 59) {\r\n      s1 = peg$c11;\r\n      peg$currPos++;\r\n    } else {\r\n      s1 = peg$FAILED;\r\n      if (peg$silentFails === 0) { peg$fail(peg$e28); }\r\n    }\r\n    if (s1 !== peg$FAILED) {\r\n      s2 = peg$currPos;\r\n      s3 = [];\r\n      s4 = input.charAt(peg$currPos);\r\n      if (peg$r8.test(s4)) {\r\n        peg$currPos++;\r\n      } else {\r\n        s4 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$e29); }\r\n      }\r\n      while (s4 !== peg$FAILED) {\r\n        s3.push(s4);\r\n        s4 = input.charAt(peg$currPos);\r\n        if (peg$r8.test(s4)) {\r\n          peg$currPos++;\r\n        } else {\r\n          s4 = peg$FAILED;\r\n          if (peg$silentFails === 0) { peg$fail(peg$e29); }\r\n        }\r\n      }\r\n      s2 = input.substring(s2, peg$currPos);\r\n      peg$savedPos = s0;\r\n      s0 = peg$f8(s2);\r\n    } else {\r\n      peg$currPos = s0;\r\n      s0 = peg$FAILED;\r\n    }\r\n    peg$silentFails--;\r\n    if (s0 === peg$FAILED) {\r\n      s1 = peg$FAILED;\r\n      if (peg$silentFails === 0) { peg$fail(peg$e27); }\r\n    }\r\n\r\n    return s0;\r\n  }\r\n\r\n  function peg$parsevariation() {\r\n    var s0, s1, s2, s3, s4, s5;\r\n\r\n    peg$silentFails++;\r\n    s0 = peg$currPos;\r\n    s1 = peg$parse_();\r\n    if (input.charCodeAt(peg$currPos) === 40) {\r\n      s2 = peg$c12;\r\n      peg$currPos++;\r\n    } else {\r\n      s2 = peg$FAILED;\r\n      if (peg$silentFails === 0) { peg$fail(peg$e31); }\r\n    }\r\n    if (s2 !== peg$FAILED) {\r\n      s3 = peg$parseline();\r\n      if (s3 !== peg$FAILED) {\r\n        s4 = peg$parse_();\r\n        if (input.charCodeAt(peg$currPos) === 41) {\r\n          s5 = peg$c13;\r\n          peg$currPos++;\r\n        } else {\r\n          s5 = peg$FAILED;\r\n          if (peg$silentFails === 0) { peg$fail(peg$e32); }\r\n        }\r\n        if (s5 !== peg$FAILED) {\r\n          peg$savedPos = s0;\r\n          s0 = peg$f9(s3);\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$FAILED;\r\n        }\r\n      } else {\r\n        peg$currPos = s0;\r\n        s0 = peg$FAILED;\r\n      }\r\n    } else {\r\n      peg$currPos = s0;\r\n      s0 = peg$FAILED;\r\n    }\r\n    peg$silentFails--;\r\n    if (s0 === peg$FAILED) {\r\n      s1 = peg$FAILED;\r\n      if (peg$silentFails === 0) { peg$fail(peg$e30); }\r\n    }\r\n\r\n    return s0;\r\n  }\r\n\r\n  function peg$parsegameTerminationMarker() {\r\n    var s0, s1, s2, s3;\r\n\r\n    peg$silentFails++;\r\n    s0 = peg$currPos;\r\n    if (input.substr(peg$currPos, 3) === peg$c14) {\r\n      s1 = peg$c14;\r\n      peg$currPos += 3;\r\n    } else {\r\n      s1 = peg$FAILED;\r\n      if (peg$silentFails === 0) { peg$fail(peg$e34); }\r\n    }\r\n    if (s1 === peg$FAILED) {\r\n      if (input.substr(peg$currPos, 3) === peg$c15) {\r\n        s1 = peg$c15;\r\n        peg$currPos += 3;\r\n      } else {\r\n        s1 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$e35); }\r\n      }\r\n      if (s1 === peg$FAILED) {\r\n        if (input.substr(peg$currPos, 7) === peg$c16) {\r\n          s1 = peg$c16;\r\n          peg$currPos += 7;\r\n        } else {\r\n          s1 = peg$FAILED;\r\n          if (peg$silentFails === 0) { peg$fail(peg$e36); }\r\n        }\r\n        if (s1 === peg$FAILED) {\r\n          if (input.charCodeAt(peg$currPos) === 42) {\r\n            s1 = peg$c17;\r\n            peg$currPos++;\r\n          } else {\r\n            s1 = peg$FAILED;\r\n            if (peg$silentFails === 0) { peg$fail(peg$e37); }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    if (s1 !== peg$FAILED) {\r\n      s2 = peg$parse_();\r\n      s3 = peg$parsecomment();\r\n      if (s3 === peg$FAILED) {\r\n        s3 = null;\r\n      }\r\n      peg$savedPos = s0;\r\n      s0 = peg$f10(s1, s3);\r\n    } else {\r\n      peg$currPos = s0;\r\n      s0 = peg$FAILED;\r\n    }\r\n    peg$silentFails--;\r\n    if (s0 === peg$FAILED) {\r\n      s1 = peg$FAILED;\r\n      if (peg$silentFails === 0) { peg$fail(peg$e33); }\r\n    }\r\n\r\n    return s0;\r\n  }\r\n\r\n  function peg$parse_() {\r\n    var s0, s1;\r\n\r\n    peg$silentFails++;\r\n    s0 = [];\r\n    s1 = input.charAt(peg$currPos);\r\n    if (peg$r9.test(s1)) {\r\n      peg$currPos++;\r\n    } else {\r\n      s1 = peg$FAILED;\r\n      if (peg$silentFails === 0) { peg$fail(peg$e39); }\r\n    }\r\n    while (s1 !== peg$FAILED) {\r\n      s0.push(s1);\r\n      s1 = input.charAt(peg$currPos);\r\n      if (peg$r9.test(s1)) {\r\n        peg$currPos++;\r\n      } else {\r\n        s1 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$e39); }\r\n      }\r\n    }\r\n    peg$silentFails--;\r\n    s1 = peg$FAILED;\r\n    if (peg$silentFails === 0) { peg$fail(peg$e38); }\r\n\r\n    return s0;\r\n  }\r\n\r\n  peg$result = peg$startRuleFunction();\r\n\r\n  if (options.peg$library) {\r\n    return /** @type {any} */ ({\r\n      peg$result,\r\n      peg$currPos,\r\n      peg$FAILED,\r\n      peg$maxFailExpected,\r\n      peg$maxFailPos\r\n    });\r\n  }\r\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\r\n    return peg$result;\r\n  } else {\r\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\r\n      peg$fail(peg$endExpectation());\r\n    }\r\n\r\n    throw peg$buildStructuredError(\r\n      peg$maxFailExpected,\r\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\r\n      peg$maxFailPos < input.length\r\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\r\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\r\n    );\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  StartRules: [\"pgn\"],\r\n  SyntaxError: peg$SyntaxError,\r\n  parse: peg$parse\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hlc3MuanMvZGlzdC9janMvcGduLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwwQkFBMEIsSUFBSTtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxL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QUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvY2hlc3MuanMvZGlzdC9janMvcGduLmpzPzcxZTEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQGdlbmVyYXRlZCBieSBQZWdneSA0LjIuMC5cclxuLy9cclxuLy8gaHR0cHM6Ly9wZWdneWpzLm9yZy9cclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcblxyXG4gIGZ1bmN0aW9uIHJvb3ROb2RlKGNvbW1lbnQpIHtcclxuICBcdHJldHVybiBjb21tZW50ICE9PSBudWxsID8geyBjb21tZW50LCB2YXJpYXRpb25zOiBbXSB9IDogeyB2YXJpYXRpb25zOiBbXX1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG5vZGUobW92ZSwgc3VmZml4LCBuYWcsIGNvbW1lbnQsIHZhcmlhdGlvbnMpIHtcclxuICBcdGNvbnN0IG5vZGUgPSB7IG1vdmUsIHZhcmlhdGlvbnMgfVxyXG5cclxuICAgIGlmIChzdWZmaXgpIHtcclxuICAgIFx0bm9kZS5zdWZmaXggPSBzdWZmaXhcclxuICAgIH1cclxuXHJcbiAgICBpZiAobmFnKSB7XHJcbiAgICBcdG5vZGUubmFnID0gbmFnXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNvbW1lbnQgIT09IG51bGwpIHtcclxuICAgIFx0bm9kZS5jb21tZW50ID0gY29tbWVudFxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBub2RlXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBsaW5lVG9UcmVlKC4uLm5vZGVzKSB7XHJcbiAgXHRjb25zdCBbcm9vdCwgLi4ucmVzdF0gPSBub2RlcztcclxuXHJcbiAgICBsZXQgcGFyZW50ID0gcm9vdFxyXG5cclxuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgcmVzdCkge1xyXG4gICAgXHRpZiAoY2hpbGQgIT09IG51bGwpIHtcclxuICAgICAgICBcdHBhcmVudC52YXJpYXRpb25zID0gW2NoaWxkLCAuLi5jaGlsZC52YXJpYXRpb25zXVxyXG4gICAgICAgICAgICBjaGlsZC52YXJpYXRpb25zID0gW11cclxuICAgICAgICAgICAgcGFyZW50ID0gY2hpbGRcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gIFx0cmV0dXJuIHJvb3RcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBnbihoZWFkZXJzLCBnYW1lKSB7XHJcbiAgXHRpZiAoZ2FtZS5tYXJrZXIgJiYgZ2FtZS5tYXJrZXIuY29tbWVudCkge1xyXG4gICAgXHRsZXQgbm9kZSA9IGdhbWUucm9vdFxyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgXHRjb25zdCBuZXh0ID0gbm9kZS52YXJpYXRpb25zWzBdXHJcbiAgICAgICAgICAgIGlmICghbmV4dCkge1xyXG4gICAgICAgICAgICBcdG5vZGUuY29tbWVudCA9IGdhbWUubWFya2VyLmNvbW1lbnRcclxuICAgICAgICAgICAgXHRicmVha1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5vZGUgPSBuZXh0XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICBcdHJldHVybiB7XHJcbiAgICBcdGhlYWRlcnMsXHJcbiAgICAgICAgcm9vdDogZ2FtZS5yb290LFxyXG4gICAgICAgIHJlc3VsdDogKGdhbWUubWFya2VyICYmIGdhbWUubWFya2VyLnJlc3VsdCkgPz8gdW5kZWZpbmVkXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuZnVuY3Rpb24gcGVnJHN1YmNsYXNzKGNoaWxkLCBwYXJlbnQpIHtcclxuICBmdW5jdGlvbiBDKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH1cclxuICBDLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XHJcbiAgY2hpbGQucHJvdG90eXBlID0gbmV3IEMoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGVnJFN5bnRheEVycm9yKG1lc3NhZ2UsIGV4cGVjdGVkLCBmb3VuZCwgbG9jYXRpb24pIHtcclxuICB2YXIgc2VsZiA9IEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XHJcbiAgLy8gaXN0YW5idWwgaWdub3JlIG5leHQgQ2hlY2sgaXMgYSBuZWNlc3NhcnkgZXZpbCB0byBzdXBwb3J0IG9sZGVyIGVudmlyb25tZW50c1xyXG4gIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcclxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihzZWxmLCBwZWckU3ludGF4RXJyb3IucHJvdG90eXBlKTtcclxuICB9XHJcbiAgc2VsZi5leHBlY3RlZCA9IGV4cGVjdGVkO1xyXG4gIHNlbGYuZm91bmQgPSBmb3VuZDtcclxuICBzZWxmLmxvY2F0aW9uID0gbG9jYXRpb247XHJcbiAgc2VsZi5uYW1lID0gXCJTeW50YXhFcnJvclwiO1xyXG4gIHJldHVybiBzZWxmO1xyXG59XHJcblxyXG5wZWckc3ViY2xhc3MocGVnJFN5bnRheEVycm9yLCBFcnJvcik7XHJcblxyXG5mdW5jdGlvbiBwZWckcGFkRW5kKHN0ciwgdGFyZ2V0TGVuZ3RoLCBwYWRTdHJpbmcpIHtcclxuICBwYWRTdHJpbmcgPSBwYWRTdHJpbmcgfHwgXCIgXCI7XHJcbiAgaWYgKHN0ci5sZW5ndGggPiB0YXJnZXRMZW5ndGgpIHsgcmV0dXJuIHN0cjsgfVxyXG4gIHRhcmdldExlbmd0aCAtPSBzdHIubGVuZ3RoO1xyXG4gIHBhZFN0cmluZyArPSBwYWRTdHJpbmcucmVwZWF0KHRhcmdldExlbmd0aCk7XHJcbiAgcmV0dXJuIHN0ciArIHBhZFN0cmluZy5zbGljZSgwLCB0YXJnZXRMZW5ndGgpO1xyXG59XHJcblxyXG5wZWckU3ludGF4RXJyb3IucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKHNvdXJjZXMpIHtcclxuICB2YXIgc3RyID0gXCJFcnJvcjogXCIgKyB0aGlzLm1lc3NhZ2U7XHJcbiAgaWYgKHRoaXMubG9jYXRpb24pIHtcclxuICAgIHZhciBzcmMgPSBudWxsO1xyXG4gICAgdmFyIGs7XHJcbiAgICBmb3IgKGsgPSAwOyBrIDwgc291cmNlcy5sZW5ndGg7IGsrKykge1xyXG4gICAgICBpZiAoc291cmNlc1trXS5zb3VyY2UgPT09IHRoaXMubG9jYXRpb24uc291cmNlKSB7XHJcbiAgICAgICAgc3JjID0gc291cmNlc1trXS50ZXh0LnNwbGl0KC9cXHJcXG58XFxufFxcci9nKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIHMgPSB0aGlzLmxvY2F0aW9uLnN0YXJ0O1xyXG4gICAgdmFyIG9mZnNldF9zID0gKHRoaXMubG9jYXRpb24uc291cmNlICYmICh0eXBlb2YgdGhpcy5sb2NhdGlvbi5zb3VyY2Uub2Zmc2V0ID09PSBcImZ1bmN0aW9uXCIpKVxyXG4gICAgICA/IHRoaXMubG9jYXRpb24uc291cmNlLm9mZnNldChzKVxyXG4gICAgICA6IHM7XHJcbiAgICB2YXIgbG9jID0gdGhpcy5sb2NhdGlvbi5zb3VyY2UgKyBcIjpcIiArIG9mZnNldF9zLmxpbmUgKyBcIjpcIiArIG9mZnNldF9zLmNvbHVtbjtcclxuICAgIGlmIChzcmMpIHtcclxuICAgICAgdmFyIGUgPSB0aGlzLmxvY2F0aW9uLmVuZDtcclxuICAgICAgdmFyIGZpbGxlciA9IHBlZyRwYWRFbmQoXCJcIiwgb2Zmc2V0X3MubGluZS50b1N0cmluZygpLmxlbmd0aCwgJyAnKTtcclxuICAgICAgdmFyIGxpbmUgPSBzcmNbcy5saW5lIC0gMV07XHJcbiAgICAgIHZhciBsYXN0ID0gcy5saW5lID09PSBlLmxpbmUgPyBlLmNvbHVtbiA6IGxpbmUubGVuZ3RoICsgMTtcclxuICAgICAgdmFyIGhhdExlbiA9IChsYXN0IC0gcy5jb2x1bW4pIHx8IDE7XHJcbiAgICAgIHN0ciArPSBcIlxcbiAtLT4gXCIgKyBsb2MgKyBcIlxcblwiXHJcbiAgICAgICAgICArIGZpbGxlciArIFwiIHxcXG5cIlxyXG4gICAgICAgICAgKyBvZmZzZXRfcy5saW5lICsgXCIgfCBcIiArIGxpbmUgKyBcIlxcblwiXHJcbiAgICAgICAgICArIGZpbGxlciArIFwiIHwgXCIgKyBwZWckcGFkRW5kKFwiXCIsIHMuY29sdW1uIC0gMSwgJyAnKVxyXG4gICAgICAgICAgKyBwZWckcGFkRW5kKFwiXCIsIGhhdExlbiwgXCJeXCIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc3RyICs9IFwiXFxuIGF0IFwiICsgbG9jO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gc3RyO1xyXG59O1xyXG5cclxucGVnJFN5bnRheEVycm9yLmJ1aWxkTWVzc2FnZSA9IGZ1bmN0aW9uKGV4cGVjdGVkLCBmb3VuZCkge1xyXG4gIHZhciBERVNDUklCRV9FWFBFQ1RBVElPTl9GTlMgPSB7XHJcbiAgICBsaXRlcmFsOiBmdW5jdGlvbihleHBlY3RhdGlvbikge1xyXG4gICAgICByZXR1cm4gXCJcXFwiXCIgKyBsaXRlcmFsRXNjYXBlKGV4cGVjdGF0aW9uLnRleHQpICsgXCJcXFwiXCI7XHJcbiAgICB9LFxyXG5cclxuICAgIGNsYXNzOiBmdW5jdGlvbihleHBlY3RhdGlvbikge1xyXG4gICAgICB2YXIgZXNjYXBlZFBhcnRzID0gZXhwZWN0YXRpb24ucGFydHMubWFwKGZ1bmN0aW9uKHBhcnQpIHtcclxuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShwYXJ0KVxyXG4gICAgICAgICAgPyBjbGFzc0VzY2FwZShwYXJ0WzBdKSArIFwiLVwiICsgY2xhc3NFc2NhcGUocGFydFsxXSlcclxuICAgICAgICAgIDogY2xhc3NFc2NhcGUocGFydCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIFwiW1wiICsgKGV4cGVjdGF0aW9uLmludmVydGVkID8gXCJeXCIgOiBcIlwiKSArIGVzY2FwZWRQYXJ0cy5qb2luKFwiXCIpICsgXCJdXCI7XHJcbiAgICB9LFxyXG5cclxuICAgIGFueTogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiBcImFueSBjaGFyYWN0ZXJcIjtcclxuICAgIH0sXHJcblxyXG4gICAgZW5kOiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIFwiZW5kIG9mIGlucHV0XCI7XHJcbiAgICB9LFxyXG5cclxuICAgIG90aGVyOiBmdW5jdGlvbihleHBlY3RhdGlvbikge1xyXG4gICAgICByZXR1cm4gZXhwZWN0YXRpb24uZGVzY3JpcHRpb247XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gaGV4KGNoKSB7XHJcbiAgICByZXR1cm4gY2guY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGxpdGVyYWxFc2NhcGUocykge1xyXG4gICAgcmV0dXJuIHNcclxuICAgICAgLnJlcGxhY2UoL1xcXFwvZywgXCJcXFxcXFxcXFwiKVxyXG4gICAgICAucmVwbGFjZSgvXCIvZywgIFwiXFxcXFxcXCJcIilcclxuICAgICAgLnJlcGxhY2UoL1xcMC9nLCBcIlxcXFwwXCIpXHJcbiAgICAgIC5yZXBsYWNlKC9cXHQvZywgXCJcXFxcdFwiKVxyXG4gICAgICAucmVwbGFjZSgvXFxuL2csIFwiXFxcXG5cIilcclxuICAgICAgLnJlcGxhY2UoL1xcci9nLCBcIlxcXFxyXCIpXHJcbiAgICAgIC5yZXBsYWNlKC9bXFx4MDAtXFx4MEZdL2csICAgICAgICAgIGZ1bmN0aW9uKGNoKSB7IHJldHVybiBcIlxcXFx4MFwiICsgaGV4KGNoKTsgfSlcclxuICAgICAgLnJlcGxhY2UoL1tcXHgxMC1cXHgxRlxceDdGLVxceDlGXS9nLCBmdW5jdGlvbihjaCkgeyByZXR1cm4gXCJcXFxceFwiICArIGhleChjaCk7IH0pO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY2xhc3NFc2NhcGUocykge1xyXG4gICAgcmV0dXJuIHNcclxuICAgICAgLnJlcGxhY2UoL1xcXFwvZywgXCJcXFxcXFxcXFwiKVxyXG4gICAgICAucmVwbGFjZSgvXFxdL2csIFwiXFxcXF1cIilcclxuICAgICAgLnJlcGxhY2UoL1xcXi9nLCBcIlxcXFxeXCIpXHJcbiAgICAgIC5yZXBsYWNlKC8tL2csICBcIlxcXFwtXCIpXHJcbiAgICAgIC5yZXBsYWNlKC9cXDAvZywgXCJcXFxcMFwiKVxyXG4gICAgICAucmVwbGFjZSgvXFx0L2csIFwiXFxcXHRcIilcclxuICAgICAgLnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpXHJcbiAgICAgIC5yZXBsYWNlKC9cXHIvZywgXCJcXFxcclwiKVxyXG4gICAgICAucmVwbGFjZSgvW1xceDAwLVxceDBGXS9nLCAgICAgICAgICBmdW5jdGlvbihjaCkgeyByZXR1cm4gXCJcXFxceDBcIiArIGhleChjaCk7IH0pXHJcbiAgICAgIC5yZXBsYWNlKC9bXFx4MTAtXFx4MUZcXHg3Ri1cXHg5Rl0vZywgZnVuY3Rpb24oY2gpIHsgcmV0dXJuIFwiXFxcXHhcIiAgKyBoZXgoY2gpOyB9KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGRlc2NyaWJlRXhwZWN0YXRpb24oZXhwZWN0YXRpb24pIHtcclxuICAgIHJldHVybiBERVNDUklCRV9FWFBFQ1RBVElPTl9GTlNbZXhwZWN0YXRpb24udHlwZV0oZXhwZWN0YXRpb24pO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZGVzY3JpYmVFeHBlY3RlZChleHBlY3RlZCkge1xyXG4gICAgdmFyIGRlc2NyaXB0aW9ucyA9IGV4cGVjdGVkLm1hcChkZXNjcmliZUV4cGVjdGF0aW9uKTtcclxuICAgIHZhciBpLCBqO1xyXG5cclxuICAgIGRlc2NyaXB0aW9ucy5zb3J0KCk7XHJcblxyXG4gICAgaWYgKGRlc2NyaXB0aW9ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGZvciAoaSA9IDEsIGogPSAxOyBpIDwgZGVzY3JpcHRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uc1tpIC0gMV0gIT09IGRlc2NyaXB0aW9uc1tpXSkge1xyXG4gICAgICAgICAgZGVzY3JpcHRpb25zW2pdID0gZGVzY3JpcHRpb25zW2ldO1xyXG4gICAgICAgICAgaisrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBkZXNjcmlwdGlvbnMubGVuZ3RoID0gajtcclxuICAgIH1cclxuXHJcbiAgICBzd2l0Y2ggKGRlc2NyaXB0aW9ucy5sZW5ndGgpIHtcclxuICAgICAgY2FzZSAxOlxyXG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbnNbMF07XHJcblxyXG4gICAgICBjYXNlIDI6XHJcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uc1swXSArIFwiIG9yIFwiICsgZGVzY3JpcHRpb25zWzFdO1xyXG5cclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb25zLnNsaWNlKDAsIC0xKS5qb2luKFwiLCBcIilcclxuICAgICAgICAgICsgXCIsIG9yIFwiXHJcbiAgICAgICAgICArIGRlc2NyaXB0aW9uc1tkZXNjcmlwdGlvbnMubGVuZ3RoIC0gMV07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBkZXNjcmliZUZvdW5kKGZvdW5kKSB7XHJcbiAgICByZXR1cm4gZm91bmQgPyBcIlxcXCJcIiArIGxpdGVyYWxFc2NhcGUoZm91bmQpICsgXCJcXFwiXCIgOiBcImVuZCBvZiBpbnB1dFwiO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIFwiRXhwZWN0ZWQgXCIgKyBkZXNjcmliZUV4cGVjdGVkKGV4cGVjdGVkKSArIFwiIGJ1dCBcIiArIGRlc2NyaWJlRm91bmQoZm91bmQpICsgXCIgZm91bmQuXCI7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBwZWckcGFyc2UoaW5wdXQsIG9wdGlvbnMpIHtcclxuICBvcHRpb25zID0gb3B0aW9ucyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucyA6IHt9O1xyXG5cclxuICB2YXIgcGVnJEZBSUxFRCA9IHt9O1xyXG4gIHZhciBwZWckc291cmNlID0gb3B0aW9ucy5ncmFtbWFyU291cmNlO1xyXG5cclxuICB2YXIgcGVnJHN0YXJ0UnVsZUZ1bmN0aW9ucyA9IHsgcGduOiBwZWckcGFyc2VwZ24gfTtcclxuICB2YXIgcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uID0gcGVnJHBhcnNlcGduO1xyXG5cclxuICB2YXIgcGVnJGMwID0gXCJbXCI7XHJcbiAgdmFyIHBlZyRjMSA9IFwiXFxcIlwiO1xyXG4gIHZhciBwZWckYzIgPSBcIl1cIjtcclxuICB2YXIgcGVnJGMzID0gXCIuXCI7XHJcbiAgdmFyIHBlZyRjNCA9IFwiTy1PLU9cIjtcclxuICB2YXIgcGVnJGM1ID0gXCJPLU9cIjtcclxuICB2YXIgcGVnJGM2ID0gXCIwLTAtMFwiO1xyXG4gIHZhciBwZWckYzcgPSBcIjAtMFwiO1xyXG4gIHZhciBwZWckYzggPSBcIiRcIjtcclxuICB2YXIgcGVnJGM5ID0gXCJ7XCI7XHJcbiAgdmFyIHBlZyRjMTAgPSBcIn1cIjtcclxuICB2YXIgcGVnJGMxMSA9IFwiO1wiO1xyXG4gIHZhciBwZWckYzEyID0gXCIoXCI7XHJcbiAgdmFyIHBlZyRjMTMgPSBcIilcIjtcclxuICB2YXIgcGVnJGMxNCA9IFwiMS0wXCI7XHJcbiAgdmFyIHBlZyRjMTUgPSBcIjAtMVwiO1xyXG4gIHZhciBwZWckYzE2ID0gXCIxLzItMS8yXCI7XHJcbiAgdmFyIHBlZyRjMTcgPSBcIipcIjtcclxuXHJcbiAgdmFyIHBlZyRyMCA9IC9eW2EtekEtWl0vO1xyXG4gIHZhciBwZWckcjEgPSAvXlteXCJdLztcclxuICB2YXIgcGVnJHIyID0gL15bMC05XS87XHJcbiAgdmFyIHBlZyRyMyA9IC9eWy5dLztcclxuICB2YXIgcGVnJHI0ID0gL15bYS16QS1aMS04XFwtPV0vO1xyXG4gIHZhciBwZWckcjUgPSAvXlsrI10vO1xyXG4gIHZhciBwZWckcjYgPSAvXlshP10vO1xyXG4gIHZhciBwZWckcjcgPSAvXltefV0vO1xyXG4gIHZhciBwZWckcjggPSAvXlteXFxyXFxuXS87XHJcbiAgdmFyIHBlZyRyOSA9IC9eWyBcXHRcXHJcXG5dLztcclxuXHJcbiAgdmFyIHBlZyRlMCA9IHBlZyRvdGhlckV4cGVjdGF0aW9uKFwidGFnIHBhaXJcIik7XHJcbiAgdmFyIHBlZyRlMSA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJbXCIsIGZhbHNlKTtcclxuICB2YXIgcGVnJGUyID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIlxcXCJcIiwgZmFsc2UpO1xyXG4gIHZhciBwZWckZTMgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiXVwiLCBmYWxzZSk7XHJcbiAgdmFyIHBlZyRlNCA9IHBlZyRvdGhlckV4cGVjdGF0aW9uKFwidGFnIG5hbWVcIik7XHJcbiAgdmFyIHBlZyRlNSA9IHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtbXCJhXCIsIFwielwiXSwgW1wiQVwiLCBcIlpcIl1dLCBmYWxzZSwgZmFsc2UpO1xyXG4gIHZhciBwZWckZTYgPSBwZWckb3RoZXJFeHBlY3RhdGlvbihcInRhZyB2YWx1ZVwiKTtcclxuICB2YXIgcGVnJGU3ID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1wiXFxcIlwiXSwgdHJ1ZSwgZmFsc2UpO1xyXG4gIHZhciBwZWckZTggPSBwZWckb3RoZXJFeHBlY3RhdGlvbihcIm1vdmUgbnVtYmVyXCIpO1xyXG4gIHZhciBwZWckZTkgPSBwZWckY2xhc3NFeHBlY3RhdGlvbihbW1wiMFwiLCBcIjlcIl1dLCBmYWxzZSwgZmFsc2UpO1xyXG4gIHZhciBwZWckZTEwID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIi5cIiwgZmFsc2UpO1xyXG4gIHZhciBwZWckZTExID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1wiLlwiXSwgZmFsc2UsIGZhbHNlKTtcclxuICB2YXIgcGVnJGUxMiA9IHBlZyRvdGhlckV4cGVjdGF0aW9uKFwic3RhbmRhcmQgYWxnZWJyYWljIG5vdGF0aW9uXCIpO1xyXG4gIHZhciBwZWckZTEzID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIk8tTy1PXCIsIGZhbHNlKTtcclxuICB2YXIgcGVnJGUxNCA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJPLU9cIiwgZmFsc2UpO1xyXG4gIHZhciBwZWckZTE1ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIjAtMC0wXCIsIGZhbHNlKTtcclxuICB2YXIgcGVnJGUxNiA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIwLTBcIiwgZmFsc2UpO1xyXG4gIHZhciBwZWckZTE3ID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcImFcIiwgXCJ6XCJdLCBbXCJBXCIsIFwiWlwiXSwgW1wiMVwiLCBcIjhcIl0sIFwiLVwiLCBcIj1cIl0sIGZhbHNlLCBmYWxzZSk7XHJcbiAgdmFyIHBlZyRlMTggPSBwZWckY2xhc3NFeHBlY3RhdGlvbihbXCIrXCIsIFwiI1wiXSwgZmFsc2UsIGZhbHNlKTtcclxuICB2YXIgcGVnJGUxOSA9IHBlZyRvdGhlckV4cGVjdGF0aW9uKFwic3VmZml4IGFubm90YXRpb25cIik7XHJcbiAgdmFyIHBlZyRlMjAgPSBwZWckY2xhc3NFeHBlY3RhdGlvbihbXCIhXCIsIFwiP1wiXSwgZmFsc2UsIGZhbHNlKTtcclxuICB2YXIgcGVnJGUyMSA9IHBlZyRvdGhlckV4cGVjdGF0aW9uKFwiTkFHXCIpO1xyXG4gIHZhciBwZWckZTIyID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIiRcIiwgZmFsc2UpO1xyXG4gIHZhciBwZWckZTIzID0gcGVnJG90aGVyRXhwZWN0YXRpb24oXCJicmFjZSBjb21tZW50XCIpO1xyXG4gIHZhciBwZWckZTI0ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIntcIiwgZmFsc2UpO1xyXG4gIHZhciBwZWckZTI1ID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1wifVwiXSwgdHJ1ZSwgZmFsc2UpO1xyXG4gIHZhciBwZWckZTI2ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIn1cIiwgZmFsc2UpO1xyXG4gIHZhciBwZWckZTI3ID0gcGVnJG90aGVyRXhwZWN0YXRpb24oXCJyZXN0IG9mIGxpbmUgY29tbWVudFwiKTtcclxuICB2YXIgcGVnJGUyOCA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCI7XCIsIGZhbHNlKTtcclxuICB2YXIgcGVnJGUyOSA9IHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtcIlxcclwiLCBcIlxcblwiXSwgdHJ1ZSwgZmFsc2UpO1xyXG4gIHZhciBwZWckZTMwID0gcGVnJG90aGVyRXhwZWN0YXRpb24oXCJ2YXJpYXRpb25cIik7XHJcbiAgdmFyIHBlZyRlMzEgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiKFwiLCBmYWxzZSk7XHJcbiAgdmFyIHBlZyRlMzIgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiKVwiLCBmYWxzZSk7XHJcbiAgdmFyIHBlZyRlMzMgPSBwZWckb3RoZXJFeHBlY3RhdGlvbihcImdhbWUgdGVybWluYXRpb24gbWFya2VyXCIpO1xyXG4gIHZhciBwZWckZTM0ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIjEtMFwiLCBmYWxzZSk7XHJcbiAgdmFyIHBlZyRlMzUgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiMC0xXCIsIGZhbHNlKTtcclxuICB2YXIgcGVnJGUzNiA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIxLzItMS8yXCIsIGZhbHNlKTtcclxuICB2YXIgcGVnJGUzNyA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIqXCIsIGZhbHNlKTtcclxuICB2YXIgcGVnJGUzOCA9IHBlZyRvdGhlckV4cGVjdGF0aW9uKFwid2hpdGVzcGFjZVwiKTtcclxuICB2YXIgcGVnJGUzOSA9IHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtcIiBcIiwgXCJcXHRcIiwgXCJcXHJcIiwgXCJcXG5cIl0sIGZhbHNlLCBmYWxzZSk7XHJcblxyXG4gIHZhciBwZWckZjAgPSBmdW5jdGlvbihoZWFkZXJzLCBnYW1lKSB7IHJldHVybiBwZ24oaGVhZGVycywgZ2FtZSkgfTtcclxuICB2YXIgcGVnJGYxID0gZnVuY3Rpb24odGFnUGFpcnMpIHsgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyh0YWdQYWlycykgfTtcclxuICB2YXIgcGVnJGYyID0gZnVuY3Rpb24odGFnTmFtZSwgdGFnVmFsdWUpIHsgcmV0dXJuIFt0YWdOYW1lLCB0YWdWYWx1ZV0gfTtcclxuICB2YXIgcGVnJGYzID0gZnVuY3Rpb24ocm9vdCwgbWFya2VyKSB7IHJldHVybiB7IHJvb3QsIG1hcmtlcn0gfTtcclxuICB2YXIgcGVnJGY0ID0gZnVuY3Rpb24oY29tbWVudCwgbW92ZXMpIHsgcmV0dXJuIGxpbmVUb1RyZWUocm9vdE5vZGUoY29tbWVudCksIC4uLm1vdmVzLmZsYXQoKSkgfTtcclxuICB2YXIgcGVnJGY1ID0gZnVuY3Rpb24oc2FuLCBzdWZmaXgsIG5hZywgY29tbWVudCwgdmFyaWF0aW9ucykgeyByZXR1cm4gbm9kZShzYW4sIHN1ZmZpeCwgbmFnLCBjb21tZW50LCB2YXJpYXRpb25zKSB9O1xyXG4gIHZhciBwZWckZjYgPSBmdW5jdGlvbihuYWcpIHsgcmV0dXJuIG5hZyB9O1xyXG4gIHZhciBwZWckZjcgPSBmdW5jdGlvbihjb21tZW50KSB7IHJldHVybiBjb21tZW50LnJlcGxhY2UoL1tcXHJcXG5dKy9nLCBcIiBcIikgfTtcclxuICB2YXIgcGVnJGY4ID0gZnVuY3Rpb24oY29tbWVudCkgeyByZXR1cm4gY29tbWVudC50cmltKCkgfTtcclxuICB2YXIgcGVnJGY5ID0gZnVuY3Rpb24obGluZSkgeyByZXR1cm4gbGluZSB9O1xyXG4gIHZhciBwZWckZjEwID0gZnVuY3Rpb24ocmVzdWx0LCBjb21tZW50KSB7IHJldHVybiB7IHJlc3VsdCwgY29tbWVudCB9IH07XHJcbiAgdmFyIHBlZyRjdXJyUG9zID0gb3B0aW9ucy5wZWckY3VyclBvcyB8IDA7XHJcbiAgdmFyIHBlZyRzYXZlZFBvcyA9IHBlZyRjdXJyUG9zO1xyXG4gIHZhciBwZWckcG9zRGV0YWlsc0NhY2hlID0gW3sgbGluZTogMSwgY29sdW1uOiAxIH1dO1xyXG4gIHZhciBwZWckbWF4RmFpbFBvcyA9IHBlZyRjdXJyUG9zO1xyXG4gIHZhciBwZWckbWF4RmFpbEV4cGVjdGVkID0gb3B0aW9ucy5wZWckbWF4RmFpbEV4cGVjdGVkIHx8IFtdO1xyXG4gIHZhciBwZWckc2lsZW50RmFpbHMgPSBvcHRpb25zLnBlZyRzaWxlbnRGYWlscyB8IDA7XHJcblxyXG4gIHZhciBwZWckcmVzdWx0O1xyXG5cclxuICBpZiAob3B0aW9ucy5zdGFydFJ1bGUpIHtcclxuICAgIGlmICghKG9wdGlvbnMuc3RhcnRSdWxlIGluIHBlZyRzdGFydFJ1bGVGdW5jdGlvbnMpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHN0YXJ0IHBhcnNpbmcgZnJvbSBydWxlIFxcXCJcIiArIG9wdGlvbnMuc3RhcnRSdWxlICsgXCJcXFwiLlwiKTtcclxuICAgIH1cclxuXHJcbiAgICBwZWckc3RhcnRSdWxlRnVuY3Rpb24gPSBwZWckc3RhcnRSdWxlRnVuY3Rpb25zW29wdGlvbnMuc3RhcnRSdWxlXTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHRleHQoKSB7XHJcbiAgICByZXR1cm4gaW5wdXQuc3Vic3RyaW5nKHBlZyRzYXZlZFBvcywgcGVnJGN1cnJQb3MpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gb2Zmc2V0KCkge1xyXG4gICAgcmV0dXJuIHBlZyRzYXZlZFBvcztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJhbmdlKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc291cmNlOiBwZWckc291cmNlLFxyXG4gICAgICBzdGFydDogcGVnJHNhdmVkUG9zLFxyXG4gICAgICBlbmQ6IHBlZyRjdXJyUG9zXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbG9jYXRpb24oKSB7XHJcbiAgICByZXR1cm4gcGVnJGNvbXB1dGVMb2NhdGlvbihwZWckc2F2ZWRQb3MsIHBlZyRjdXJyUG9zKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGV4cGVjdGVkKGRlc2NyaXB0aW9uLCBsb2NhdGlvbikge1xyXG4gICAgbG9jYXRpb24gPSBsb2NhdGlvbiAhPT0gdW5kZWZpbmVkXHJcbiAgICAgID8gbG9jYXRpb25cclxuICAgICAgOiBwZWckY29tcHV0ZUxvY2F0aW9uKHBlZyRzYXZlZFBvcywgcGVnJGN1cnJQb3MpO1xyXG5cclxuICAgIHRocm93IHBlZyRidWlsZFN0cnVjdHVyZWRFcnJvcihcclxuICAgICAgW3BlZyRvdGhlckV4cGVjdGF0aW9uKGRlc2NyaXB0aW9uKV0sXHJcbiAgICAgIGlucHV0LnN1YnN0cmluZyhwZWckc2F2ZWRQb3MsIHBlZyRjdXJyUG9zKSxcclxuICAgICAgbG9jYXRpb25cclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBlcnJvcihtZXNzYWdlLCBsb2NhdGlvbikge1xyXG4gICAgbG9jYXRpb24gPSBsb2NhdGlvbiAhPT0gdW5kZWZpbmVkXHJcbiAgICAgID8gbG9jYXRpb25cclxuICAgICAgOiBwZWckY29tcHV0ZUxvY2F0aW9uKHBlZyRzYXZlZFBvcywgcGVnJGN1cnJQb3MpO1xyXG5cclxuICAgIHRocm93IHBlZyRidWlsZFNpbXBsZUVycm9yKG1lc3NhZ2UsIGxvY2F0aW9uKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24odGV4dCwgaWdub3JlQ2FzZSkge1xyXG4gICAgcmV0dXJuIHsgdHlwZTogXCJsaXRlcmFsXCIsIHRleHQ6IHRleHQsIGlnbm9yZUNhc2U6IGlnbm9yZUNhc2UgfTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBlZyRjbGFzc0V4cGVjdGF0aW9uKHBhcnRzLCBpbnZlcnRlZCwgaWdub3JlQ2FzZSkge1xyXG4gICAgcmV0dXJuIHsgdHlwZTogXCJjbGFzc1wiLCBwYXJ0czogcGFydHMsIGludmVydGVkOiBpbnZlcnRlZCwgaWdub3JlQ2FzZTogaWdub3JlQ2FzZSB9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcGVnJGFueUV4cGVjdGF0aW9uKCkge1xyXG4gICAgcmV0dXJuIHsgdHlwZTogXCJhbnlcIiB9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcGVnJGVuZEV4cGVjdGF0aW9uKCkge1xyXG4gICAgcmV0dXJuIHsgdHlwZTogXCJlbmRcIiB9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcGVnJG90aGVyRXhwZWN0YXRpb24oZGVzY3JpcHRpb24pIHtcclxuICAgIHJldHVybiB7IHR5cGU6IFwib3RoZXJcIiwgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uIH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwZWckY29tcHV0ZVBvc0RldGFpbHMocG9zKSB7XHJcbiAgICB2YXIgZGV0YWlscyA9IHBlZyRwb3NEZXRhaWxzQ2FjaGVbcG9zXTtcclxuICAgIHZhciBwO1xyXG5cclxuICAgIGlmIChkZXRhaWxzKSB7XHJcbiAgICAgIHJldHVybiBkZXRhaWxzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHBvcyA+PSBwZWckcG9zRGV0YWlsc0NhY2hlLmxlbmd0aCkge1xyXG4gICAgICAgIHAgPSBwZWckcG9zRGV0YWlsc0NhY2hlLmxlbmd0aCAtIDE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcCA9IHBvcztcclxuICAgICAgICB3aGlsZSAoIXBlZyRwb3NEZXRhaWxzQ2FjaGVbLS1wXSkge31cclxuICAgICAgfVxyXG5cclxuICAgICAgZGV0YWlscyA9IHBlZyRwb3NEZXRhaWxzQ2FjaGVbcF07XHJcbiAgICAgIGRldGFpbHMgPSB7XHJcbiAgICAgICAgbGluZTogZGV0YWlscy5saW5lLFxyXG4gICAgICAgIGNvbHVtbjogZGV0YWlscy5jb2x1bW5cclxuICAgICAgfTtcclxuXHJcbiAgICAgIHdoaWxlIChwIDwgcG9zKSB7XHJcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocCkgPT09IDEwKSB7XHJcbiAgICAgICAgICBkZXRhaWxzLmxpbmUrKztcclxuICAgICAgICAgIGRldGFpbHMuY29sdW1uID0gMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZGV0YWlscy5jb2x1bW4rKztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHArKztcclxuICAgICAgfVxyXG5cclxuICAgICAgcGVnJHBvc0RldGFpbHNDYWNoZVtwb3NdID0gZGV0YWlscztcclxuXHJcbiAgICAgIHJldHVybiBkZXRhaWxzO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcGVnJGNvbXB1dGVMb2NhdGlvbihzdGFydFBvcywgZW5kUG9zLCBvZmZzZXQpIHtcclxuICAgIHZhciBzdGFydFBvc0RldGFpbHMgPSBwZWckY29tcHV0ZVBvc0RldGFpbHMoc3RhcnRQb3MpO1xyXG4gICAgdmFyIGVuZFBvc0RldGFpbHMgPSBwZWckY29tcHV0ZVBvc0RldGFpbHMoZW5kUG9zKTtcclxuXHJcbiAgICB2YXIgcmVzID0ge1xyXG4gICAgICBzb3VyY2U6IHBlZyRzb3VyY2UsXHJcbiAgICAgIHN0YXJ0OiB7XHJcbiAgICAgICAgb2Zmc2V0OiBzdGFydFBvcyxcclxuICAgICAgICBsaW5lOiBzdGFydFBvc0RldGFpbHMubGluZSxcclxuICAgICAgICBjb2x1bW46IHN0YXJ0UG9zRGV0YWlscy5jb2x1bW5cclxuICAgICAgfSxcclxuICAgICAgZW5kOiB7XHJcbiAgICAgICAgb2Zmc2V0OiBlbmRQb3MsXHJcbiAgICAgICAgbGluZTogZW5kUG9zRGV0YWlscy5saW5lLFxyXG4gICAgICAgIGNvbHVtbjogZW5kUG9zRGV0YWlscy5jb2x1bW5cclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIGlmIChvZmZzZXQgJiYgcGVnJHNvdXJjZSAmJiAodHlwZW9mIHBlZyRzb3VyY2Uub2Zmc2V0ID09PSBcImZ1bmN0aW9uXCIpKSB7XHJcbiAgICAgIHJlcy5zdGFydCA9IHBlZyRzb3VyY2Uub2Zmc2V0KHJlcy5zdGFydCk7XHJcbiAgICAgIHJlcy5lbmQgPSBwZWckc291cmNlLm9mZnNldChyZXMuZW5kKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwZWckZmFpbChleHBlY3RlZCkge1xyXG4gICAgaWYgKHBlZyRjdXJyUG9zIDwgcGVnJG1heEZhaWxQb3MpIHsgcmV0dXJuOyB9XHJcblxyXG4gICAgaWYgKHBlZyRjdXJyUG9zID4gcGVnJG1heEZhaWxQb3MpIHtcclxuICAgICAgcGVnJG1heEZhaWxQb3MgPSBwZWckY3VyclBvcztcclxuICAgICAgcGVnJG1heEZhaWxFeHBlY3RlZCA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIHBlZyRtYXhGYWlsRXhwZWN0ZWQucHVzaChleHBlY3RlZCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwZWckYnVpbGRTaW1wbGVFcnJvcihtZXNzYWdlLCBsb2NhdGlvbikge1xyXG4gICAgcmV0dXJuIG5ldyBwZWckU3ludGF4RXJyb3IobWVzc2FnZSwgbnVsbCwgbnVsbCwgbG9jYXRpb24pO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcGVnJGJ1aWxkU3RydWN0dXJlZEVycm9yKGV4cGVjdGVkLCBmb3VuZCwgbG9jYXRpb24pIHtcclxuICAgIHJldHVybiBuZXcgcGVnJFN5bnRheEVycm9yKFxyXG4gICAgICBwZWckU3ludGF4RXJyb3IuYnVpbGRNZXNzYWdlKGV4cGVjdGVkLCBmb3VuZCksXHJcbiAgICAgIGV4cGVjdGVkLFxyXG4gICAgICBmb3VuZCxcclxuICAgICAgbG9jYXRpb25cclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwZWckcGFyc2VwZ24oKSB7XHJcbiAgICB2YXIgczAsIHMxLCBzMjtcclxuXHJcbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xyXG4gICAgczEgPSBwZWckcGFyc2V0YWdQYWlyU2VjdGlvbigpO1xyXG4gICAgczIgPSBwZWckcGFyc2Vtb3ZlVGV4dFNlY3Rpb24oKTtcclxuICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xyXG4gICAgczAgPSBwZWckZjAoczEsIHMyKTtcclxuXHJcbiAgICByZXR1cm4gczA7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwZWckcGFyc2V0YWdQYWlyU2VjdGlvbigpIHtcclxuICAgIHZhciBzMCwgczEsIHMyO1xyXG5cclxuICAgIHMwID0gcGVnJGN1cnJQb3M7XHJcbiAgICBzMSA9IFtdO1xyXG4gICAgczIgPSBwZWckcGFyc2V0YWdQYWlyKCk7XHJcbiAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcclxuICAgICAgczEucHVzaChzMik7XHJcbiAgICAgIHMyID0gcGVnJHBhcnNldGFnUGFpcigpO1xyXG4gICAgfVxyXG4gICAgczIgPSBwZWckcGFyc2VfKCk7XHJcbiAgICBwZWckc2F2ZWRQb3MgPSBzMDtcclxuICAgIHMwID0gcGVnJGYxKHMxKTtcclxuXHJcbiAgICByZXR1cm4gczA7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwZWckcGFyc2V0YWdQYWlyKCkge1xyXG4gICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2LCBzNywgczgsIHM5LCBzMTA7XHJcblxyXG4gICAgcGVnJHNpbGVudEZhaWxzKys7XHJcbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xyXG4gICAgczEgPSBwZWckcGFyc2VfKCk7XHJcbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDkxKSB7XHJcbiAgICAgIHMyID0gcGVnJGMwO1xyXG4gICAgICBwZWckY3VyclBvcysrO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgczIgPSBwZWckRkFJTEVEO1xyXG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMSk7IH1cclxuICAgIH1cclxuICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xyXG4gICAgICBzMyA9IHBlZyRwYXJzZV8oKTtcclxuICAgICAgczQgPSBwZWckcGFyc2V0YWdOYW1lKCk7XHJcbiAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xyXG4gICAgICAgIHM1ID0gcGVnJHBhcnNlXygpO1xyXG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMzQpIHtcclxuICAgICAgICAgIHM2ID0gcGVnJGMxO1xyXG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgczYgPSBwZWckRkFJTEVEO1xyXG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTIpOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkge1xyXG4gICAgICAgICAgczcgPSBwZWckcGFyc2V0YWdWYWx1ZSgpO1xyXG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAzNCkge1xyXG4gICAgICAgICAgICBzOCA9IHBlZyRjMTtcclxuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHM4ID0gcGVnJEZBSUxFRDtcclxuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTIpOyB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoczggIT09IHBlZyRGQUlMRUQpIHtcclxuICAgICAgICAgICAgczkgPSBwZWckcGFyc2VfKCk7XHJcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gOTMpIHtcclxuICAgICAgICAgICAgICBzMTAgPSBwZWckYzI7XHJcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBzMTAgPSBwZWckRkFJTEVEO1xyXG4gICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUzKTsgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzMTAgIT09IHBlZyRGQUlMRUQpIHtcclxuICAgICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcclxuICAgICAgICAgICAgICBzMCA9IHBlZyRmMihzNCwgczcpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XHJcbiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xyXG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XHJcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XHJcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xyXG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XHJcbiAgICB9XHJcbiAgICBwZWckc2lsZW50RmFpbHMtLTtcclxuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xyXG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XHJcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUwKTsgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzMDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZXRhZ05hbWUoKSB7XHJcbiAgICB2YXIgczAsIHMxLCBzMjtcclxuXHJcbiAgICBwZWckc2lsZW50RmFpbHMrKztcclxuICAgIHMwID0gcGVnJGN1cnJQb3M7XHJcbiAgICBzMSA9IFtdO1xyXG4gICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xyXG4gICAgaWYgKHBlZyRyMC50ZXN0KHMyKSkge1xyXG4gICAgICBwZWckY3VyclBvcysrO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgczIgPSBwZWckRkFJTEVEO1xyXG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlNSk7IH1cclxuICAgIH1cclxuICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xyXG4gICAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcclxuICAgICAgICBzMS5wdXNoKHMyKTtcclxuICAgICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XHJcbiAgICAgICAgaWYgKHBlZyRyMC50ZXN0KHMyKSkge1xyXG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xyXG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTUpOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XHJcbiAgICB9XHJcbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcclxuICAgICAgczAgPSBpbnB1dC5zdWJzdHJpbmcoczAsIHBlZyRjdXJyUG9zKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHMwID0gczE7XHJcbiAgICB9XHJcbiAgICBwZWckc2lsZW50RmFpbHMtLTtcclxuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xyXG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XHJcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGU0KTsgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzMDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZXRhZ1ZhbHVlKCkge1xyXG4gICAgdmFyIHMwLCBzMSwgczI7XHJcblxyXG4gICAgcGVnJHNpbGVudEZhaWxzKys7XHJcbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xyXG4gICAgczEgPSBbXTtcclxuICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcclxuICAgIGlmIChwZWckcjEudGVzdChzMikpIHtcclxuICAgICAgcGVnJGN1cnJQb3MrKztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHMyID0gcGVnJEZBSUxFRDtcclxuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTcpOyB9XHJcbiAgICB9XHJcbiAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcclxuICAgICAgczEucHVzaChzMik7XHJcbiAgICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcclxuICAgICAgaWYgKHBlZyRyMS50ZXN0KHMyKSkge1xyXG4gICAgICAgIHBlZyRjdXJyUG9zKys7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgczIgPSBwZWckRkFJTEVEO1xyXG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGU3KTsgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBzMCA9IGlucHV0LnN1YnN0cmluZyhzMCwgcGVnJGN1cnJQb3MpO1xyXG4gICAgcGVnJHNpbGVudEZhaWxzLS07XHJcbiAgICBzMSA9IHBlZyRGQUlMRUQ7XHJcbiAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlNik7IH1cclxuXHJcbiAgICByZXR1cm4gczA7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwZWckcGFyc2Vtb3ZlVGV4dFNlY3Rpb24oKSB7XHJcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0O1xyXG5cclxuICAgIHMwID0gcGVnJGN1cnJQb3M7XHJcbiAgICBzMSA9IHBlZyRwYXJzZWxpbmUoKTtcclxuICAgIHMyID0gcGVnJHBhcnNlXygpO1xyXG4gICAgczMgPSBwZWckcGFyc2VnYW1lVGVybWluYXRpb25NYXJrZXIoKTtcclxuICAgIGlmIChzMyA9PT0gcGVnJEZBSUxFRCkge1xyXG4gICAgICBzMyA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBzNCA9IHBlZyRwYXJzZV8oKTtcclxuICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xyXG4gICAgczAgPSBwZWckZjMoczEsIHMzKTtcclxuXHJcbiAgICByZXR1cm4gczA7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwZWckcGFyc2VsaW5lKCkge1xyXG4gICAgdmFyIHMwLCBzMSwgczIsIHMzO1xyXG5cclxuICAgIHMwID0gcGVnJGN1cnJQb3M7XHJcbiAgICBzMSA9IHBlZyRwYXJzZWNvbW1lbnQoKTtcclxuICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xyXG4gICAgICBzMSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBzMiA9IFtdO1xyXG4gICAgczMgPSBwZWckcGFyc2Vtb3ZlKCk7XHJcbiAgICB3aGlsZSAoczMgIT09IHBlZyRGQUlMRUQpIHtcclxuICAgICAgczIucHVzaChzMyk7XHJcbiAgICAgIHMzID0gcGVnJHBhcnNlbW92ZSgpO1xyXG4gICAgfVxyXG4gICAgcGVnJHNhdmVkUG9zID0gczA7XHJcbiAgICBzMCA9IHBlZyRmNChzMSwgczIpO1xyXG5cclxuICAgIHJldHVybiBzMDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZW1vdmUoKSB7XHJcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNSwgczYsIHM3LCBzOCwgczksIHMxMDtcclxuXHJcbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xyXG4gICAgczEgPSBwZWckcGFyc2VfKCk7XHJcbiAgICBzMiA9IHBlZyRwYXJzZW1vdmVOdW1iZXIoKTtcclxuICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xyXG4gICAgICBzMiA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBzMyA9IHBlZyRwYXJzZV8oKTtcclxuICAgIHM0ID0gcGVnJHBhcnNlc2FuKCk7XHJcbiAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcclxuICAgICAgczUgPSBwZWckcGFyc2VzdWZmaXhBbm5vdGF0aW9uKCk7XHJcbiAgICAgIGlmIChzNSA9PT0gcGVnJEZBSUxFRCkge1xyXG4gICAgICAgIHM1ID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICBzNiA9IFtdO1xyXG4gICAgICBzNyA9IHBlZyRwYXJzZW5hZygpO1xyXG4gICAgICB3aGlsZSAoczcgIT09IHBlZyRGQUlMRUQpIHtcclxuICAgICAgICBzNi5wdXNoKHM3KTtcclxuICAgICAgICBzNyA9IHBlZyRwYXJzZW5hZygpO1xyXG4gICAgICB9XHJcbiAgICAgIHM3ID0gcGVnJHBhcnNlXygpO1xyXG4gICAgICBzOCA9IHBlZyRwYXJzZWNvbW1lbnQoKTtcclxuICAgICAgaWYgKHM4ID09PSBwZWckRkFJTEVEKSB7XHJcbiAgICAgICAgczggPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIHM5ID0gW107XHJcbiAgICAgIHMxMCA9IHBlZyRwYXJzZXZhcmlhdGlvbigpO1xyXG4gICAgICB3aGlsZSAoczEwICE9PSBwZWckRkFJTEVEKSB7XHJcbiAgICAgICAgczkucHVzaChzMTApO1xyXG4gICAgICAgIHMxMCA9IHBlZyRwYXJzZXZhcmlhdGlvbigpO1xyXG4gICAgICB9XHJcbiAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xyXG4gICAgICBzMCA9IHBlZyRmNShzNCwgczUsIHM2LCBzOCwgczkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcclxuICAgICAgczAgPSBwZWckRkFJTEVEO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzMDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZW1vdmVOdW1iZXIoKSB7XHJcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNTtcclxuXHJcbiAgICBwZWckc2lsZW50RmFpbHMrKztcclxuICAgIHMwID0gcGVnJGN1cnJQb3M7XHJcbiAgICBzMSA9IFtdO1xyXG4gICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xyXG4gICAgaWYgKHBlZyRyMi50ZXN0KHMyKSkge1xyXG4gICAgICBwZWckY3VyclBvcysrO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgczIgPSBwZWckRkFJTEVEO1xyXG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlOSk7IH1cclxuICAgIH1cclxuICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xyXG4gICAgICBzMS5wdXNoKHMyKTtcclxuICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xyXG4gICAgICBpZiAocGVnJHIyLnRlc3QoczIpKSB7XHJcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XHJcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTkpOyB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDYpIHtcclxuICAgICAgczIgPSBwZWckYzM7XHJcbiAgICAgIHBlZyRjdXJyUG9zKys7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzMiA9IHBlZyRGQUlMRUQ7XHJcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUxMCk7IH1cclxuICAgIH1cclxuICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xyXG4gICAgICBzMyA9IHBlZyRwYXJzZV8oKTtcclxuICAgICAgczQgPSBbXTtcclxuICAgICAgczUgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xyXG4gICAgICBpZiAocGVnJHIzLnRlc3QoczUpKSB7XHJcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XHJcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTExKTsgfVxyXG4gICAgICB9XHJcbiAgICAgIHdoaWxlIChzNSAhPT0gcGVnJEZBSUxFRCkge1xyXG4gICAgICAgIHM0LnB1c2goczUpO1xyXG4gICAgICAgIHM1ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcclxuICAgICAgICBpZiAocGVnJHIzLnRlc3QoczUpKSB7XHJcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XHJcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMTEpOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHMxID0gW3MxLCBzMiwgczMsIHM0XTtcclxuICAgICAgczAgPSBzMTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XHJcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcclxuICAgIH1cclxuICAgIHBlZyRzaWxlbnRGYWlscy0tO1xyXG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XHJcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcclxuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTgpOyB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHMwO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcGVnJHBhcnNlc2FuKCkge1xyXG4gICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczU7XHJcblxyXG4gICAgcGVnJHNpbGVudEZhaWxzKys7XHJcbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xyXG4gICAgczEgPSBwZWckY3VyclBvcztcclxuICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDUpID09PSBwZWckYzQpIHtcclxuICAgICAgczIgPSBwZWckYzQ7XHJcbiAgICAgIHBlZyRjdXJyUG9zICs9IDU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzMiA9IHBlZyRGQUlMRUQ7XHJcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUxMyk7IH1cclxuICAgIH1cclxuICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xyXG4gICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAzKSA9PT0gcGVnJGM1KSB7XHJcbiAgICAgICAgczIgPSBwZWckYzU7XHJcbiAgICAgICAgcGVnJGN1cnJQb3MgKz0gMztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XHJcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTE0KTsgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xyXG4gICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDUpID09PSBwZWckYzYpIHtcclxuICAgICAgICAgIHMyID0gcGVnJGM2O1xyXG4gICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xyXG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTE1KTsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoczIgPT09IHBlZyRGQUlMRUQpIHtcclxuICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDMpID09PSBwZWckYzcpIHtcclxuICAgICAgICAgICAgczIgPSBwZWckYzc7XHJcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDM7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XHJcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUxNik7IH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xyXG4gICAgICAgICAgICBzMiA9IHBlZyRjdXJyUG9zO1xyXG4gICAgICAgICAgICBzMyA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XHJcbiAgICAgICAgICAgIGlmIChwZWckcjAudGVzdChzMykpIHtcclxuICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcclxuICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlNSk7IH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcclxuICAgICAgICAgICAgICBzNCA9IFtdO1xyXG4gICAgICAgICAgICAgIHM1ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcclxuICAgICAgICAgICAgICBpZiAocGVnJHI0LnRlc3QoczUpKSB7XHJcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XHJcbiAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMTcpOyB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHM1ICE9PSBwZWckRkFJTEVEKSB7XHJcbiAgICAgICAgICAgICAgICAgIHM0LnB1c2goczUpO1xyXG4gICAgICAgICAgICAgICAgICBzNSA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChwZWckcjQudGVzdChzNSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xyXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMTcpOyB9XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgczQgPSBwZWckRkFJTEVEO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcclxuICAgICAgICAgICAgICAgIHMzID0gW3MzLCBzNF07XHJcbiAgICAgICAgICAgICAgICBzMiA9IHMzO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMyO1xyXG4gICAgICAgICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMyO1xyXG4gICAgICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XHJcbiAgICAgIHMzID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcclxuICAgICAgaWYgKHBlZyRyNS50ZXN0KHMzKSkge1xyXG4gICAgICAgIHBlZyRjdXJyUG9zKys7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgczMgPSBwZWckRkFJTEVEO1xyXG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUxOCk7IH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoczMgPT09IHBlZyRGQUlMRUQpIHtcclxuICAgICAgICBzMyA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgczIgPSBbczIsIHMzXTtcclxuICAgICAgczEgPSBzMjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBlZyRjdXJyUG9zID0gczE7XHJcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcclxuICAgIH1cclxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xyXG4gICAgICBzMCA9IGlucHV0LnN1YnN0cmluZyhzMCwgcGVnJGN1cnJQb3MpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgczAgPSBzMTtcclxuICAgIH1cclxuICAgIHBlZyRzaWxlbnRGYWlscy0tO1xyXG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XHJcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcclxuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTEyKTsgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzMDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZXN1ZmZpeEFubm90YXRpb24oKSB7XHJcbiAgICB2YXIgczAsIHMxLCBzMjtcclxuXHJcbiAgICBwZWckc2lsZW50RmFpbHMrKztcclxuICAgIHMwID0gcGVnJGN1cnJQb3M7XHJcbiAgICBzMSA9IFtdO1xyXG4gICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xyXG4gICAgaWYgKHBlZyRyNi50ZXN0KHMyKSkge1xyXG4gICAgICBwZWckY3VyclBvcysrO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgczIgPSBwZWckRkFJTEVEO1xyXG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMjApOyB9XHJcbiAgICB9XHJcbiAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcclxuICAgICAgczEucHVzaChzMik7XHJcbiAgICAgIGlmIChzMS5sZW5ndGggPj0gMikge1xyXG4gICAgICAgIHMyID0gcGVnJEZBSUxFRDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XHJcbiAgICAgICAgaWYgKHBlZyRyNi50ZXN0KHMyKSkge1xyXG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xyXG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTIwKTsgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHMxLmxlbmd0aCA8IDEpIHtcclxuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcclxuICAgICAgczAgPSBwZWckRkFJTEVEO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgczAgPSBzMTtcclxuICAgIH1cclxuICAgIHBlZyRzaWxlbnRGYWlscy0tO1xyXG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XHJcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcclxuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTE5KTsgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzMDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZW5hZygpIHtcclxuICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1O1xyXG5cclxuICAgIHBlZyRzaWxlbnRGYWlscysrO1xyXG4gICAgczAgPSBwZWckY3VyclBvcztcclxuICAgIHMxID0gcGVnJHBhcnNlXygpO1xyXG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAzNikge1xyXG4gICAgICBzMiA9IHBlZyRjODtcclxuICAgICAgcGVnJGN1cnJQb3MrKztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHMyID0gcGVnJEZBSUxFRDtcclxuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTIyKTsgfVxyXG4gICAgfVxyXG4gICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XHJcbiAgICAgIHMzID0gcGVnJGN1cnJQb3M7XHJcbiAgICAgIHM0ID0gW107XHJcbiAgICAgIHM1ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcclxuICAgICAgaWYgKHBlZyRyMi50ZXN0KHM1KSkge1xyXG4gICAgICAgIHBlZyRjdXJyUG9zKys7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgczUgPSBwZWckRkFJTEVEO1xyXG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGU5KTsgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xyXG4gICAgICAgIHdoaWxlIChzNSAhPT0gcGVnJEZBSUxFRCkge1xyXG4gICAgICAgICAgczQucHVzaChzNSk7XHJcbiAgICAgICAgICBzNSA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XHJcbiAgICAgICAgICBpZiAocGVnJHIyLnRlc3QoczUpKSB7XHJcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XHJcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGU5KTsgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XHJcbiAgICAgICAgczMgPSBpbnB1dC5zdWJzdHJpbmcoczMsIHBlZyRjdXJyUG9zKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzMyA9IHM0O1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xyXG4gICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xyXG4gICAgICAgIHMwID0gcGVnJGY2KHMzKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xyXG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcclxuICAgICAgczAgPSBwZWckRkFJTEVEO1xyXG4gICAgfVxyXG4gICAgcGVnJHNpbGVudEZhaWxzLS07XHJcbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcclxuICAgICAgczEgPSBwZWckRkFJTEVEO1xyXG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMjEpOyB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHMwO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcGVnJHBhcnNlY29tbWVudCgpIHtcclxuICAgIHZhciBzMDtcclxuXHJcbiAgICBzMCA9IHBlZyRwYXJzZWJyYWNlQ29tbWVudCgpO1xyXG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XHJcbiAgICAgIHMwID0gcGVnJHBhcnNlcmVzdE9mTGluZUNvbW1lbnQoKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gczA7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwZWckcGFyc2VicmFjZUNvbW1lbnQoKSB7XHJcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0O1xyXG5cclxuICAgIHBlZyRzaWxlbnRGYWlscysrO1xyXG4gICAgczAgPSBwZWckY3VyclBvcztcclxuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMTIzKSB7XHJcbiAgICAgIHMxID0gcGVnJGM5O1xyXG4gICAgICBwZWckY3VyclBvcysrO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgczEgPSBwZWckRkFJTEVEO1xyXG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMjQpOyB9XHJcbiAgICB9XHJcbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcclxuICAgICAgczIgPSBwZWckY3VyclBvcztcclxuICAgICAgczMgPSBbXTtcclxuICAgICAgczQgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xyXG4gICAgICBpZiAocGVnJHI3LnRlc3QoczQpKSB7XHJcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XHJcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTI1KTsgfVxyXG4gICAgICB9XHJcbiAgICAgIHdoaWxlIChzNCAhPT0gcGVnJEZBSUxFRCkge1xyXG4gICAgICAgIHMzLnB1c2goczQpO1xyXG4gICAgICAgIHM0ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcclxuICAgICAgICBpZiAocGVnJHI3LnRlc3QoczQpKSB7XHJcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XHJcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMjUpOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHMyID0gaW5wdXQuc3Vic3RyaW5nKHMyLCBwZWckY3VyclBvcyk7XHJcbiAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMTI1KSB7XHJcbiAgICAgICAgczMgPSBwZWckYzEwO1xyXG4gICAgICAgIHBlZyRjdXJyUG9zKys7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgczMgPSBwZWckRkFJTEVEO1xyXG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUyNik7IH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcclxuICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcclxuICAgICAgICBzMCA9IHBlZyRmNyhzMik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcclxuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XHJcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcclxuICAgIH1cclxuICAgIHBlZyRzaWxlbnRGYWlscy0tO1xyXG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XHJcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcclxuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTIzKTsgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzMDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZXJlc3RPZkxpbmVDb21tZW50KCkge1xyXG4gICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNDtcclxuXHJcbiAgICBwZWckc2lsZW50RmFpbHMrKztcclxuICAgIHMwID0gcGVnJGN1cnJQb3M7XHJcbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDU5KSB7XHJcbiAgICAgIHMxID0gcGVnJGMxMTtcclxuICAgICAgcGVnJGN1cnJQb3MrKztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcclxuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTI4KTsgfVxyXG4gICAgfVxyXG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XHJcbiAgICAgIHMyID0gcGVnJGN1cnJQb3M7XHJcbiAgICAgIHMzID0gW107XHJcbiAgICAgIHM0ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcclxuICAgICAgaWYgKHBlZyRyOC50ZXN0KHM0KSkge1xyXG4gICAgICAgIHBlZyRjdXJyUG9zKys7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgczQgPSBwZWckRkFJTEVEO1xyXG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUyOSk7IH1cclxuICAgICAgfVxyXG4gICAgICB3aGlsZSAoczQgIT09IHBlZyRGQUlMRUQpIHtcclxuICAgICAgICBzMy5wdXNoKHM0KTtcclxuICAgICAgICBzNCA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XHJcbiAgICAgICAgaWYgKHBlZyRyOC50ZXN0KHM0KSkge1xyXG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgczQgPSBwZWckRkFJTEVEO1xyXG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTI5KTsgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBzMiA9IGlucHV0LnN1YnN0cmluZyhzMiwgcGVnJGN1cnJQb3MpO1xyXG4gICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcclxuICAgICAgczAgPSBwZWckZjgoczIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcclxuICAgICAgczAgPSBwZWckRkFJTEVEO1xyXG4gICAgfVxyXG4gICAgcGVnJHNpbGVudEZhaWxzLS07XHJcbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcclxuICAgICAgczEgPSBwZWckRkFJTEVEO1xyXG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMjcpOyB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHMwO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcGVnJHBhcnNldmFyaWF0aW9uKCkge1xyXG4gICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczU7XHJcblxyXG4gICAgcGVnJHNpbGVudEZhaWxzKys7XHJcbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xyXG4gICAgczEgPSBwZWckcGFyc2VfKCk7XHJcbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQwKSB7XHJcbiAgICAgIHMyID0gcGVnJGMxMjtcclxuICAgICAgcGVnJGN1cnJQb3MrKztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHMyID0gcGVnJEZBSUxFRDtcclxuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTMxKTsgfVxyXG4gICAgfVxyXG4gICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XHJcbiAgICAgIHMzID0gcGVnJHBhcnNlbGluZSgpO1xyXG4gICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcclxuICAgICAgICBzNCA9IHBlZyRwYXJzZV8oKTtcclxuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQxKSB7XHJcbiAgICAgICAgICBzNSA9IHBlZyRjMTM7XHJcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XHJcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMzIpOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xyXG4gICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XHJcbiAgICAgICAgICBzMCA9IHBlZyRmOShzMyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XHJcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XHJcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xyXG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XHJcbiAgICB9XHJcbiAgICBwZWckc2lsZW50RmFpbHMtLTtcclxuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xyXG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XHJcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUzMCk7IH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gczA7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwZWckcGFyc2VnYW1lVGVybWluYXRpb25NYXJrZXIoKSB7XHJcbiAgICB2YXIgczAsIHMxLCBzMiwgczM7XHJcblxyXG4gICAgcGVnJHNpbGVudEZhaWxzKys7XHJcbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xyXG4gICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgMykgPT09IHBlZyRjMTQpIHtcclxuICAgICAgczEgPSBwZWckYzE0O1xyXG4gICAgICBwZWckY3VyclBvcyArPSAzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgczEgPSBwZWckRkFJTEVEO1xyXG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMzQpOyB9XHJcbiAgICB9XHJcbiAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcclxuICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgMykgPT09IHBlZyRjMTUpIHtcclxuICAgICAgICBzMSA9IHBlZyRjMTU7XHJcbiAgICAgICAgcGVnJGN1cnJQb3MgKz0gMztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XHJcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTM1KTsgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xyXG4gICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDcpID09PSBwZWckYzE2KSB7XHJcbiAgICAgICAgICBzMSA9IHBlZyRjMTY7XHJcbiAgICAgICAgICBwZWckY3VyclBvcyArPSA3O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XHJcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRlMzYpOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xyXG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0Mikge1xyXG4gICAgICAgICAgICBzMSA9IHBlZyRjMTc7XHJcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XHJcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUzNyk7IH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xyXG4gICAgICBzMiA9IHBlZyRwYXJzZV8oKTtcclxuICAgICAgczMgPSBwZWckcGFyc2Vjb21tZW50KCk7XHJcbiAgICAgIGlmIChzMyA9PT0gcGVnJEZBSUxFRCkge1xyXG4gICAgICAgIHMzID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcclxuICAgICAgczAgPSBwZWckZjEwKHMxLCBzMyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xyXG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XHJcbiAgICB9XHJcbiAgICBwZWckc2lsZW50RmFpbHMtLTtcclxuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xyXG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XHJcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUzMyk7IH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gczA7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwZWckcGFyc2VfKCkge1xyXG4gICAgdmFyIHMwLCBzMTtcclxuXHJcbiAgICBwZWckc2lsZW50RmFpbHMrKztcclxuICAgIHMwID0gW107XHJcbiAgICBzMSA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XHJcbiAgICBpZiAocGVnJHI5LnRlc3QoczEpKSB7XHJcbiAgICAgIHBlZyRjdXJyUG9zKys7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XHJcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUzOSk7IH1cclxuICAgIH1cclxuICAgIHdoaWxlIChzMSAhPT0gcGVnJEZBSUxFRCkge1xyXG4gICAgICBzMC5wdXNoKHMxKTtcclxuICAgICAgczEgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xyXG4gICAgICBpZiAocGVnJHI5LnRlc3QoczEpKSB7XHJcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XHJcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckZTM5KTsgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBwZWckc2lsZW50RmFpbHMtLTtcclxuICAgIHMxID0gcGVnJEZBSUxFRDtcclxuICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGUzOCk7IH1cclxuXHJcbiAgICByZXR1cm4gczA7XHJcbiAgfVxyXG5cclxuICBwZWckcmVzdWx0ID0gcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uKCk7XHJcblxyXG4gIGlmIChvcHRpb25zLnBlZyRsaWJyYXJ5KSB7XHJcbiAgICByZXR1cm4gLyoqIEB0eXBlIHthbnl9ICovICh7XHJcbiAgICAgIHBlZyRyZXN1bHQsXHJcbiAgICAgIHBlZyRjdXJyUG9zLFxyXG4gICAgICBwZWckRkFJTEVELFxyXG4gICAgICBwZWckbWF4RmFpbEV4cGVjdGVkLFxyXG4gICAgICBwZWckbWF4RmFpbFBvc1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGlmIChwZWckcmVzdWx0ICE9PSBwZWckRkFJTEVEICYmIHBlZyRjdXJyUG9zID09PSBpbnB1dC5sZW5ndGgpIHtcclxuICAgIHJldHVybiBwZWckcmVzdWx0O1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAocGVnJHJlc3VsdCAhPT0gcGVnJEZBSUxFRCAmJiBwZWckY3VyclBvcyA8IGlucHV0Lmxlbmd0aCkge1xyXG4gICAgICBwZWckZmFpbChwZWckZW5kRXhwZWN0YXRpb24oKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhyb3cgcGVnJGJ1aWxkU3RydWN0dXJlZEVycm9yKFxyXG4gICAgICBwZWckbWF4RmFpbEV4cGVjdGVkLFxyXG4gICAgICBwZWckbWF4RmFpbFBvcyA8IGlucHV0Lmxlbmd0aCA/IGlucHV0LmNoYXJBdChwZWckbWF4RmFpbFBvcykgOiBudWxsLFxyXG4gICAgICBwZWckbWF4RmFpbFBvcyA8IGlucHV0Lmxlbmd0aFxyXG4gICAgICAgID8gcGVnJGNvbXB1dGVMb2NhdGlvbihwZWckbWF4RmFpbFBvcywgcGVnJG1heEZhaWxQb3MgKyAxKVxyXG4gICAgICAgIDogcGVnJGNvbXB1dGVMb2NhdGlvbihwZWckbWF4RmFpbFBvcywgcGVnJG1heEZhaWxQb3MpXHJcbiAgICApO1xyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgU3RhcnRSdWxlczogW1wicGduXCJdLFxyXG4gIFN5bnRheEVycm9yOiBwZWckU3ludGF4RXJyb3IsXHJcbiAgcGFyc2U6IHBlZyRwYXJzZVxyXG59O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chess.js/dist/cjs/pgn.js\n");

/***/ })

};
;